<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[函数防抖与节流]]></title>
    <url>%2F2019%2F01%2F10%2F%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81%2F</url>
    <content type="text"><![CDATA[防抖和节流函数节流的核心是，让一个函数不要执行得太频繁，减少一些过快的调用来节流。 函数去抖就是对于一定时间段的连续的函数调用，只让其执行一次。 应用条件发送一个 ajax 表单，给一个 button 绑定 click 事件，并且监听触发 ajax 请求。如果是 debounce，则用户不管点多少次，都只会发送一次请求；如果是 throttle，不断点击的过程中会间隔发送请求。这时候最好使用 debounce.监听滚动事件判断是否到页面底部自动加载更多，如果是 debounce，则只有在用户停止滚动的时候的才会判断是否到了底部，如果是 throttle，则页面滚动的过程中会间隔判断是否到达底部。 此时最好使用 throttle 函数防抖1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行 * * @param &#123;function&#125; func 回调函数 * @param &#123;number&#125; wait 表示时间窗口的间隔 * @param &#123;boolean&#125; immediate 设置为ture时，是否立即调用函数 * @return &#123;function&#125; 返回客户调用函数 */const debounce = (func, wait = 1000, immediate = true) =&gt; &#123; let timer; let context; let args; // 延迟执行函数 const later = () =&gt; setTimeout(() =&gt; &#123; // 延迟函数执行完毕，清空缓存的定时器序号 timer = null; // 延迟执行的情况下，函数会在延迟函数中执行 // 使用到之前缓存的参数和上下文 if (!immediate) &#123; func.apply(context, args); context = null; args = null; &#125; &#125;, wait); // 这里返回的函数是每次实际调用的函数 return (...params) =&gt; &#123; // 如果没有创建延迟执行函数（later），就创建一个 if (!timer) &#123; timer = later(); // 如果是立即执行，调用函数 // 否则缓存参数和调用上下文 if (immediate) &#123; func.apply(this, params); &#125; else &#123; context = this; args = params; &#125; // 如果已有延迟执行函数（later），调用的时候清除原来的并重新设定一个 // 这样做延迟函数会重新计时 &#125; else &#123; clearTimeout(timer); timer = later(); &#125; &#125;;&#125;;export default debounce; 函数节流1234567891011121314151617const throttle = (func, delay) =&gt; &#123; let last, deferTimer; return () =&gt; &#123; const _args = arguments; const now = +new Date(); if (last &amp;&amp; now &lt; last + delay) &#123; clearTimeout(deferTimer); deferTimer = setTimeout(() =&gt; &#123; last = now; func.apply(this, _args); &#125;, delay); &#125; else &#123; last = now; func.apply(this, _args); &#125; &#125;;&#125;;]]></content>
      <categories>
        <category>面试锦囊</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP status]]></title>
    <url>%2F2019%2F01%2F09%2FHTTP-status%2F</url>
    <content type="text"><![CDATA[HttpStatusHttp Status Code 分类1XX 信息，服务器收到请求，需要请求者继续执行操作2XX 成功，操作被成功接收并处理3XX 重定向，需要进一步的操作以完成请求4XX 客户端错误，请求包含语法错误或无法完成请求5XX 服务器错误，服务器在处理请求的过程中发生了错误 1XX 相关具体的内容 2XX 相关具体的内容 3XX 相关具体的内容 4XX 相关具体的内容 5XX 相关具体的内容]]></content>
  </entry>
  <entry>
    <title><![CDATA[react 相关知识整理]]></title>
    <url>%2F2018%2F12%2F11%2Freact-%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[整理一下脑图里关于 react 的相关的知识。 react 的思想Just The UIreact 只是一个 UI 库，可以当作一个模板引擎，用在各种 mv*的框架中作为 view 层 Virtual DOM什么是 Virtual DOM在 React 中，render 执行的结果得到的并不是真正的 DOM 节点，而是轻量级的 JavaScript 对象，我们称之为 virtual DOM。 Virtual DOM 为什么能提高性能react 在内存中维护 virtual DOM 来处理我们数据的改变，通过 diff 算法，得到一个 patch，然后将这个 patch 放到一个队列里，然后批量的更新这些 patch 到真实 DOM 里。 真实 DOM 的的工作流程：大致分 5 步：创建 DOM tree –&gt; 创建 Style Rules -&gt; 构建 Render tree -&gt; 布局 Layout –&gt; 绘制 Painting操作 DOM，浏览器会从构建 DOM 树开始从头到尾执行一遍流程。然而 DOM 的批量操作不会被合并，只会第一个 DOM 操作处理完之后再重新从构建 DOM 树开始第二个操作，一直到最后一个操作结束。 Virtrual DOM 的工作流程：Virtrual DOM 会对批量的操作合并到 Virtrual DOM 树上，然后根据 diff 算法，查看哪一部分发生了变化，然后将 diff 的内容保存到本地的一个 js 对象里，然后这个对象再 attach 到 DOM 树上，通知浏览器重新绘制。 diff 算法React 通过制定大胆的策略，将 O(n^3) 复杂度的问题转换成 O(n) 复杂度的问题。 diff 策略1、Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。2、拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。3、对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。 基于以上三个前提策略，React 分别对 tree diff、component diff 以及 element diff 进行算法优化，事实也证明这三个前提策略是合理且准确的，它保证了整体界面构建的性能。 tree diff基于策略一，React 对树的算法进行了简洁明了的优化，即对树进行分层比较，两棵树只会对同一层次的节点进行比较。React 通过 updateDepth 对 Virtual DOM 树进行层级控制，只会对相同颜色方框内的 DOM 节点进行比较，即同一个父节点下的所有子节点。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。 component diffReact 是基于组件构建应用的，对于组件间的比较所采取的策略也是简洁高效。如果是同一类型的组件，按照原策略继续比较 virtual DOM tree。如果不是，则将该组件判断为 dirty component，从而替换整个组件下的所有子节点。对于同一类型的组件，有可能其 Virtual DOM 没有任何变化，如果能够确切的知道这点那可以节省大量的 diff 运算时间，因此 React 允许用户通过 shouldComponentUpdate() 来判断该组件是否需要进行 diff。 element diff当节点处于同一层级时，React diff 提供了三种节点操作，分别为：INSERT_MARKUP（插入）、MOVE_EXISTING（移动）和 REMOVE_NODE（删除）。INSERT_MARKUP，新的 component 类型不在老集合里， 即是全新的节点，需要对新节点执行插入操作。MOVE_EXISTING，在老集合有新 component 类型，且 element 是可更新的类型，generateComponentChildren 已调用 receiveComponent，这种情况下 prevChild=nextChild，就需要做移动操作，可以复用以前的 DOM 节点。REMOVE_NODE，老 component 类型，在新集合里也有，但对应的 element 不同则不能直接复用和更新，需要执行删除操作，或者老 component 不在新集合里的，也需要执行删除操作。 Data Flow单向数据流，只需要关心从数据怎么得出界面就行。由数据驱动页面的方式，可以轻松让用户界面和数据保持一致。更新 DOM 的数据总是从顶层流下来，用户事件不直接操作 DOM，而是操作顶层数据 react 解决了前端哪些痛点1、组件化，模块化 ：react 组件化，和基于 webpack 可以使用 Es6 或 CommonJs 的写法实现模块化代码2、开发效率：React 的代码基本就是组件的组合，分而治之的方式让代码的可阅读性很高，容易理解3、运行效率：React 使用 Virtual DOM，通过 diff 算法，更新特定的 dom，加快了效率4、可维护性：维护性强5、用户体验：spa react 生命周期react 完整的生命周期react 的生命周期包括： 数据请求react 在 16.3 中，将 componentWillMount 标为不安全的生命周期函数，所以需要在 componentDidMount 里面获取数据。为什么不在 constructor？constructor 被调用是在组件准备要挂载的最一开始，所以此时组件尚未挂载到网页上，而且在未渲染的时候，数据获取到也不会存在。 性能优化shouldComponentUpdate ：组件接受到新属性或者新状态的时候（可以返回 false，接收数据后不更新，阻止 render 调用，后面的函数不会被继续执行了） 这个方法用来判断是否需要调用 render 方法重新描绘 dom。因为 dom 的描绘非常消耗性能，如果我们能在 shouldComponentUpdate 方法中能够写出更优化的 dom diff 算法，可以极大的提高性能。 JSX 相关JSX 怎么被浏览器认识JSX 是 React 对 JS 语法的拓展，需要编译后才能正确使用它，JSX 的构建非常简洁明 JSX 是需要编译才能被浏览器识别的，它就是被 Babel 编译的，具体说来是被 babel-preset-react 来编译的。不过 Babel 的最主要目的其实并非编译 JSX，Babel 应该算是一个编译平台，其主要目的是转换你在代码中使用了的 ES6 甚至 ES7 语法为浏览器识别的 ES5 语法（babel-core,babel-preset-es2015 模块）。 Babel 转译器会把 JSX 转换成一个名为 React.createElement() 的方法调用。 本质上来讲，JSX 只是为 React.createElement(component, props, …children) 方法提供的语法糖。 12const element = &lt;h1 className="greeting"&gt;Hello, world!&lt;/h1&gt;;const element = React.createElement('h1', &#123; className: 'greeting' &#125;, 'Hello, world!'); JSX 组件的首字母为什么要大写当元素类型以小写字母开头时，它表示一个内置的组件，如 &lt;div&gt; 或 &lt;span&gt;，并将字符串 ‘div’ 或 ‘span’ 传 递给 React.createElement。 以大写字母开头的类型，如 编译为 React.createElement(Foo)，并它正对应于你在 JavaScript 文件中定义或导入的组件。 函数绑定 thisreact 中函数绑定 this 有那么几种方法：1、箭头函数不管是在类里面，还是在 render 里面，都可以用箭头函数，箭头函数会自动绑定 this。 2、在构造函数里绑定 this 3、在 render 里用.bind(this) 1234567891011121314151617181920212223242526class App extends React.Component &#123; constructor(props) &#123; super(props); this.handleClick3 = this.handleClick.bind(this); &#125; handleClick() &#123; console.log('this &gt; ', this); &#125; handleClick2 = () =&gt; &#123; console.log('this &gt; ', this); &#125; handleClick3() &#123; console.log('this &gt; ', this); &#125; handleClick4() &#123; console.log('this &gt; ', this); &#125; render() &#123; return ( &lt;div onClick=&#123;this.handleClick.bind(this)&#125;&gt;test&lt;/div&gt; &lt;div onClick=&#123;this.handleClick2&#125;&gt;test2&lt;/div&gt; &lt;div onClick=&#123;this.handleClick3&#125;&gt;test3&lt;/div&gt; &lt;div onClick=&#123;e=&gt;handleClick4(e)&#125;&gt;test4&lt;/div&gt; ) &#125;&#125; 组件组件的三种定义方法1、纯函数组件 123function HelloComponent(props /* context */) &#123; return &lt;div&gt;Hello &#123;props.name&#125;&lt;/div&gt;;&#125; 2、使用 React.createClass 创建组件 12345678910111213141516171819202122232425262728293031const InputControlES5 = React.createClass(&#123; propTypes: &#123; //定义传入props中的属性各种类型 initialValue: React.PropTypes.string &#125;, defaultProps: &#123; //组件默认的props对象 initialValue: '' &#125;, // 设置 initial state getInitialState: function() &#123; //组件相关的状态对象 return &#123; text: this.props.initialValue || 'placeholder' &#125;; &#125;, handleChange: function(event) &#123; this.setState(&#123; //this represents react component instance text: event.target.value &#125;); &#125;, render: function() &#123; return ( &lt;div&gt; Type something: &lt;input onChange=&#123;this.handleChange&#125; value=&#123;this.state.text&#125; /&gt; &lt;/div&gt; ); &#125;&#125;); 3、使用 ES6 的类，继承 React.Component 来创建组件 1234567891011121314151617181920212223class InputControlES6 extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; text: props.initialValue || 'placeholder' &#125;; &#125; handleChange = event =&gt; &#123; this.setState(&#123; text: event.target.value &#125;); &#125;; render() &#123; return ( &lt;div&gt; Type something: &lt;input onChange=&#123;this.handleChange&#125; value=&#123;this.state.text&#125; /&gt; &lt;/div&gt; ); &#125;&#125;]]></content>
      <categories>
        <category>面试锦囊</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[作用域及闭包]]></title>
    <url>%2F2018%2F12%2F06%2F%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%8F%8A%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[想搞一个大事情！ 开篇点题，嗯，这个题目真的是一个大事情。感觉要准备好多东西，要理解很多东西。 什么是作用域作用域，看了一些书啊，文章啊，似乎对作用域的解释都是那么几句话，比如《你不知道的 JavaScript（上）》里说，作用域就是一套设计良好的用来存储变量规则 。mqyqingfeng (冴羽) 说，作用域是指程序源代码中定义变量的区域。 嗯，反正就是一个区域，用来定义变量，存储变量，在需要的时候找到变量的地方。 为什么需要作用域为什么需要作用域呢？有一个最小访问原则。设置作用域的一个优势，是为你的代码提供了一个安全层级。计算机安全中，有个常规的原则是：用户只能访问他们当前需要的东西。这叫做最小访问原则。这个原则应用于编程语言设计，在大多数编程语言（包括 JavaScript）中就被称为作用域。当然，设置作用域还有一些提高性能，减少 bug 的优势，还能解决不同范围内的同名变量命名的问题等。 JS 中的作用域JavaScript 中的采用的是词法作用域，也就是静态作用域。JavaScript 中的作用域包括 全局作用域 函数作用域 块级作用域 词法作用域（静态作用域） 动态作用域 全局作用域直接编写在 script 标签中的 JS 代码，都在全局作用域。变量的生命周期：在页面打开时创建，在页面关闭时销毁，全局作用域中，创建变量都会作为 window 对象的属性保存，创建的函数都会作为 window 对象的方法保存，全局作用域中的变量和函数都是全局变量，在页面的任何部分都可以访问的到 在函数中，未使用var关键字定义的变量都是全局变量。 函数作用域块级作用域词法作用域动态作用域闭包作用域变量作用域链]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react 主要概念笔记]]></title>
    <url>%2F2018%2F11%2F08%2Freact-%E4%B8%BB%E8%A6%81%E6%A6%82%E5%BF%B5%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[React v16.5.2 文档学习 Hello WorldReact 应用的构成模块：元素和组件 JSX 简介JSX 是一种 JavaScript 的语法扩展，推荐在 React 中使用 JSX 来描述用户界面。可以在 JSX 中任意的使用 JS 表达式，但是 JS 表达式要放在大括号里。 JSX 本身也是一种表达式，在编译之后，JSX 会被转化成普通的 JS 对象。JSX 的中，ReactDOM 使用小驼峰来命名。 JSX 防注入攻击，因为 React DOM 在渲染之前默认会过滤所有传入的值，所有的内容在渲染之前都被转换成了字符串。可以有效的防止 XSS 攻击。 JSX 代表 Objects，Babel 转译器会把 JSX 专换成一个名为React.createElement()的方法调用。React.createElement()会返回一个对象，这个对象被称为“React 元素”。React 通过读取这些对象来构建 DOM 并且保持数据一致。 元素渲染元素是构成 React 应用的最小单位。元素用来描述在屏幕上看到的东西，React 中的元素是普通的 JS 对象，ReactDOM 可以确保浏览器 DOM 的数据和 react 元素保持一致。 在 Html 页面里定义一个id=&quot;root&quot;根节点。然后通过ReactDOM.render()方法，将 React 元素渲染到根 DOM 里。 更新元素渲染，是创建一个新的元素，然后用ReactDOM.render()方法，将 React 元素渲染到根 DOM 里。但是，React DOM 会比较元素内容先后的不同，然后在渲染过程中，只更新改变了的部分。 组件&amp;props组件是独立的可复用的 ui 部件，从概念上看就像是函数，可以接受任意的输入值（props），并返回一个 React 元素。 定义组件，可以是一个 JavaScript 函数或者用一个 ES6 的 class 来定义一个组件。React 元素可以是 DOM 标签，也可以是自定义的组件。组件名称必须以大写字母开头。并且在使用组件时，需要引入或者定义它。组件可以在输出中引用其他组件，但是组件的返回值只能有一个根元素。 Props 的只读性，无论是使用函数或者时类来声明一个组件，它不允许修改自己的 props。所有的 React 组件必须像纯函数那样使用它们的 props。 State&amp;生命周期使用类来声明一个组件，可以允许使用局部状态，生命周期钩子等。使用类声明组件时，使用constructor把 props 传递到组件里: 1234constructor(props) &#123; super(props); this.state = &#123;date: new Date()&#125;;&#125; 生命周期：当组件第一次加载到 DOM 中的时候，称为挂载；当组件生成的 DOM 被移除时，称为卸载。 正确的使用状态：1、不要直接更新状态，直接更新不会重新渲染组件，应使用this.setState({})来更新。2、状态更新可能是异步的。3、状态更新合并，也可以独立更新。 数据自顶向下流动。父组件和子组件都不知道某一个组件是否有状态，所以状态被称为局部状态，除了拥有并设置它的组件外，其他组件不可访问。组件可以选择状态，当作属性传给子组件。这被称为单向数据流。任何状态始终由某些特定组件所有，并且从该状态导出的任何数据或 UI 只能影响树中下方的组件。 在 React 应用程序中，组件是有状态还是无状态被认为是可能随时间而变化的组件的实现细节。 可以在有状态组件中使用无状态组件，反之亦然。 事件处理React 的事件绑定属性的命名采用驼峰式写法，并为其赋值一个事件处理函数。在函数中，要调用preventDefault()方法来阻止默认行为。 事件绑定 this：因为类的方法不会默认绑定 this，所以用 ES5 写函数的时候，在调用的时候，需要在 constructor 里绑定 this。也可以用 ES6 的箭头函数来写。 用 ES6 class 语法来定义一个组件的时候，事件处理器会成为类的一个方法 向事件处理程序传递参数 12&lt;button onClick=&#123;(e) =&gt; this.deleteRow(id, e)&#125;&gt;Delete Row&lt;/button&gt;&lt;button onClick=&#123;this.deleteRow.bind(this, id)&#125;&gt;Delete Row&lt;/button&gt; 条件渲染可以使用 if..else..语句来条件渲染。可以使用与运算符 &amp;&amp;来条件渲染可以使用 JavaScript 的条件运算符 condition ? true : false 来条件渲染 阻止条件渲染，可以用三目运算符，让 render 方法返回 null 而不是它的渲染结果即可实现。组件的 render 方法返回 null 并不会影响该组件生命周期方法的回调。 列表 &amp; Keys使用 map()函数，让每一个元素返回一个标签或者组件。 Keys 可以在 DOM 中的某些元素被增加或删除的时候帮助 React 识别哪些元素发生了变化。因此你应当给列表中的每一个元素赋予一个确定的标识 元素的 key 在他的兄弟元素之间应该唯一 表单其值由 React 控制的输入表单元素称为“受控组件” 通过受控组件，来构造一个处理提交表单并可访问用户输入表单数据的函数在 react 中，受控组件需要使用 this.setState 来进行更新。使用”受控组件”,每个状态的改变都有一个与之相关的处理函数。这样就可以直接修改或验证用户输入。 状态提升使用 react 经常会遇到几个组件需要共用状态数据的情况。这种情况下，我们最好将这部分共享的状态提升至他们最近的父组件当中进行管理。在 React 应用中，对应任何可变数据理应只有一个单一“数据源”。通常，状态都是首先添加在需要渲染数据的组件中。此时，如果另一个组件也需要这些数据，你可以将数据提升至离它们最近的父组件中。你应该在应用中保持 自上而下的数据流，而不是尝试在不同组件中同步状态。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux 服务器安装nginx及配置]]></title>
    <url>%2F2018%2F11%2F02%2Flinux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85nginx%2F</url>
    <content type="text"><![CDATA[在 linux 服务器上安装 nginx，是想把自己写的项目配置到服务器上, 于是就研究了一下 nginx 安装 nginx我是用 yum 安装的 nginx，简单快捷，命令也简单 1234567891011121314151617181920212223242526272829303132333435363738yum -y install nginx;已加载插件：fastestmirror, security设置安装进程Loading mirror speeds from cached hostfile解决依赖关系--&gt; 执行事务检查---&gt; Package nginx.i686 0:1.0.15-12.el6 will be 安装--&gt; 完成依赖关系计算依赖关系解决======================================================================================================================================== 软件包 架构 版本 仓库 大小========================================================================================================================================正在安装: nginx i686 1.0.15-12.el6 epel 410 k事务概要========================================================================================================================================Install 1 Package(s)总下载量：410 kInstalled size: 1.1 M下载软件包：nginx-1.0.15-12.el6.i686.rpm | 410 kB 00:00运行 rpm_check_debug执行事务测试事务测试成功执行事务Warning: RPMDB altered outside of yum. 正在安装 : nginx-1.0.15-12.el6.i686 1/1 Verifying : nginx-1.0.15-12.el6.i686 1/1已安装: nginx.i686 0:1.0.15-12.el6完毕！ 然后可以查看一下 nginx 的版本 12nginx -vnginx version: nginx/1.12.2 然后记一下 nginx 的启动，停止，和重启的问题就好了 12345678// 启动服务service nginx start// 关闭服务service nginx stop// 重启服务service nginx restart 然后把项目记得放在／usr 目录下，然后你就需要配置 nginx.conf 了 我的 nginx.conf 是放在/etc/nginx/目录下，打开目录。 1vim nginx.conf 然后可以在 vim 里处理 nginx.conf 文件 默认配置可以不动。 123456789101112131415161718192021222324// 由于是单页应用虚拟路由的原因，需要将nginx的所有请求都转发到index.html页面，所以需要修改配置文件：server &#123; listen 80 default_server; listen [::]:80 default_server; server_name _; root /usr/project/projectName/dist; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location ~* html &#123; rewrite .* /index.html break; root /usr/project/projectName/dist/; &#125; error_page 404 /404.html; location = /index.html &#123; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125; &#125; 然后重启nginx服务，在浏览器里输入ip地址就可以看到你的项目啦～]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端性能优化]]></title>
    <url>%2F2018%2F10%2F10%2F%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[最近在整理前端面试的一些知识点，感觉前端的性能优化是一个很重要的方面，还是得好好整理一下。 1问题：前端优化有那些解决方案？ 前端性能优化的原则以更好的用户体验为标准,具体就是要实现以下两个目标 多使用内存、缓存或者其他方法 减少 CPU 和GPU 计算，更快展现 而前端优化的方向有两个： 减少页面体积，提升网络加载 优化页面渲染 具体的方案有： 减少页面体积，提升网络加载：1、静态资源压缩合并 webpack 打包，把js，css，等文件压缩打包2、静态资源缓存]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript原型学习]]></title>
    <url>%2F2018%2F10%2F09%2FJavascript%E5%8E%9F%E5%9E%8B%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[prototype是函数才有的一个属性。 函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型。 原型可以理解成：每一个 JS 对象（null 除外），在创建的时候，就会与之关联另一个对象，这个对象就是我们说的原型。每个对象都会从原型继承属性。 每一个 JS 对象（null 除外）都有一个_proto_的属性，该属性指向该对象的原型。 每一个原型都会有一个constructor属性，指向关联的构造函数。 原型也是一个对象，是通过Object()构造函数生成的。 Object.prototype没有原型 关系图]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[for 循环作用域的探究]]></title>
    <url>%2F2018%2F09%2F29%2Ffor-%E5%BE%AA%E7%8E%AF%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%8E%A2%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[之前看到这么一个题，问最后输出什么？ 1for (let i = (setTimeout(() =&gt; console.log(i), 2333), 0); i &lt; 2; i++) &#123;&#125; 答案是在 2333ms 之后，输出了 0。 一直在想什么原因。今天闲着没事重新在看阮一峰 es6 入门，然后想起来这个问题。 es6 入门的 let 和 const 的那一章里，他说了一个问题： for 循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。 1234567for (let i = 0; i &lt; 3; i++) &#123; let i = 'abc'; console.log(i);&#125;// abc// abc// abc 因为输出了 3 遍 abc，这表明函数内部的变量 i 与循环变量 i 不在同一个作用域，有各自单独的作用域。 我 google 了一下，发现： 1for (let i = 0; i &lt; 3; i++) 在声明的（）内存在一个变量 i，会存在 JavaScript 引擎内部。 每一次循环的时候， JavaScript 引擎内部会记住上一轮循环的值，然后将新的 i 的值赋值给 i。 1234&#123; let i = 'abc'; console.log(i);&#125; 在循环体里面，这是一个新的作用域，重新声明一个 i；不会影响（）里 i 的值。 12345for (let i = 0; i &lt; 3; i++) &#123; i = 'abc'; console.log(i);&#125;// abc 但是如果不声明 i，直接给 i 赋值，会影响（）里 i 的值，说明（）是循环体的上一级作用域，在循环体里直接改变 i 的值会影响上一级作用域里的 i 值。 回到最初的那道题里面： for 循环有三个语句： 1234for (语句 1; 语句 2; 语句 3) &#123; 被执行的代码块 &#125; 语句 1 在循环（代码块）开始前执行，就是 for()之前开始执行，只会执行一次。并且在 js 引擎里记住这个变量，他的值随着条件改变。 语句 2 定义运行循环（代码块）的条件。 语句 3 在循环（代码块）已被执行之后执行。 语句1如下： 1let i = (setTimeout(() =&gt; console.log(i), 2333), 0); 这个表达式，同步执行的时候，因为括号里是逗号表达式，所以返回了 0，i=0；同时把 setTimeout 放到了 macrotasks 中。并继续向下执行。 这个题目，就会变成这样了 1234567&#123; let o = (setTimeout(() =&gt; console.log(o), 2333), 0); for (let i = o; i &lt; 2; i++) &#123; let j = i; console.log(j); &#125;&#125; 就好理解了]]></content>
      <categories>
        <category>Demo练习</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现一个解构数组的方法]]></title>
    <url>%2F2018%2F09%2F10%2F%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%A7%A3%E6%9E%84%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一道笔试题： 实现 destructuringArray 方法，达到如下效果 123// destructuringArray( [1,[2,4],3], "[a,[b],c]" );// result// &#123; a:1, b:2, c:3 &#125; 123456789101112131415161718192021222324252627const targetArray = [1, [2, 3], 4];const formater = '[a, [b], c]';const formaterArray = ['a', ['b'], 'c'];const destructuringArray = (values, keys) =&gt; &#123; try &#123; const obj = &#123;&#125;; if (typeof keys === 'string') &#123; keys = JSON.parse(keys.replace(/\w+/g, '"$&amp;"')); &#125; const iterate = (values, keys) =&gt; keys.forEach((key, i) =&gt; &#123; if (Array.isArray(key)) iterate(values[i], key); else obj[key] = values[i]; &#125;); iterate(values, keys); return obj; &#125; catch (e) &#123; console.error(e.message); &#125;&#125;;console.dir(destructuringArray(targetArray, formater));console.dir(destructuringArray(targetArray, formaterArray));]]></content>
      <categories>
        <category>面试锦囊</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何判断一个整数是否在40亿个整数中？]]></title>
    <url>%2F2018%2F09%2F10%2F%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E6%98%AF%E5%90%A6%E5%9C%A840%E4%BA%BF%E4%B8%AA%E6%95%B4%E6%95%B0%E4%B8%AD%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[题目：我有 40 亿个整数，再给一个新的整数，我需要判断新的整数是否在 40 亿个整数中，你会怎么做（每个整数是32位的）？ 一个数在不在就是两个状态，在或者不在，就可以用1个位来代表。每个整数是32位的，那么所有的整数也就2^32个，大概42亿个数左右。可以申请2^32的位，把每一个整数都覆盖了，40亿个数的位分别为1，剩下的位为0。新的整数，就可以跟进它的大小来判断相应的位，比如1245，就去看1245位是1还是0来判断是否在这40亿个整数中。 2^32个位，就是2^29个字节，也就是500M左右。 位图法（bitmap） 链接：漫画：如何判断一个数是否在 40 亿个整数中]]></content>
      <categories>
        <category>面试锦囊</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于xss和csrf]]></title>
    <url>%2F2018%2F09%2F06%2F%E5%85%B3%E4%BA%8Exss%E5%92%8Ccsrf%2F</url>
    <content type="text"><![CDATA[XSSxss 是跨网站指令码，是代码注入的一种，它允许恶意使用者将程式码注入到网页上，其他使用者在观看网页时就会受到影响。这类攻击通常包含了 HTML 以及使用者端脚本语言。 攻击方式: XSS 通过修改 HTML 节点或者执行 JS 代码来攻击网站。比如通过 url 来在页面上添加 html 后者 js 文件。 防止: 最普遍的方法，是将输出的内容进行转义，比如对于引号，尖括号，斜杠进行转义等，再就是设置白名单或者黑名单等。比如只允许加载本站资源等。。 CSRFcsrf 跨站请求伪造，是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。简单点说，CSRF 就是利用用户的登录态发起恶意请求。 防止：防范 CSRF 可以遵循以下几种规则： Get 请求不对数据进行修改 不让第三方网站访问到用户 Cookie 阻止第三方网站请求接口 请求时附带验证信息，比如验证码或者 token]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>前端安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些JS小技巧]]></title>
    <url>%2F2018%2F08%2F23%2F%E4%B8%80%E4%BA%9BJS%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[整理一些自己遇到的 js 小技巧，希望以后能变成一个炫技派，哈哈哈～ 0、对象深拷贝的小方法 1JSON.parse(JSON.stringify(obj)); 1、数组去重 1const deleteSame = array =&gt; [...new Set(array)]; 去重只能基本数据类型的，String，Number，Boolean, undefined, null, Symbol。如果是对象，都不会去重。 2、用Object.is(a, b) 代替 === 123if (Object.is(a, b)) &#123; //TODO&#125; 3、用+ a操作符去代替Number(a) 1234const a = '123';typeof a; // "string"typeof Number(a); // "number"typeof +a; // "number" 4、短路操作 12345if (!foo) &#123; foo = bar;&#125;foo = foo || bar; 5、通过!!确认 bool 值 1234const foo = false;if (!!foo) &#123; // TODO&#125; 6、判断变量的类型 12345678Object.prototype.toString.call(data);// "[object String]"// "[object Array]"// "[object Number]"// "[object Object]"// "[object Function]"// "[object Undefined]"// "[object RegExp]" 7、str.trim()来清除前后空格 8、遍历对象的方法 1234const obj = &#123; '0': 'a', '1': 'b', '2': 'c' &#125;;Object.keys(obj).forEach(function(key) &#123; console.log(key, obj[key]);&#125;); 9、删除数组里的某个元素 123let arr = [1, 2, 3, 4, 5, 6, 7];const target = 3;arr = arr.filter(v =&gt; !Object.is(v, target));]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解虚拟DOM]]></title>
    <url>%2F2018%2F08%2F23%2F%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9FDOM%2F</url>
    <content type="text"><![CDATA[什么是虚拟 DOM Virtual DOM 就是一个模拟 DOM 树的 Javascript 的对象。 虚拟的 DOM 的核心思想 对复杂的文档 DOM 结构，提供一种方便的工具，进行最小化地 DOM 操作。 React 工作原理 React 使用了虚拟 DOM，每次状态更新，React 比较虚拟 DOM 的差异之后，再更改变化的内容，最后统一由 React 去修改真实 DOM、完成页面的更新、渲染。 Virtrual DOM 和真实 DOM 的区别 真实 DOM 的的工作流程：大致分 5 步：创建 DOM tree –&gt; 创建 Style Rules -&gt; 构建 Render tree -&gt; 布局 Layout –&gt; 绘制 Painting 第一步，用 HTML 分析器，分析 HTML 的各种元素，构建一颗 DOM 树。 第二步：用 CSS 分析器，分析 CSS 文件和元素上的 inline 样式，生成页面的样式表。 第三步：将上面的 DOM 树和样式表，关联起来，构建一颗 Render 树。这一过程又称为 Attachment。每个 DOM 节点都有 attach 方法，接受样式信息，返回一个 render 对象（又名 renderer）。这些 render 对象最终会被构建成一颗 Render 树。 第四步：有了 Render 树后，浏览器开始布局，会为每个 Render 树上的节点确定一个在显示屏上出现的精确坐标值。 第五步：Render 数有了，节点显示的位置坐标也有了，最后就是调用每个节点的 paint 方法，让它们显示出来。 然而操作 DOM，浏览器会从构建 DOM 树开始从头到尾执行一遍流程。然而 DOM 的批量操作不会被合并，只会第一个 DOM 操作处理完之后再重新从构建 DOM 树开始第二个操作，一直到最后一个操作结束。 Virtrual DOM 的工作流程：Virtrual DOM 会对批量的操作合并到 Virtrual DOM 树上，然后根据 diff 算法，查看哪一部分发生了变化，然后将 diff 的内容保存到本地的一个 js 对象里，然后这个对象再 attach 到 DOM 树上，通知浏览器重新绘制。 实现一个 Virtrual DOM 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//虚拟dom，参数分别为标签名、属性对象、子DOM列表const VElement = (tagName, props, children) =&gt; &#123; //保证只能通过如下方式调用：new VElement if (!(this instanceof VElement)) &#123; return new VElement(tagName, props, children); &#125; //可以通过只传递tagName和children参数 if (util.isArray(props)) &#123; children = props; props = &#123;&#125;; &#125; //设置虚拟dom的相关属性 this.tagName = tagName; this.props = props || &#123;&#125;; this.children = children || []; this.key = props ? props.key : void 666; let count = 0; util.each(this.children, (child, i) =&gt; &#123; if (child instanceof VElement) &#123; count += child.count; &#125; else &#123; children[i] = "" + child; &#125; count++; &#125;); this.count = count;&#125;;VElement.prototype.render = () =&gt; &#123; //创建标签 const el = document.createElement(this.tagName); //设置标签的属性 const props = this.props; for (let propName in props) &#123; const propValue = props[propName]; util.setAttr(el, propName, propValue); &#125; //依次创建子节点的标签 util.each(this.children, child =&gt; &#123; //如果子节点仍然为velement，则递归的创建子节点，否则直接创建文本类型节点 const childEl = child instanceof VElement ? child.render() : document.createTextNode(child); el.appendChild(childEl); &#125;); return el;&#125;; 对一个虚拟的 DOM 对象 VElement，调用其原型的 render 方法，就可以产生一颗真实的 DOM 树]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[偷得浮生半日闲]]></title>
    <url>%2F2018%2F08%2F19%2F%E5%81%B7%E5%BE%97%E6%B5%AE%E7%94%9F%E5%8D%8A%E6%97%A5%E9%97%B2%2F</url>
    <content type="text"><![CDATA[没有什么事情是理所应当的，所有的结果都是之前付出努力的一种回报。 我是比较相信这样的努力和付出的论点的。毕竟付出努力，肯定会有回报，不一定会是在你期望的方面，但是他也会有结果，也许是另一个方面的回报。 这只是我的一段碎碎念。 工作的第 8 个月零 1 天，感觉我需要更多方面的进步了。感觉到了很大的压力，最近整个人都比较的佛系，靠着工作，拿着薪水，奋斗的动力感觉少了很多。当工作忙的时候，就没时间写博客了，时间都浪费在了铺页面，联调，提测，改 bug 的过程中。我觉得我需要有一些规划，让自己能在工作期间，也能学习到一些东西。 前几天，还被说每天三个小时的通勤时间，竟然还不搬家。平时都不觉得，路上的时间总觉得都过的很快，但是有一天，突然想了一下，就是觉得，每天三个小时通勤时间确实好长啊，每天好累啊 balaba，但是又一想，唉，每天这 3 个小时都被我浪费掉了。有时候在书签里存了好多想看的书啊，想看的网页啊，教程啊，到了地铁上，就没了兴趣，游戏真好玩，虎扑真好玩，知乎真好玩，歌真好听等等等等。 我觉得一个人的自制力或者自控力，是不会随着长大逐渐提高的，除非有什么事情逼迫着你。 这就是一种个人的体验，也算是一种总结吧。觉得自己会写好多东西出来。其实我也写不动了。但是我想我可以没事给自己打一点鸡血，让自己兴奋一些。 加油吧，少年（也许已经不是少年了）。 想想 2018 年来的时候，我还在票圈里说，我出生的时候就比别的孩子长得老，2017 过去了，我很想念它。希望不要在 2019 年来的时候，继续怀念 2018.]]></content>
      <categories>
        <category>浮生小记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[axios jquery.ajax fetch 区别]]></title>
    <url>%2F2018%2F08%2F03%2Faxios-jquery-ajax-fetch-%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[最近项目在用 axios，好像出现好久了，才开始学习。 这三个都是发起 http 请求的东西,都算是对原生 XHR 的封装。从 XHR -&gt; Jquery ajax() -&gt; fetch -&gt; axios现在来分别看一下这三个东西 Jquery ajax它是对原生 XHR 的封装，支持 JsonP，是 MVC 编程的一种请求方式，已经逐渐的不适应前端的 MVVM 框架的潮流了。而且，在项目中使用的时候，要使用 ajax，就得把 jquery 都引进来，很冗余。 12345678$.ajax(&#123; type: "POST", url: url, data: data, dataType: dataType, success: function() &#123;&#125;, error: function() &#123;&#125;&#125;); fetch fetch 是一个出现比较久的，但是依旧有好多不兼容的 ajax 的替代品。采用了 es 的 promise。fetch 不会默认的传 cookies，需要添加配置项credentials: &#39;include&#39;fetch 只会对网络请求错误报错，400，500 等问题会进入 then，而不会进入 catch。fetch 不支持超时的问题。fetch 不能监听请求的进度，而 XHR 可以。 1234567try &#123; let response = await fetch(url); let data = response.json(); console.log(data);&#125; catch(e) &#123; console.log("Oops, error", e);&#125; axios 是一个很高档的东西。它不仅支持浏览器的数据请求，还支持 node 创建 http 请求。它和 fetch 一样，也是基于 Promise 的 API，能够从客户端支持防止 CSRF，提供了很多接口，可以并发等。 12345678910axios(&#123; method: "GET", url: url&#125;) .then(res =&gt; &#123; console.log(res); &#125;) .catch(err =&gt; &#123; console.log(err); &#125;);]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-router 4.0使用笔记]]></title>
    <url>%2F2018%2F07%2F23%2Freact-router-4-0%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[最近项目里的 react-router 从 3.0 更新到了 4.0，重新学习了一下 react-router 的东西，感觉从 3 到 4，变化还是很多的。通过react-router 4.0 中文文档和一些其他的教程，大概学会了如何使用。记下来防止以后忘记了。。 v3 的时候，是把所有的路由都写在一个地方，通常就是组件和路由分开。到了 v4，路由就变成了一个和 UI 组件并列的组件，在你需要的地方把路由组件写在合适的地方。不在需要用组件的嵌套来实现路由嵌套。 exactexact 关键字，可以让路由只匹配一个 path，path 为’/‘的路由将不会匹配’/xxx’的 Switch可以使用 Switch 组件，来启用排他性的路由。 12345&lt;Switch&gt; &lt;Route path="/" exact component=&#123;Home&#125; /&gt; &lt;Route path="/about" component=&#123;About&#125; /&gt; &lt;Route path="/user" component=&#123;User&#125; /&gt;&lt;/Switch&gt; 嵌套路由如果需要嵌套路由，在 app 组件中可以把嵌套路由的父组件 /&gt;，在 xxx 组件中，在根据父组件来匹配路由。 12345678910111213141516171819202122232425class XXX extends Component &#123; constructor(props) &#123; super(props); this.state = &#123;&#125;; &#125; render() &#123; const &#123; history, match &#125; = this.props; return ( &lt;Layout&gt; &lt;Layout.Content style=&#123;&#123; padding: "0 50px" &#125;&#125;&gt; &lt;div style=&#123;&#123; background: "#fff", padding: 24 &#125;&#125;&gt; &lt;Divider /&gt; &lt;Route exact path=&#123;`$&#123;match.path&#125;/loan-info`&#125; component=&#123;LoanInfo&#125; /&gt; &lt;Route exact path=&#123;`$&#123;match.path&#125;/img-info`&#125; component=&#123;ImgInfo&#125; /&gt; &lt;Route exact path=&#123;`$&#123;match.path&#125;`&#125; component=&#123;LoanInfo&#125; /&gt; &lt;/div&gt; &lt;/Layout.Content&gt; &lt;/Layout&gt; ); &#125;&#125; withRouter想通过代码跳转子路由，可以用 withRouter,包装 react 组件,让它获得 history 属性 12import &#123; withRouter &#125; from "react-router";withRouter(MyComponent); 然后用this.props.history来跳转。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>react-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BOM 学习]]></title>
    <url>%2F2018%2F07%2F10%2FBOM-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[这是js高程的第8章，这是我第一次系统的学习bom，以前都是随便用，也没有成体系的东西，这次要好好学习一下。主要内容： 理解 window 对象——BOM 的核心 控制窗口、框架和弹出窗口 利用 location 对象中的页面信息 使用 navigator 对象了解浏览器 window对象BOM的核心对象是window，它表示浏览器的一个实例。在浏览器中，window对象有双重角色，它既是通过JavaScript访问浏览器窗口的一个接口，又是ECMAScript规定的Global对象 1、1全局作用域由于 window 对象同时扮演着 ECMAScript 中 Global 对象的角色，因此所有在全局作用域中声明的变量、函数都会变成 window 对象的属性和方法]]></content>
      <categories>
        <category>JS高程填坑笔记</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[科学上网小记]]></title>
    <url>%2F2018%2F07%2F10%2F%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[整理一下前一段时间研究科学上网的方法。科学上网需要购买国外的服务器, 会有一定的花费, 请自行判断 购买服务器科学上网是通过 VPS，搭建 ss 或者 ssr 服务器（梯子）来实现的。vps 服务器需要选择国外的（毕竟要翻墙）。一般都会在搬瓦工或者 vultr 购买服务器。我是看了同事在 vultr 买的，我也就在这里买的,感觉还不错，能够随时改变和删除服务器。网站：https://www.vultr.com/ 1、注册账号2、充值因为可以用支付宝，我就选择了支付宝支付。3、购买服务器vultr 官方最近进行了调整，2.5 美元套餐只提供 ipv6，可以用来上 BT，教育网等，但是不能实用 ipv4 的流量，如果你有 ipv4 需求，那么你至少要买 5 美元的套餐。3.1 选择地区3.2 选择服务器种类我选的 ubuntu 16.04 x64 版本的，当然也可以选其他的种类，3.3 选择服务器大小我当时选的$2.5/mo 的，现在貌似得选$5/mo 的了。。然后就可以买了。会得到一个服务器。。服务器列表服务器详情开启 ipv6 到这里，购买服务器就一步就可以了。 搭建 ss 服务1、首先需要连接到服务器，可以先 ping 一下 ip 地址看看，能 ping 通应该就可以用，没有 ping 通，就把刚才的服务器换一个。mac 可以用终端直接连接，windows 可以用 git bash，Xshell，Putty 等也都可以连接到远程服务器的方法是： 1ssh root@ip ip 就是你新买服务器的 ip，然后会提示让你输入密码，可以把密码复制进去就可以登陆了. 2、搭建 ss 服务器我是使用的 ubuntu 的服务器，其他服务器可以 google 其他教程。在刚刚连接的命令行里 安装pip前需要前置安装setuptools 123456789wget --no-check-certificate https://pypi.python.org/packages/source/s/setuptools/setuptools-19.6.tar.gz#md5=c607dd118eae682c44ed146367a17e26tar -zxvf setuptools-19.6.tar.gzcd setuptools-19.6python3 setup.py buildpython3 setup.py install 安装 pip首先安装 pip3： 1sudo apt install python3-pip 安装 Shadowsocks安装最新版的 Shadowsocks： 1pip3 install https://github.com/shadowsocks/shadowsocks/archive/master.zip 查看 Shadowsocks 的版本 1sudo ssserver --version 创建配置文件创建 Shadowsocks 配置文件所在文件夹 1sudo mkdir /etc/shadowsocks 创建配置文件： 1sudo nano /etc/shadowsocks/config.json 复制粘贴如下内容（注意修改密码“password”,服务器端口号也可以自行修改）： 12345678910&#123; &quot;server&quot;:&quot;::&quot;, &quot;server_port&quot;:8388, &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;mypassword&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;: false&#125; 然后按 Ctrl + O 保存文件，Ctrl + X 退出。 测试 Shadowsocks 配置测试下 Shadowsocks 能不能正常工作 1ssserver -c /etc/shadowsocks/config.json 测试完毕，按 Ctrl + C 关闭 Shadowsocks。 配置 Systemd 管理 Shadowsocks新建 Shadowsocks 管理文件 1sudo nano /etc/systemd/system/shadowsocks-server.service 复制粘贴： 12345678910[Unit]Description=Shadowsocks ServerAfter=network.target[Service]ExecStart=/usr/local/bin/ssserver -c /etc/shadowsocks/config.jsonRestart=on-abort[Install]WantedBy=multi-user.target Ctrl + O 保存文件，Ctrl + X 退出启动 Shadowsocks： 1sudo systemctl start shadowsocks-server 设置开机启动 Shadowsocks： 1sudo systemctl enable shadowsocks-server 优化（主要就是开启 BBR）BBR 系 Google 最新开发的 TCP 拥塞控制算法，目前有着较好的带宽提升效果。 升级 Linux 内核 BBR 在 Linux kernel 4.9 引入。首先检查服务器 kernel 版本： 1uname -r 如果其显示版本在 4.9.0 之下，则需要升级 Linux 内核，否则请忽略下文。 更新包管理器： 1sudo apt update 查看可用的 Linux 内核版本： 1sudo apt-cache showpkg linux-image 找到一个你想要升级的 Linux 内核版本，如“linux-image-4.10.0-22-generic”： 1sudo apt install linux-image-4.10.0-22-generic 等待安装完成后重启服务器： 1sudo reboot 删除老的 Linux 内核： 1sudo purge-old-kernels 开启 BBR 运行 lsmod | grep bbr，如果结果中没有 tcp_bbr，则先运行： 12modprobe tcp_bbrecho &quot;tcp_bbr&quot; &gt;&gt; /etc/modules-load.d/modules.conf 运行： 12echo &quot;net.core.default_qdisc=fq&quot; &gt;&gt; /etc/sysctl.confecho &quot;net.ipv4.tcp_congestion_control=bbr&quot; &gt;&gt; /etc/sysctl.conf 运行： 1sysctl -p 保存生效。运行： 12sysctl net.ipv4.tcp_available_congestion_controlsysctl net.ipv4.tcp_congestion_control 若均有 bbr，则开启 BBR 成功。至此，Shadowsock服务器端的基本配置已经全部完成了！ 客户端配置需要下载shadowsocks客户端mac下载地址：https://github.com/shadowsocks/ShadowsocksX-NG/releaseswindows下载地址：https://github.com/shadowsocks/shadowsocks-windows/releases 在Shadowsocks客户端添加服务器，如果你使用的是我提供的那个配置文件的话，地址填写你的IPv4地址或IPv6地址，端口号为8388，加密方法为aes-256-cfb，密码为你设置的密码。然后设置客户端使用全局模式，浏览器登录Google试试应该能直接打开了。mac下的配置：windows下的配置 在mac下可能需要在偏好设置里设置一下socket5和http代理 在mac下需要全局模式才能科学上网。可以直接上bt。在window下，代理模式可以科学上网，但是全局模式，外加需要设置一下ut才可以上bt设置utorrent打开设置 -&gt; 连接代理服务选择Http，代理127.0.0.1，端口1080，勾选通过代理服务器解析主机名 和 对于点对点连接使用代理服务器然后点应用，就可以上网了。]]></content>
      <categories>
        <category>Demo练习</category>
      </categories>
      <tags>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数表达式]]></title>
    <url>%2F2018%2F07%2F09%2F%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[JS 高程第 7 章，主要讲函数的表达式。主要内容有下面几个： 函数表达式的特征 递归 闭包等问题 一、函数表达的式的特征：1、函数声明提升具名函数会有函数生命提升，匿名函数，函数表达式，箭头函数声明不能被提升 123456789101112131415161718192021//函数声明提升sayHi();function sayHi() &#123; console.log('hi');&#125;sayHi();const sayHi = () =&gt; &#123; console.log('hi');&#125;;//Uncaught ReferenceError: sayHi is not definedsayHi();const sayHi = function() &#123; console.log('hi');&#125;;//Uncaught ReferenceError: sayHi is not definedsayHi()(function sayHi() &#123; console.log('hi');&#125;)(); 二、递归递归函数就是一个函数通过名字调用自身的情况下构成的 三、闭包闭包是指有权访问另一个函数作用域中变量的函数。常见的闭包创建方式，是在函数内创建另一个函数。 12345function plusFive(a) &#123; return function() &#123; return a + 5; &#125;;&#125; 四、模拟块级作用域ES5 中，可以用匿名函数来模拟块级作用域 1234567(function() &#123; //这里是块级作用域&#125;)();var someFunction = function() &#123; //这里是块级作用域&#125;;someFunction(); 五、私有变量严格来讲，JS没有私有成员的概念，所有的属性都是公有的，不过，倒是有一个私有变量的概念任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量。 私有变量包括函数的参数、局部变量和在函数内部定义的其他函数。]]></content>
      <categories>
        <category>JS高程填坑笔记</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[圣杯布局，双飞翼布局]]></title>
    <url>%2F2018%2F07%2F03%2F%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%EF%BC%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[等待填坑]]></content>
      <categories>
        <category>面试锦囊</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[变量、作用域和内存问题]]></title>
    <url>%2F2018%2F06%2F28%2F%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[这是JS高程的第四章，讲的是变量，作用域，以及JS的内存问题。现在来填坑本节包括三个部分 基本类型和引用类型 执行环境 垃圾收集 基本类型和引用类型 基本类型值：简单的数据段，Undefined，Null，number，string，boolean五种基本类型，在操作的时候，可以操作保存在变量中实际的值。 引用类型的值是保存在内存中的对象。Js不允许直接访问内存的位置，也就是不允许直接操作对象的内存空间，在操作对象时，复制对象时，操作的时对象的引用，在为对象添加属性时，操作的是对象 传递参数ES中所有的参数都是按值传递的。基本类型传的值就是变量的值，引用类型传的值是引用内存的地址。 执行环境与作用域全局执行环境，是最外围的一个执行环境。每一个函数都会有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中，而在环境执行结束后，栈将其环境弹出，把控制权返回之前的执行环境。当代码在一个环境中执行时，会产生一个作用域链。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问 可以通过try-catch 和 with语句来延长作用域链 垃圾收集垃圾收集一般有两个策略：标记清楚，进入环境和弹出环境分别有标记，清除弹出环境标记的变量或者函数。引用计数，引用为0的会被清除]]></content>
      <categories>
        <category>JS高程填坑笔记</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对象深拷贝方法]]></title>
    <url>%2F2018%2F06%2F25%2F%E5%AF%B9%E8%B1%A1%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[分享大佬写的深拷贝的方法。。1、JSON.parse(JSON.stringify(obj))这个小方法可以把 obj 里的除了 RegExp 和 function 的属性拷贝下来。function 就忽略了，RegExp 转成{} 2、大佬们写的两个方法。。 12345678910111213141516171819202122232425262728293031323334353637383940const deepClone = obj =&gt; &#123; const innerIterator = (v, key, nb) =&gt; &#123; if (v instanceof Array) &#123; const result = v.map(item =&gt; &#123; if (item instanceof RegExp) &#123; return new RegExp(item); &#125; else if ( typeof item === 'function' || item === null || typeof item !== 'object' ) &#123; return item; &#125; else if (item instanceof Array) &#123; return innerIterator(item); &#125; return reduceKeys(item)(); &#125;); return key &amp;&amp; nb ? &#123; ...nb, [key]: result &#125; : result; &#125; const newObj = reduceKeys(v)(); return &#123; ...nb, [key]: newObj &#125;; &#125;; const reduceKeys = value =&gt; () =&gt; &#123; const ks = Object.keys(value); return ks.reduce((pre, current) =&gt; &#123; const v = value[current]; if (v instanceof RegExp) &#123; return &#123; ...pre, [current]: new RegExp(v) &#125;; &#125; else if ( v === null || typeof v === 'function' || typeof v !== 'object' ) &#123; return &#123; ...pre, [current]: v &#125;; &#125; return innerIterator(v, current, pre); &#125;, &#123;&#125;); &#125;; return reduceKeys(obj)();&#125;; 123456789101112131415161718192021222324252627282930313233343536373839const deepClone = data =&gt; &#123; const notIn = ['[object Function]', '[object Object]', '[object Array]']; const getType = data =&gt; &#123; return Object.prototype.toString.call(data); &#125;; const isObject = data =&gt; &#123; return getType(data) === '[object Object]'; &#125;; const isArray = data =&gt; &#123; return getType(data) === '[object Array]'; &#125;; const isFunction = data =&gt; &#123; return getType(data) === '[object Function]'; &#125;; let result; if (isObject(data)) &#123; result = &#123;&#125;; for (var p in data) &#123; if (notIn.includes(getType(data[p]))) &#123; result[p] = deepClone(data[p]); &#125; else &#123; result[p] = data[p]; &#125; &#125; &#125; else if (isArray(data)) &#123; result = []; for (var i of data) &#123; if (notIn.includes(getType(i))) &#123; result.push(deepClone(i)); &#125; else &#123; result.push(i); &#125; &#125; &#125; else if (isFunction(data)) &#123; result = data; &#125; return result;&#125;;]]></content>
      <categories>
        <category>Demo练习</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目action封装]]></title>
    <url>%2F2018%2F06%2F25%2F%E9%A1%B9%E7%9B%AEaction%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import callApi from '../../utils/callApi';import api from '../../api';/** * callApi * @param dispatch * @param formData * @param requestUrl * @param type 设置action的type * @returns &#123;function(*)&#125; */const commonCallApi = (dispatch, formData, requestUrl, type) =&gt; &#123; return callApi.post(requestUrl, formData).then(res =&gt; &#123; if (res.code === 200) &#123; const data = type ? dispatch(&#123; type, data: res.data &#125;) : res; return Promise.resolve(data); &#125; return Promise.reject(res); &#125;);&#125;;/** * 公共action * @param requestUrl * @param formData * @param type 设置action的type * @returns &#123;function(*)&#125; */const commonAction = (requestUrl, formData, type) =&gt; &#123; return dispatch =&gt; &#123; return commonCallApi(dispatch, requestUrl, formData, type); &#125;;&#125;;/** * 获取列表 * @param formData * @returns &#123;function(*)&#125; */const getList = formData =&gt; &#123; return commonAction(api.getList, formData, 'get_list');&#125;;export default &#123; getList&#125;;]]></content>
      <categories>
        <category>Demo练习</category>
      </categories>
      <tags>
        <tag>Javascript redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对象字面量声明和构造函数声明的比较]]></title>
    <url>%2F2018%2F06%2F20%2F%E5%AF%B9%E8%B1%A1%E5%AD%97%E9%9D%A2%E9%87%8F%E5%A3%B0%E6%98%8E%E5%92%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E7%9A%84%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[去某家面试的时候，在笔试的时候，看到了这个问题，回来研究一下。JS 中有很多种对象的声明方式，一般我用到的也就是这两种，通过字面量来声明对象和通过构造函数来声明对象。 用字面量来声明对象我们可以直接在创建对象的时候添加功能 12345678let person = &#123; name: 'paji', age: 18, sex: 'male', speak: function() &#123; console.log('大家好'); &#125;&#125;; 或者在一开始先声明一个空的对象，当然这个空对象也不是空对象，也是从 object 上继承了好多 object 的属性，只是没有自有属性 1234567let person = &#123;&#125;,person.name = 'paji';person.age = 18;person.sex = 'male';person.speak = function() &#123; console.log('大家好');&#125; 用构造函数声明对象1234567var person = new Object();person.name = 'paji';person.age = 18;person.sex = 'male';person.speak = function() &#123; console.log('大家好');&#125;; 字面量的优势 代码量更少，更易读 强调对象就是一个简单的可变的散列表，而不必一定派生自某个类 对象字面量运行速度更快，因为它们可以在解析的时候被优化：它们不需要”作用域解析(scope resolution)”；因为存在我们创建了一个同名的构造函数Object()的可能，当我们调用Object()的时候，解析器需要顺着作用域链从当前作用域开始查找，如果在当前作用域找到了名为Object()的函数就执行，如果没找到，就继续顺着作用域链往上照，直到找到全局Object()构造函数为止 Object()构造函数可以接收参数，通过这个参数可以把对象实例的创建过程委托给另一个内置构造函数，并返回另外一个对象实例，而这往往不是你想要的。 尽量用对象字面量的方式来创建对象]]></content>
      <categories>
        <category>面试锦囊</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS包装对象]]></title>
    <url>%2F2018%2F06%2F19%2FJS%E5%8C%85%E8%A3%85%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[Q1: 什么是包装对象？A1: JS 的数值，布尔，字符串类型的变量，在一定条件下，也可以自动变成对象，这就是原始类型的包装对象。 123let a = new Number(-1);let b = new Boolean(true);let c = new String('hello world'); Q2: 包装对象和同样的原始类型的值相等么，这么做有什么目的？A2: 不想等。包装对象的最大目的，首先是使得 JavaScript 的对象涵盖所有的值，其次使得原始类型的值可以方便地调用某些方法。 1234567typeof a; //'object'typeof b; //'object'typeof c; //'object'a === -1; //falseb === true; //false;c === 'hello world'; //false Q3: 包装对象有什么实例方法？A3: 包装对象可以使用 object 对象提供的原生的方法，其中主要的就是 valueOf()和 toString()方法 1234567a.valueOf(); //-1b.valueOf(); //trueb.valueOf(); //'hello world'a.toString(); //'-1'b.toString(); //'true'b.toString(); //'hello world' Q4: 原始类型和实例对象怎么转换？A4: 原始类型的值，可以自动当作包装对象调用，即调用各种包装对象的属性和方法。这时，JavaScript 引擎会自动将原始类型的值转为包装对象实例，在使用后立刻销毁实例。自动转换生成的包装对象是只读的，无法修改。所以，字符串无法添加新属性。 123let s = 'Hello World';s.x = 123;s.x; // undefined 另一方面，调用结束后，包装对象实例会自动销毁。这意味着，下一次调用字符串的属性时，实际是调用一个新生成的对象，而不是上一次调用时生成的那个对象，所以取不到赋值在上一个对象的属性。]]></content>
      <categories>
        <category>面试锦囊</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript基本概念（四）]]></title>
    <url>%2F2018%2F06%2F19%2FJavascript%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这是 JS 高程第三章的第四部分。本节的主要内容是 语句 函数 语句if 语句if (condition) statement1 else statement2eg: 1234567if (i &gt; 25) &#123; alert('Greater than 25.');&#125; else if (i &lt; 0) &#123; alert('Less than 0.');&#125; else &#123; alert('Between 0 and 25, inclusive.');&#125; do-while 语句后测试循环语句 123do &#123; statement;&#125; while (expression); while 语句前测试循环语句while(expression) statement 1234var i = 0;while (i &lt; 10) &#123; i += 2;&#125; for 语句前测试循环语句for (initialization; expression; post-loop-expression) statement 1234var count = 10;for (var i = 0; i &lt; count; i++) &#123; alert(i);&#125; for-in 语句精准迭代语句，可以用来枚举对象属性for (property in expression) statement 123for (var propName in window) &#123; document.write(propName);&#125; label 语句label: statement 123start: for (var i = 0; i &lt; count; i++) &#123; alert(i);&#125; 这个例子中的 start 标签，可以在将来由 break 和 continue 语句引用，加标签的语句一般都要与 for 语句等循环语句配合使用。 break 和 continue 语句break 语句会立即跳出循环，然后执行循环后的代码continue 语句会跳出循环，然后从循环顶部开始执行循环。 switch 语句12345678910111213switch (expression) &#123; case value: statement; break; case value: statement; break; case value: statement; break; default: statement;&#125; 函数ES 中采用 function 来声明一个函数，后面跟一组参数和函数体，函数会在执行完 return 语句之后停止并立即退出。 123function functionName(arg0, arg1,...,argN) &#123; statements&#125; 参数理解函数内部通过一个数组arguments来接收参数。arguments对象只是与数组很像，但是并不是Array的实例。可以用arguments[0]来获取内部的元素。ECMAScript 中的所有的参数传递的都是值，不可能通过引用传递参数 没有重载ES中的函数没有重载]]></content>
      <categories>
        <category>JS高程填坑笔记</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript 基本概念（三）]]></title>
    <url>%2F2018%2F06%2F13%2FJavascript%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这是JS高程第三章的第三部分。这一章内容是真的多。。我觉得重新刷高程，对我来说，也是一种不一样的进步吧。本节的主要内容是 操作符 一元操作符只能操作一个一个值的操作符叫做一元操作符。1、递增递减操作符 有两个版本，前置型和后置型。 前置型，先操作，后执行。 后置型，先执行，后操作。123456let a = 5, b = 6;let sum = ++a + b;let sum2 = a++ + b;console.log(sum); //12console.log(sum2) //12console.log(a); //7 递增递减操作符对数值，布尔，字符串，对象都有作用！！！！！ 规则如下： 如果字符串包含有效数字，则先转化成数值变量，然后加减1；不包含有效数字，则转化成NaN。字符串变量变成数值变量 数值变量加减1； 布尔变量，true先变成1，false变成0，然后加减1,布尔变了转换成数值变量； 对象变量，先查看valueOf()方法，如果是NaN，则调用toString()，对象转换成数值变量。 2、一元加减操作符。 一元+操作符，会像Number()方法一样对变量转换成数值变量var a; a = +a; 一元-操作符，主要是变成负数。会像Number()方法一样，不过是负数。 位操作符首先ES里所有的数值都是有64位来储存，但是位操作符并不是操作64位，而是先转化成32位的整数，然后操作，再将结果转换成64位的，这样，NaN和Infinity就会变成0。对于有符号数，第32位是符号位，0代表正数，1代表负数，符号位决定了其他位数值的格式。剩下31位用来储存数据。正数都是以二进制格式存储，负数以二进制的补码格式存储。默认情况下，ES里所有的正数都是有符号数。无符号数，第32位是数值。但是无符号数只能是正数。位操作符对其他变量，会先用Number()方法变成数值，然后再按位操作。1、按位非（NOT） 按位非是用～表示，执行按位非的结果是返回数值的反码。2、按位与（AND） 按位与是用&amp;表示，它有两个操作符数，运算的时候，将两个数的二进制每一位对齐，都是1得1，其他为0；3、按位或（OR） 按位或是用|表示，它有两个操作符数，运算的时候，将两个数的二进制每一位对齐，都是0得0，其他为1；4、按位异或（XOR） 按位或是用^表示，它有两个操作符数，运算的时候，将两个数的二进制每一位对齐，相同得0，不同为1；5、左移 左移用&lt;&lt;表示，会将数值所有位数向左移动指定的位数。后面补0；左移不会影响符号。6、有符号右移 有符号右移用&gt;&gt;表示，会将数值所有位数向右移动指定的位数。前面补0；保留符号位，不会影响符号。7、无符号右移 无符号右移用&gt;&gt;&gt;表示，会将数值所有位数向右移动指定的位数。前面补0；会影响符号。而且会把负数的补码当成二进制码来运算。 布尔运算符布尔运算符有三个，主要用来测试值的关系1、逻辑非(!)这个操作符会返回一个布尔值，逻辑非运算会将操作数先转换成布尔值，然后求反。 操作数是对象，返回false 操作数是空字符串，返回true 操作数是非空字符串，返回false 操作数是非0数值，返回false 操作数是0，null，NaN，undefined，返回true 2、逻辑与(&amp;&amp;)逻辑与操作符两边有两个操作数。都是true才为true。逻辑与操作可以应用于所有变量，在有一个操作数不是布尔值的情况下，逻辑与不一定会返回布尔值。规则： 如果第一个操作数是对象，则返回第二个操作数 如果第二个操作数是对象，则必须第一个操作数是true才会返回该对象。 如果两个数都是对象，则返回第二个操作数 如果有一个操作数是null，NaN，undefined，则返回null，NaN，undefined。 逻辑与属于短路操作，第一个操作数能决定结果，就不会对第二个操作数求值。 3、逻辑或(||)逻辑或两边有两个操作数，有一个为true就是true。逻辑或操作可以应用于所有变量，在有一个操作数不是布尔值的情况下，逻辑与不一定会返回布尔值。规则： 如果第一个操作数是对象，则返回第一个操作数 如果第一个操作数是false，则返回第二个操作数 两个操作数都是对象，则返回第一个操作数 如果两个操作数是null，NaN，undefined，则返回null，NaN，undefined。 乘性操作符ES有三个乘性操作符，乘法，除法和求模。如果乘性操作符的某一个操作数不是数值，则将会用Number()方法，先转换成数值。1、乘法(*)规则： 乘积超过限制，则显示Infinity或者-Infinity 有一个操作数为NaN，结果为NaN Infinity与0相乘，结果是NaN Infinity与非0数相乘，结果是Infinity或者-Infinity Infinity与Infinity相乘，结果是Infinity 2、除法(/)规则： Infinity与Infinity相除，结果是NaN 0/0结果是NaN 其他操作数／0 结果是Infinity或者-Infinity 3、求模(%)规则： Infinity%操作数 结果是NaN 操作数%0，结果是NaN Infinity%Infinity，结果是NaN 操作数%Infinity，结果是操作数 加性操作符ES中有两个加性操作符，加法和减法1、加法(+)规则： 有一个操作数是NaN，结果就是NaN Infinity + Infinity = Infinity -Infinity + -Infinity = -Infinity Infinity + -Infinity = NaN +0 + +0 = +0 -0 + -0 = -0 +0 + -0 = +0 两个操作数都是字符串，则将字符串拼接起来 只有一个操作数是字符串，另一个操作数则会转换成字符串，然后拼接起来。 2、减法(-)规则： Infinity - Infinity = NaN -Infinity - -Infinity = NaN Infinity - -Infinity = Infinity -Infinity - Infinity = -Infinity 关系操作符关系操作符有大于(&gt;)，小于(&lt;),小于等于(&lt;=),大于等于(&gt;=)规则： 都是数值，执行数值比较 都是字符串，执行字符串编码比较 一个是数值，则另一个转换成数值比较 相等操作符ES中提供了两种相等操作符：相等操作符：先转换再比较全等操作符：不转换只比较1、相等操作符(==,!=),强制转型，然后比较。规则： 如果有一个是布尔类型的操作数，则先转换成数值。 如果有一个是数值，一个是字符串，则将字符串转换成数值 如果有一个是对象，则用valueOf转成基本类型比较 null 和undefined 相等 如果有一个操作数是NaN，则==返回false，!=返回true 如果都是对象，则比较两个对象是不是一个对象，是否来指向同一个对象。 2、全等操作符(===,!==),不转换，只比较。规则： 只要是完全一样就为true，其他为false。 ##条件操作符ES中的条件操作符(?:)1variable ? console.log(true): console.log(false); ##赋值操作符其中有+= ，-=，*=，／=，%=，&lt;&lt;=, &gt;&gt;=, &gt;&gt;&gt;= ##逗号操作符1var a = 1, b = 2, c = 3;]]></content>
      <categories>
        <category>JS高程填坑笔记</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[display的属性们]]></title>
    <url>%2F2018%2F06%2F13%2Fdisplay%E7%9A%84%E5%B1%9E%E6%80%A7%E4%BB%AC%2F</url>
    <content type="text"><![CDATA[display： none | inline | block | list-item | inline-block | table | inline-table | table-caption | table-cell | table-row | table-row-group | table-column | table-column-group | table-footer-group | table-header-group | run-in | box | inline-box | flexbox | inline-flexbox | flex | inline-flex默认值：inline none： 隐藏对象。与visibility属性的hidden值不同，其不为被隐藏的对象保留其物理空间inline： 指定对象为内联元素。block： 指定对象为块元素。list-item： 指定对象为列表项目。inline-block： 指定对象为内联块元素。（CSS2）table： 指定对象作为块元素级的表格。类同于html标签&lt;table&gt;（CSS2）inline-table： 指定对象作为内联元素级的表格。类同于html标签&lt;table&gt;（CSS2）table-caption： 指定对象作为表格标题。类同于html标签&lt;caption&gt;（CSS2）table-cell： 指定对象作为表格单元格。类同于html标签&lt;td&gt;（CSS2）table-row： 指定对象作为表格行。类同于html标签&lt;tr&gt;（CSS2）table-row-group： 指定对象作为表格行组。类同于html标签&lt;tbody&gt;（CSS2）table-column： 指定对象作为表格列。类同于html标签&lt;col&gt;（CSS2）table-column-group： 指定对象作为表格列组显示。类同于html标签&lt;colgroup&gt;（CSS2）table-header-group： 指定对象作为表格标题组。类同于html标签&lt;thead&gt;（CSS2）table-footer-group： 指定对象作为表格脚注组。类同于html标签&lt;tfoot&gt;（CSS2）run-in： 根据上下文决定对象是内联对象还是块级对象。（CSS3）box： 将对象作为弹性伸缩盒显示。（伸缩盒最老版本）（CSS3）inline-box： 将对象作为内联块级弹性伸缩盒显示。（伸缩盒最老版本）（CSS3）flexbox： 将对象作为弹性伸缩盒显示。（伸缩盒过渡版本）（CSS3）inline-flexbox： 将对象作为内联块级弹性伸缩盒显示。（伸缩盒过渡版本）（CSS3）flex： 将对象作为弹性伸缩盒显示。（伸缩盒最新版本）（CSS3）inline-flex： 将对象作为内联块级弹性伸缩盒显示。（伸缩盒最新版本）（CSS3）]]></content>
      <categories>
        <category>面试锦囊</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[link和@import之争]]></title>
    <url>%2F2018%2F06%2F13%2Flink%E5%92%8C-import%E4%B9%8B%E4%BA%89%2F</url>
    <content type="text"><![CDATA[看到知乎大神说，先问是不是，再问为什么 我页不知道为什么要写这句话，反正就是很奇怪的想法，就先记下来。今天研究的link和@import，是外部引入外部引入 CSS 的两种方式。两者是有区别的（是不是）。我们来研究一下有哪些区别（为什么） link是XHTML(HTML)标签，除了加载CSS外，还可以定义RSS,rel等其他事务； @import是 CSS 提供的语法规则, 只有导入样式表的作用。 link引用CSS时，在页面载入时同时加载； @import需要页面网页完全载入以后加载。 link是XHTML(HTML)标签，无兼容问题； @import是在CSS2.1提出的，低版本的浏览器不支持(IE5+)。 link支持使用Javascript控制DOM去改变样式；而@import不支持。 1234&lt;link href="style.css" rel="stylesheet" type="text/css"&gt; &lt;style&gt; @import url(style.css);&lt;/style&gt;]]></content>
      <categories>
        <category>面试锦囊</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript基本概念(二）]]></title>
    <url>%2F2018%2F06%2F11%2FJavascript%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[JS高程的第三章第二节，对数据类型进行一下学习 JS有五种基本数据类型：Number，String，Boolean，Undefined，Null和一种复杂类型：Object，Object本质上是由一组无序的名值对组成的（说好的万物皆对象来着）。JS不支持任何创建自定义类型的机制。 typeof 操作符ECMAScript是松散类型的，typeof就是负责来检测给定变量的数据类型的操作符。typeof是判断参数是什么类型的实例，就一个参数typeof一般只能返回如下几个结果：”number”、”string”、”boolean”、”object”、”function” 和 “undefined”。 Undefined类型Undefined类型只有一个值，即特殊的undefined。只有在变量声明且未初始化的时候，变量的值为undefined。建议显式的初始化undefined，这样发现值为undefined的时候，就会知道该变量未声明而不是未初始化。1let message = 'undefined'; Null类型Null类型只有一个值的数据类型，即特殊的null。从逻辑角度来看，null值表示一个空对象指针，使用typeof操作符检测null值时会返回’object’。如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为null而不是其他值。只要直接检查null值就可以知道相应的变量是否已经保存了一个对象的引用123if (obj != null)&#123;// 对 car 对象执行某些操作&#125; 另外：undefined值是派生自null值的，在验证相等时，它们的相等性测试要返回true。但是在全等性测试时返回false。 Boolean类型Boolean类型是JS中使用得最多的一种类型，该类型只有两个字面值:true和false。Boolean类型的字面值true和false是区分大小写的。Boolean类型的字面值只有两个，但JS中所有类型的值都有与这两个Boolean值等价的值。要将一个值转换为其对应的 Boolean值，可以调用转型函数Boolean(),可以对任何数据类型的值调用Boolean()函数，而且总会返回一个Boolean值12const message = 'hello world';const bool = Boolean(message); 数据类型 true false String 任何非空字符串 ‘’(空字符串) Boolean true false Number 任何非0值 0和NaN Object 任何对象 null undefined undefined Number类型Number类型使用IEEE754格式来表示整数和浮点数值(浮点数值在某些语言中也被称为双精度数值)。最基本的数值字面量格式是十进制整数：const num = 254;，最高具有53位有效数字精度八进制字面值的第一位必须是零(0)，然后是八进制数字序列(0~7)const num2 = 03;八进制字面量在严格模式下是无效的十六进制字面值的前两位必须是 0x,const num2 = 0xff算术计算时，所有以八进制和十六进制表示的数值都会被转换成十进制数值在JavaScript中保存数值的方式，可以保存正零(+0)和负零(0)。正零和负零被认为相等1、浮点数值数值中必须包含一个小数点，并且小数点后面必须至少有一位数字.浮点数保存空间是整数的两倍，如果小数点后的值为0或者没有任何数值，那么该数值就会保存成整数用e或E表示10的幂。2e5,浮点数的最高精度为17位。算术运算的时候，精度比整数差的多。不要测试浮点数相等。2、最值：Number.MIN_VALUE, Number.MAX_VALUE3、NaN：该值表示一个本来要返回Number类型的操作数未返回数值的情况。设计NaN的所有操作都等于NaN，且NaN与任何值都不想等，包括NaNisNaN()函数,用来判断一个值是否为数值（number）isNaN也适用于对象，在判断对象的时候，会先调用对象的valueOf()方法，确定该返回值是否是数值，如果不行，会调用toString()方法，再判断是否是数值。1isNaN() 4、数值转换有3个方法可以将非数值类型的值转换成数值类型：Number() parseInt() parseFloat()。Number()方法可以将任何数值类型转化成数值类型，其他两个需要字符串类型Number()转换规则： Boolean的值，true转换成1， false转化成0 null 转化成0 undefined 转化成NaN String变量 是整数的转换成十进制整数，前导0将被去掉 浮点数将被转化成浮点数，前导0将被去掉 十六进制的数值将被转换成十进制相同大小的值 空字符串将被转换成0 其他的将被转换成NaN Object对象 会先调用对象的valueOf()方法，确定该返回值是否是数值，如果NaN，会调用toString()方法，再按照string方法判断。 parseInt()转换规则 转换字符串，从第一个非空格字符开始，是数字或者进制符号就继续下一个字符。否则就NaN 浮点数转化成整数，空字符串转化成NaN parseInt(&#39;&#39;) = NaN parseFloat()转化规则 从第一个字符开始判断，知道遇到非浮点数字符。 第一个小数点有效，其他的则无效。 16进制会被转化成0 忽略前导0 String类型用于表示有0到多个16位Unicode字符组成的字符序列，即字符串。用’’或者””表示1、字符字面量 即转义字符2、字符串特点 ES中，字符串一旦创建就不能改变，要改变就会销毁之前变量，然后生产新的变量。3、转换成字符串toString()方法 Number，Boolean，Object，String都有这个方法，转换成相应的字符串。Null和Undefined没有这个方法。 如果有toString()方法，那就调用该方法 如果没有，null 转换成’null’,undefined 转换成’undefined’ ObjectES中的对象就是一组数据和功能的集合。对象可以通过new操作符后加名字的来创建var o = new Object()Object类型是所有它的实例的基础，其具有的属性，在其他所有的实例中都会有。Object有的属性和方法 constructor：保存用于创建当前对象的函数 hasOwnProperty(propertyName): 用于判断是否有属于自己的属性，而不是在原型中的属性 isPrototypeOf(object): 用于检查传入的对象是否是传入对象的原型 propertyIsEnumerable(propertyName)：用于检查属性能否用for-in来遍历 toLocaleString()：返回对象的字符串表示 toString(): 返回对象的字符串表示 valueOf()：返回对象的字符串，数值，布尔表示，通常和toString()结果一样。]]></content>
      <categories>
        <category>JS高程填坑笔记</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript基本概念（一）]]></title>
    <url>%2F2018%2F06%2F11%2Fjavascript%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这是JS高程的第三章，内容比较多的一章，所以拆分开来，慢慢的填坑。路漫漫其修远兮啊本节包括三个部分 JS语法 JS关键字 JS变量 JS语法1、JS中的一切(变量、函数名和操作符)都区分大小写2、标识符，就是指变量、函数、属性的名字，或者函数的参数。第一个字符必须是一个字母、下划线(_)或一个美元符号($）;其他字符可以是字母、下划线、美元符号或数字3、注释：12345// 单行注释/** 这是一个多行 * (块级)注释 */ 4、严格模式ECMAScript5引入了严格模式(strict mode)的概念。严格模式是为JavaScript定义了一种不同的解析与执行模型。1"use strict"; 它是一个编译指示(pragma)，用于告诉支持的JavaScript引擎切换到严格模式。这是为不破坏ECMAScript 3语法而特意选定的语法。5、ECMAScript 中的语句以一个分号结尾;如果省略分号，则由解析器确定语句的结尾。建议在语句结尾处添加“;” 关键字和保留字1、关键字，可用于表示控制语句的开始或结束，或者用于执行特定操作等。按照规则，关键字也是语言保留的，不能用作标识符。2、保留字，保留字在这门语言中还没有任何特定的用途，但它们有可能在将来被用作关键字。 变量ECMAScript的变量是松散类型的，松散类型就是可以用来保存任何类型的数据。换句话说，每个变量仅仅是一个用于保存值的占位符而已。ECMAScript 也支持直接初始化变量，因此在定义变量的同时就可以设置变量的值用var操作符定义的变量将成为定义该变量的作用域中的局部变量。也就是说，如果在函数中使用var定义一个变量，那么这个变量在函数退出后就会被销毁。（块级作用域中可以使用let 和 const来声明块级变量，形成暂时性死区）]]></content>
      <categories>
        <category>JS高程填坑笔记</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在HTML中使用JS]]></title>
    <url>%2F2018%2F06%2F10%2F%E5%9C%A8HTML%E4%B8%AD%E4%BD%BF%E7%94%A8JS%2F</url>
    <content type="text"><![CDATA[这是js高程的第二章，主要讲的内容就是怎样在HTML中使用javascript。这章的内容包含四个部分： &lt;script&gt; 标签 嵌入脚本和外部脚本 文档模式的影响 禁用javascript的场景 &lt;script&gt; 标签向HTML页面中插入JavaScript的主要方法，就是使用&lt;script&gt;元素。html 4.01给script标签定义了以下属性 async 异步标签，表示应该立即下载脚本，但不应妨碍页面中的其他操作。该属性只对外部脚本文件有效。但是，标记为async的脚本并不保证按照script排列的先后顺序执行。异步脚本一定会在页面的load事件前执行，但可能会在DOMContentLoaded事件触发之前或之后执行。 charset:表示通过 src 属性指定的代码的字符集。由于大多数浏览器会忽略它的值，因此这个属性很少有人用。 defer:表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。脚本会被延迟到整个页面都解析完毕后再运行。HTML5规范要求脚本按照它们出现的先后顺序执行，因此第一个延迟脚本会先于第二个延迟脚本执行，而这两个脚本会先于DOMContentLoaded事件执行。但是在现实当中，延迟脚本并不一定会按照顺序执行，也不一定会在 DOMContentLoaded事件触发前执行，因此最好只包含一个延迟脚本。 1&lt;script defer="defer"&gt; src:表示包含要执行代码的外部文件。如果要通过&lt;script&gt;元素来包含外部JavaScript文件，那么src 属性就是必需的。这个属性的值是一个指向外部JavaScript文件的链接。需要注意的是，带有src属性的&lt;script&gt;元素不应该在其&lt;script&gt;和&lt;script&gt;标签之间再 包含额外的JavaScript代码。如果包含了嵌入的代码，则只会下载并执行外部脚本文件，嵌入的代码会被忽略。通过&lt;script&gt;元素的 src 属性还可以包含来自外部域的 JavaScript 文件。 1&lt;script src="example.js"&gt;&lt;/script&gt; type:type 属性规定脚本的MIME类型。type属性标示 &lt;script&gt;与&lt;/script&gt;标签之间的内容。MIME类型包括两部分：media type 和 subtype。对于JavaScript，MIME 类型是 “text/javascript”。在 HTML5中，type属性不再是必需的。默认值是”text/javascript”。 嵌入脚本和外部脚本使用&lt;script&gt;元素的方式有两种:直接在页面中嵌入JavaScript代码和包含外部 JavaScript文件。无论如何包含代码，只要不存在defer和async属性，浏览器都会按照&lt;script&gt;元素在页面中 出现的先后顺序对它们依次进行解析。 外部脚本的优势： 可维护性 可缓存: 浏览器能够根据具体的设置缓存链接的所有外部 JavaScript 文件 适应未来 文档模式的影响最初的两种文档模式是:混杂模式(quirks mode)和标准模式(standards mode)。1234&lt;!-- HTML 4.01 严格型 --&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"&gt;&lt;!-- HTML 5 --&gt;&lt;!DOCTYPE html&gt; 禁用javascript的场景关于禁用javascript的场景，主要是&lt;noscript&gt;这个元素可以包含能够出现在文档&lt;body&gt;中的任何 HTML 元素——&lt;script&gt;元素除外。包含 在&lt;noscript&gt;元素中的内容只有在下列情况下才会显示出来: 浏览器不支持脚本; 浏览器支持脚本，但脚本被禁用。123456789101112&lt;html&gt; &lt;head&gt; &lt;title&gt;Example HTML Page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;noscript&gt; &lt;p&gt;本页面需要浏览器支持(启用)JavaScript。 &lt;/noscript&gt; &lt;script type="text/javascript" defer="defer" src="example1.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" defer="defer" src="example2.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 总结把 JavaScript 插入到 HTML 页面中要使用&lt;script&gt;元素。使用这个元素可以把 JavaScript 嵌入到 HTML 页面中，让脚本与标记混合在一起;也可以包含外部的 JavaScript 文件。而我们需要注意的地方有: 在包含外部 JavaScript 文件时，必须将 src 属性设置为指向相应文件的 URL。而这个文件既可 以是与包含它的页面位于同一个服务器上的文件，也可以是其他任何域中的文件。 所有&lt;script&gt;元素都会按照它们在页面中出现的先后顺序依次被解析。在不使用 defer 和 async 属性的情况下，只有在解析完前面&lt;script&gt;元素中的代码之后，才会开始解析后面 &lt;script&gt;元素中的代码。 由于浏览器会先解析完不使用 defer 属性的&lt;script&gt;元素中的代码，然后再解析后面的内容， 所以一般应该把&lt;script&gt;元素放在页面最后，即主要内容后面，&lt;／body&gt;标签前面。 使用 defer 属性可以让脚本在文档完全呈现之后再执行。延迟脚本总是按照指定它们的顺序执行。 使用 async 属性可以表示当前脚本不必等待其他脚本，也不必阻塞文档呈现。不能保证异步脚本按照它们在页面中出现的顺序执行。 另外，使用&lt;noscript&gt;元素可以指定在不支持脚本的浏览器中显示的替代内容。但在启用了脚本的情况下，浏览器不会显示&lt;noscript&gt;元素中的任何内容。]]></content>
      <categories>
        <category>JS高程填坑笔记</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[window.location的属性]]></title>
    <url>%2F2018%2F06%2F10%2Fwindow.location%E7%9A%84%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[关于http的相关的BOM的问题 获取当前url的协议1const protocol = window.location.protocol; 获取当前的host和端口号1const host = window.location.host; 获取当前完整的URL1const host = window.location.href; 获取当前pathName1const host = window.location.pathname; 获取当前url的查找内容1const host = window.location.search;]]></content>
      <categories>
        <category>bug汇总</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 实用片段]]></title>
    <url>%2F2018%2F05%2F29%2FCSS%E5%AE%9E%E7%94%A8%E7%89%87%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[1、垂直对齐：垂直对齐容器中的元素. 1234567verticalcenter&#123; position: relative; top: 50%; -webkit-transform: translateY(-50%); -o-transform: translateY(-50%); transform: translateY(-50%);&#125; 2、垂直居中:不知道父元素高度的情况 123456789parentElement &#123; position:relative;&#125;childElement &#123; position: absolute; top: 50%; transform: translateY(-50%);&#125; 若父容器下只有一个元素，且父元素设置了高度，则只需要使用相对定位即可 123456789parentElement &#123; height: xxx;&#125;childElement &#123; position: relative; top: 50%; transform: translateY(-50%);&#125; flex 布局 12345parentElement &#123; display: flex; /*Flex布局*/ display: -webkit-flex; /* Safari */ align-items: center; /*指定垂直居中*/&#125; line-height 设置了行间的距离（行高），将要居中的元素的 line-heigth 值设置为和其块级父元素的 height 值一样时，其内部内容会垂直居中。 1234element &#123; height: 100px; line-height: 100px;&#125; 3、水平居中:行级元素水平居中对齐:text-align:center;块级元素水平居中对齐:margin: 0 auto对于浮动的元素居中 宽度不固定的浮动元素 123&lt;div class="outerbox"&gt; &lt;div class="innerbox"&gt;我是浮动的&lt;/div&gt; &lt;/div&gt; 12345678910.outerbox &#123; float: left; position: relative; left: 50%;&#125;.innerbox &#123; float: left; position: relative; right: 50%;&#125; 。。。未完待续]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表]]></title>
    <url>%2F2018%2F05%2F28%2F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[定义链表是由一组节点组成的集合。每一个节点都使用一个对象的引用指向它的后续借点。指向另外一个节点的引用叫做链。链表元素则是靠相互之间的关系进行引用。在链表中就说这个元素是某个元素的后面一个元素。遍历链表就是跟着链表从链表的头元素（head）一直走到尾元素（但是不包含链表的头节点，头通常用来作为链表的接入点）。链表的尾元素指向一个null节点。 分类单链表（见定义） 循环链表循环链表的运算与单链表的运算基本一致。所不同的有以下几点：1、在建立一个循环链表时，必须使其最后一个结点的指针指向表头结点，而不是象单链表那样置为NULL。此种情况还使用于在最后一个结点后插入一个新的结点。2、在判断是否到表尾时，是判断该结点链域的值是否是表头结点，当链域值等于表头指针时，说明已到表尾。而非象单链表那样判断链域值是否为NULL。 双向链表双向链表其实是单链表的改进。当我们对单链表进行操作时，有时你要对某个结点的直接前驱进行操作时，又必须从表头开始查找。这是由单链表结点的结构所限制的。因为单链表每个结点只有一个存储直接后继结点地址的链域，那么能不能定义一个既有存储直接后继结点地址的链域，又有存储直接前驱结点地址的链域的这样一个双链域结点结构呢？这就是双向链表。在双向链表中，结点除含有数据域外，还有两个链域，一个存储直接后继结点地址，一般称之为右链域；一个存储直接前驱结点地址，一般称之为左链域。 链表的操作链表的操作通常需要操作两个节点，例如，向链表中插入一个节点，需要修改它前面的节点，使其指向新加入的节点，而新加入的节点则指向前面指向的节点从链表中删除一个节点也很简单，将待删除的元素的前驱节点指向待删除的后续节点，同时将待删除元素指向null来释放。 代码实现12345//Definition for singly-linked list.function ListNode(val) &#123; this.val = val; this.next = null;&#125; 查找：12345678910const findListNode = (listNode, target) =&gt; &#123; while(listNode) &#123; if (listNode.val === target) &#123; return true; &#125;; listNode = listNode.next ? listNode.next : null &#125; return "not hava this target";&#125; 插入12345678910111213//在第target个元素后添加一个节点const insertListNode = (listNode1, node, target) =&gt; &#123; const count = 0 while(listNode) &#123; if (count === target) &#123; node.next = listNode.next; listNode.next = node return 0; &#125;; listNode = listNode.next ? listNode.next : null count++; &#125;&#125;]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html5语意化学习]]></title>
    <url>%2F2018%2F05%2F28%2Fhtml5%E8%AF%AD%E6%84%8F%E5%8C%96%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[百度前端技术学院学习笔记（二） 百度前端技术学院，第二天课程已经脱了好几天了，最近项目上线以及一些其他的事情，一只拖延着我这只拖延狗的进度。。今天终于抽出时间来整理一下这个知识点。 目标简介 Date: 2018.05.28 Mon Target: 熟悉html语意化。 Time: 1day 语意化探究语意化，就是根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。那通俗一点来说，就是为了让编写让人和机器都认识的代码。 语意化的意义 为了在没有样式的时候，页面也能呈现出很好地内容结构、代码结构 更好的用户体验 便于SEO 方便其他设备解析 便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。 部分语意化标签 标签 意义 用法 header 头部标签 用于网页顶部，作为头部 footer 底部标签 用于网页底部，内容多相关信息 hgroup 网页标签 网页或者含有多个h标签的 nav 导航标签 放置导航栏 aside 侧栏标签 侧边栏的内容 section 区块的标签 一个独立的区域 article 文章标签 一片文章的区域 h1-h6 标题标签 按照标题的大小选择 p 段落标签 一个段落 audio 声音标签 用来链接音频 video 视频标签 用来链接视频 相关问题Q1: HTML是什么，HTML5是什么？A1: 超级文本标记语言是标准通用标记语言下的一个应用，也是一种规范，一种标准，它通过标记符号来标记要显示的网页中的各个部分。HTML5是HTML的第五次修改，HTML5的革新之一：语义化标签一节元素标签。 Q2: HTML元素标签、属性都是什么概念？A2: HTML的标签就是一个个网页的结构元素，一个网页是由一个个元素组合起来的。属性是标签的一些性质，包括ID、名称、URI、数字、长度单位、语言、媒体描述符、颜色、字符编码、日期和时间等。 Q3: 文档类型是什么概念，起什么作用？A3: 文档类型有严格模式和非严格模式，应用严格模式来编写页面，更严谨。H5没有文档类型。 Q4: meta标签都用来做什么的？A4: 元素可提供相关页面的元信息（meta-information），标签位于文档的头部，不包含任何内容。标签的属性定义了与文档相关联的名称/值对。 meta标签共有两个属性，它们分别是http-equiv属性和name属性，不同的属性又有不同的参数值，这些不同的参数值就实现了不同的网页功能。 meta 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。 meta 标签位于文档的头部，不包含任何内容。 meta 标签的属性定义了与文档相关联的名称/值对。 Q5: Web语义化是什么，是为了解决什么问题A5：就是根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析解决了SEO等问题 Q6: 链接是什么概念，对应什么标签？A6: 是支持浏览器文档与外部资源的关系。对应link标签]]></content>
      <categories>
        <category>Glory Road</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插入排序]]></title>
    <url>%2F2018%2F05%2F25%2F%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，但将最后一个元素除外（让数组多一个空间才有插入的位置），而第二部分就只包含这一个元素（即待插入元素）。在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。插入排序的基本思想是：每步将一个待排序的记录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。 直接插入排序的算法思路：（1） 设置监视哨r[0]，将待插入记录的值赋值给r[0]；（2） 设置开始查找的位置j；（3） 在数组中进行搜索，搜索中将第j个记录后移，直至r[0].key≥r[j].key为止；（4） 将r[0]插入r[j+1]的位置上。 1234567891011121314const insertionSort = (arr) =&gt; &#123; let len = arr.length; for(let i=1; i&lt;len; i++) &#123; let j = i; let tmp = arr[i]; while(j &gt; 0 &amp;&amp; arr[j-1] &gt; tmp) &#123; arr[j] = arr[j-1]; j--; &#125; arr[j] = tmp; &#125; return arr;&#125;]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则填坑]]></title>
    <url>%2F2018%2F05%2F25%2F%E6%AD%A3%E5%88%99%E5%A1%AB%E5%9D%91%2F</url>
    <content type="text"><![CDATA[正则表达式 简介正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为”元字符”）。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。 应用通过使用正则表达式，可以：1、测试字符串内的模式。例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。替换文本。2、可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。基于模式匹配从字符串中提取子字符串。3、可以查找文档内或输入域内特定的文本。 语法正则表达式包含好多种字符，普通字符，非打印字符，特殊字符，限定符，定位符 元字符 字符 描述 \ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\n’ 匹配一个换行符。序列 ‘\‘ 匹配 “\” 而 “(“ 则匹配 “(“。 ^ 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。 * 匹配前面的子表达式零次或多次。例如，zo 能匹配 “z” 以及 “zoo”。 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 ? 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。 . 匹配除换行符（\n、\r）之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用像”(.\n)”的模式。 [xyz] 字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’、’l’、’i’、’n’。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。 [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。 \b 匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。 \B 匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。 \cx 匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。 \d 匹配一个数字字符。等价于 [0-9]。 \D 匹配一个非数字字符。等价于 [^0-9]。 \f 匹配一个换页符。等价于 \x0c 和 \cL。 \n 匹配一个换行符。等价于 \x0a 和 \cJ。 \r 匹配一个回车符。等价于 \x0d 和 \cM。 \s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。 \S 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。 \t 匹配一个制表符。等价于 \x09 和 \cI。 \v 匹配一个垂直制表符。等价于 \x0b 和 \cK。 \w 匹配字母、数字、下划线。等价于’[A-Za-z0-9_]’。 \W 匹配非字母、数字、下划线。等价于 ‘[^A-Za-z0-9_]’。 \xn 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，’\x41’ 匹配 “A”。’\x041’ 则等价于 ‘\x04’ &amp; “1”。正则表达式中可以使用 ASCII 编码。 \num 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，’(.)\1’ 匹配两个连续的相同字符。 \n 标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。 \nm 标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。 \nml 如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。 \un 匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[放飞的thinking～]]></title>
    <url>%2F2018%2F05%2F24%2F%E6%94%BE%E9%A3%9E%E7%9A%84thinking%EF%BD%9E%2F</url>
    <content type="text"><![CDATA[百度前端技术学院学习笔记（一） 目标简介 Date: 2018.05.24 Thr Flag: 真男人就坚持66天。 Target: 了解前端。 Time: 1h 课程内容1、什么是前端？ 前端这个概念，我觉得应该这么来理解，前：表示与用户直接有关的部分，比如页面的展示，与用户的交互等，端：是终端的部分，包括pc，移动端以及其他的一些可以与用于交互的终端。 从百度百科上看到了前端的解释： 前端即网站前台部分，运行在PC端，移动端等浏览器上展现给用户浏览的网页。随着互联网技术的发展，HTML5，CSS3，前端框架的应用，跨平台响应式网页设计能够适应各种屏幕分辨率，完美的动效设计，给用户带来极高的用户体验。 感觉差不多吧… 2、什么是html？ html：超文本标记语言，标准通用标记语言下的一个应用。 我理解的是，用来构建页面的骨架的语言。 html提供了语义化的标签，以及相关的属性，根据标签和属性以及内容构建页面的骨架。 3、什么是CSS？ CSS：层叠样式表(英文全称：Cascading Style Sheets)是一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的计算机语言。CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。 CSS，可以理解成骨架的衣服，好的页面有了骨架还不行，还得需要漂亮的衣服。html写好了骨架，通过写CSS来写样式，让页面变得更好看。 4、什么是Javascript？ JavaScript一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加动态功能。 js是一种脚本语言，可以给页面添加交互，以及相关的逻辑，还有和后台通过接口交互数据等。 课程疑问1、现在背景下的大前端该如何发展？2、框架的不断推出，框架的学习和个人技能的发展的均衡？3、因为node的存在，前端工程师往全栈工程师的发展是否成为必要？ 总结学习前端有一年的时间了，半路出家，从机械转到了前端。从开始写外包，囫囵吞枣，会用就行，到工作之后，发现自己欠缺的东西还有好多好多。开始逐渐的弥补自己的知识。虽然起步比较晚，但是还是很喜欢js这个不断进步的语言～希望能够通过自己的努力，成为一个真正的FE developer！]]></content>
      <categories>
        <category>Glory Road</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>CSS</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[koa2源码学习--application.js]]></title>
    <url>%2F2018%2F05%2F24%2Fkoa2%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0--application.js%2F</url>
    <content type="text"><![CDATA[一直很想研究下koa2，虽然还是小白一枚，但终于决定入坑koa2。之前只知道koa2采用了ES2015和ES2016的一些东西，还知道洋葱头的中间件的运行机制。还是先研究一下源码，学习一下大神写代码的畅快感。 把代码拉下来之后，发现lib里只有四个源码文件：application.js, context.js, request.js, response.js。 application.js 是koa的入口文件,是一个构造函数，它暴露整个应用的class, 这个class继承自node自带的events，并且把 context、request 和 response 属性指向了原型链指向其他三个文件导出对象的实例。 application暴露了一些公用的api, 比如listen，use, callback等。 下面来研究一些application.js的源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256'use strict';/** * 依赖的模块 */const isGeneratorFunction = require('is-generator-function'); //判断函数是否为generator函数const debug = require('debug')('koa:application'); //调试模式const onFinished = require('on-finished'); //HTTP请求关闭，完成或错误时执行回调。const response = require('./response'); //reponse.jsconst compose = require('koa-compose'); //koa中间件组合工具const isJSON = require('koa-is-json'); //检查body应该是一个json格式const context = require('./context'); //上下文context.jsconst request = require('./request'); //request.jsconst statuses = require('statuses'); ////http状态工具status(403) // =&gt; 'Forbidden'，可以通过code转换成msg，也可以通过msg转换成codeconst Cookies = require('cookies'); //提供一个读写cookie的APIconst accepts = require('accepts'); //一个比较高级的API用来http处理请求中的接受类型，const Emitter = require('events'); //node的events模块？const assert = require('assert'); //通过状态码进行断言？const Stream = require('stream'); //流文件？const http = require('http'); // node的http模块？const only = require('only'); //返回白名单中的值。其实就是根据一个列表获取一个对象中的部分属性返回一个objconst convert = require('koa-convert'); //提供function *的语法的转换器const deprecate = require('depd')('koa'); //提示？/** * 暴露一个application的类 * 继承自 `Emitter.prototype`. */module.exports = class Application extends Emitter &#123; /** * 初始化一个新的 `Application`. * * @api public */ constructor() &#123; super(); //定义下面的属性 this.proxy = false; //代理 this.middleware = []; //中间件的队列 this.subdomainOffset = 2; //对于要忽略的 .subdomains 偏移[2] this.env = process.env.NODE_ENV || 'development'; //env默认是 NODE_ENV 或 "development" this.context = Object.create(context); //创建一个新context对象，使用context对象来提供新创建的对象的__proto__。 this.request = Object.create(request);//创建一个新request对象 this.response = Object.create(response);//创建一个新response对象 &#125; /** * Shorthand for: * * http.createServer(app.callback()).listen(...) * * @param &#123;Mixed&#125; ... * @return &#123;Server&#125; * @api public */ //listen(),调用node的createServer方法，返回一个服务器。参数为端口号， listen(...args) &#123; debug('listen'); const server = http.createServer(this.callback());// return server.listen(...args); &#125; /** * Return JSON representation. * We only bother showing settings. * * @return &#123;Object&#125; * @api public */ //toJSON 方法，通过only方法，把key放到obj里 返回一个object对象 toJSON() &#123; return only(this, [ 'subdomainOffset', 'proxy', 'env' ]); &#125; /** * Inspect implementation. * * @return &#123;Object&#125; * @api public */ //检查,返回一个object对象 inspect() &#123; return this.toJSON(); &#125; /** * 把给定的中间件函数fn，推入到middleware队列中 * * 以前写法的中间件将会被转换 * * @param &#123;Function&#125; fn * @return &#123;Application&#125; self * @api public */ use(fn) &#123; if (typeof fn !== 'function') throw new TypeError('middleware must be a function!'); if (isGeneratorFunction(fn)) &#123; deprecate('Support for generators will be removed in v3. ' + 'See the documentation for examples of how to convert old middleware ' + 'https://github.com/koajs/koa/blob/master/docs/migration.md'); fn = convert(fn); &#125; debug('use %s', fn._name || fn.name || '-'); this.middleware.push(fn); return this; &#125; /** * Return a request handler callback * for node's native http server. * * @return &#123;Function&#125; * @api public */ //返回适用于 http.createServer() 方法的回调函数来处理请求。 //启动server和接收请求 callback() &#123; const fn = compose(this.middleware);//启动server时执行，初始化中间件 if (!this.listenerCount('error')) this.on('error', this.onerror); //接收请求时执行处理请求的函数 const handleRequest = (req, res) =&gt; &#123; const ctx = this.createContext(req, res);//创建一个最终可用的context return this.handleRequest(ctx, fn); &#125;; return handleRequest; &#125; /** * callback里的一个处理请求的方法， * * @api private */ handleRequest(ctx, fnMiddleware) &#123; const res = ctx.res; res.statusCode = 404; const onerror = err =&gt; ctx.onerror(err); const handleResponse = () =&gt; respond(ctx); onFinished(res, onerror); return fnMiddleware(ctx).then(handleResponse).catch(onerror); &#125; /** * Initialize a new context. * * @api private */ createContext(req, res) &#123; const context = Object.create(this.context); const request = context.request = Object.create(this.request); const response = context.response = Object.create(this.response); context.app = request.app = response.app = this; context.req = request.req = response.req = req; context.res = request.res = response.res = res; request.ctx = response.ctx = context; request.response = response; response.request = request; context.originalUrl = request.originalUrl = req.url; context.cookies = new Cookies(req, res, &#123; keys: this.keys, secure: request.secure &#125;); request.ip = request.ips[0] || req.socket.remoteAddress || ''; context.accept = request.accept = accepts(req); context.state = &#123;&#125;; return context; &#125; /** * Default error handler. * * @param &#123;Error&#125; err * @api private */ onerror(err) &#123; assert(err instanceof Error, `non-error thrown: $&#123;err&#125;`); if (404 == err.status || err.expose) return; if (this.silent) return; const msg = err.stack || err.toString(); console.error(); console.error(msg.replace(/^/gm, ' ')); console.error(); &#125;&#125;;/** * Response helper. */function respond(ctx) &#123; // allow bypassing koa if (false === ctx.respond) return; const res = ctx.res; if (!ctx.writable) return; let body = ctx.body; const code = ctx.status; // ignore body if (statuses.empty[code]) &#123; // strip headers ctx.body = null; return res.end(); &#125; if ('HEAD' == ctx.method) &#123; if (!res.headersSent &amp;&amp; isJSON(body)) &#123; ctx.length = Buffer.byteLength(JSON.stringify(body)); &#125; return res.end(); &#125; // status body if (null == body) &#123; body = ctx.message || String(code); if (!res.headersSent) &#123; ctx.type = 'text'; ctx.length = Buffer.byteLength(body); &#125; return res.end(body); &#125; // responses if (Buffer.isBuffer(body)) return res.end(body); if ('string' == typeof body) return res.end(body); if (body instanceof Stream) return body.pipe(res); // body: json body = JSON.stringify(body); if (!res.headersSent) &#123; ctx.length = Buffer.byteLength(body); &#125; res.end(body);&#125;]]></content>
      <categories>
        <category>koa2源码学习</category>
      </categories>
      <tags>
        <tag>Koa</tag>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react生命周期理解]]></title>
    <url>%2F2018%2F05%2F22%2Freact%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[react组建的生命周期 React组件的生命周期有两种情况，初次渲染和状态更新导致再次渲染。React 生命周期分为三种状态 1. 挂载 2.更新 3.销毁 组件加载组件的初次挂载，有以下几个步骤，分别是1、构造函数，指定This，初始状态，绑定函数（constructor）2、组件安装（componentWillMount）3、将组建或者虚拟DOM元素渲染到真实的DOM上（render）4、组件生成，DOM查找等(componentDidMount) 组件更新组件的更新，有三种情况：1.父组件的props发生更新2.调用this.forceUpdate更新（重复componentWillUpdate方法之后的操作）3.调用this.setState方法更新组件state,触发组件更新 状态更新步骤：1、构造函数，指定This，初始状态，绑定函数（constructor）2、组件安装（componentWillMount）3、将组建或者虚拟DOM元素渲染到真实的DOM上（render）4、组件生成，DOM查找等(componentDidMount)5、组建更新状态(componentWillUpdate)6、将组建或者虚拟DOM元素渲染到真实的DOM上（render）7、组建更新完成(componentDidUpdate) 调用this.forceUpdate更新当组件调用forceUpdata方法更新时，会进入componentWillUpdate方法。直接跳过shouldComponentUpdtavoid之后执行render函数更新DOMReactElement执行完render函数之后执行componentDidUpdata,除了首次render之后调用componentDidMount，其它render结束之后都是调用componentDidUpdate。 父组建更新props步骤：1、父组件构造函数，指定This，初始状态，绑定函数（constructor）2、父组件安装（componentWillMount）3、父组件或者虚拟DOM元素渲染到真实的DOM上（render）4、子组件或者虚拟DOM元素渲染到真实的DOM上（render）5、父组件生成，DOM查找等(componentDidMount)6、父组建更新状态(componentWillUpdate)7、父组件或者虚拟DOM元素渲染到真实的DOM上（render）8、子组件接收父组件props(componentWillReceiveProps)9、子组件判断是否更新(shouldComponentUpdate)10、子组建更新状态(componentWillUpdate)11、子组件或者虚拟DOM元素渲染到真实的DOM上（render）12、子组件更新完成(componentDidUpdate)12、父组件更新完成(componentDidUpdate) 组件销毁单页应用中，切换页面原组件需要销毁释放资源，如果原组件中有定时器等不能销毁时，需要在componentWillUnmount中清理资源占用，手动销毁定时器。 总结]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆排序]]></title>
    <url>%2F2018%2F05%2F21%2F%E5%A0%86%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] &gt;= A[i]。在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶。 具体算法描述如下： 1、将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；2、将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn), 且满足R[1,2…n-1]&lt;=R[n]；3、由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。 时间复杂度：最好：O(nlog2n)，最坏：O(nlog2n)，平均：O(nlog2n)。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/*方法说明：堆排序@param array 待排序数组*/ const heapSort = (arr) =&gt; &#123; if (Object.prototype.toString.call(array).slice(8, -1) === 'Array') &#123; //建堆 let heapSize = array.length, temp; for (let i = Math.floor(heapSize / 2); i &gt;= 0; i--) &#123; heapify(array, i, heapSize); &#125; //堆排序 for (let j = heapSize - 1; j &gt;= 1; j--) &#123; temp = array[0]; array[0] = array[j]; array[j] = temp; heapify(array, 0, --heapSize); &#125; &#125; else &#123; return 'array is not an Array!'; &#125;&#125;/*方法说明：维护堆的性质@param arr 数组@param x 数组下标@param len 堆大小*/const heapify = (arr, x, len) =&gt; &#123; if (Object.prototype.toString.call(arr).slice(8, -1) === 'Array' &amp;&amp; typeof x === 'number')&#123; let l = 2 * x, r = 2 * x + 1, largest = x, temp; if (l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) &#123; largest = l; &#125; if (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) &#123; largest = r; &#125; if (largest != x) &#123; temp = arr[x]; arr[x] = arr[largest]; arr[largest] = temp; heapify(arr, largest, len); &#125; &#125; else &#123; return 'arr is not an Array or x is not a number!'; &#125;&#125;]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序]]></title>
    <url>%2F2018%2F05%2F19%2F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。 把长度为n的输入序列分成两个长度为n/2的子序列；对这两个子序列分别采用归并排序；将两个排序好的子序列合并成一个最终的排序序列。 归并操作的工作原理如下：第一步：申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列第二步：设定两个指针，最初位置分别为两个已经排序序列的起始位置第三步：比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置重复步骤3直到某一指针超出序列尾将另一序列剩下的所有元素直接复制到合并序列尾 最佳情况：T(n) = O(n)最差情况：T(n) = O(nlogn)平均情况：T(n) = O(nlogn) 123456789101112131415161718const mergeSort = (arr) =&gt; &#123; let len = arr.lenght; if (len &lt; 2) &#123; return arr; &#125; let m = (len &gt;&gt; 1), //通过位运算符，将len取为一半。 left = array.slice(0, m), right = array.slice(m); //拆分为两个子数组 return merge(mergeSort(left), mergeSort(right));//子数组继续递归拆分,然后再合并&#125;const merge = (left, right) =&gt; &#123; //合并两个子数组 let res = []; while (left.length &amp;&amp; right.length) &#123; let item = left[0] &lt;= right[0] ? left.shift() : right.shift();//注意:判断的条件是小于或等于,如果只是小于,那么排序将不稳定. result.push(item); &#125; return result.concat(left.length ? left : right);&#125;]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选择排序]]></title>
    <url>%2F2018%2F05%2F19%2F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法。 简单选择排序的基本思想：第1趟，在待排序记录r[1]~r[n]中选出最小的记录，将它与r[1]交换；第2趟，在待排序记录r[2]~r[n]中选出最小的记录，将它与r[2]交换；以此类推，第i趟在待排序记录r[i]~r[n]中选出最小的记录，将它与r[i]交换，使有序序列不断增长直到全部排序完毕。 最佳情况：T(n) = O(n^2)最差情况：T(n) = O(n^2)平均情况：T(n) = O(n^2) 1234567891011const selectSort = (arr) =&gt; &#123; let len = arr.length, min; for (let i = 0; i &lt; len - 1; i++) &#123; min = i; for (let j = i + 1; j &lt; len; j++)&#123; arr[j] &lt; arr[min] &amp;&amp; (min = j); &#125; min != i &amp;&amp; swap(i,min,arr); &#125; return arr&#125;]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序]]></title>
    <url>%2F2018%2F05%2F19%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[快速排序（Quicksort）是对冒泡排序的一种改进。快速排序的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 一趟快速排序的算法是：（1）在数据集之中，选择一个元素作为”基准”（pivot）。（2）所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。（3）对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。 最佳情况：T(n) = O(nlogn)最差情况：T(n) = O(n2)平均情况：T(n) = O(nlogn) 12345678910111213141516const quickSort = (arr) =&gt; &#123; if (arr.length &lt;= 1) &#123; return arr; &#125; let pivotIndex = arr.length &gt;&gt; 1; console.log(pivotIndex); let pivot = arr.splice(pivotIndex, 1)[0]; let left = []; let right = []; for (let i = 0; i &lt; arr.length; i++)&#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; return quickSort(left).concat([pivot], quickSort(right));&#125;]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序]]></title>
    <url>%2F2018%2F05%2F19%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。 冒泡排序算法的运作如下：（从后往前）比较相邻的元素。如果第一个比第二个大，就交换他们两个。对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。针对所有的元素重复以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 时间复杂度：冒泡排序最好的时间复杂度为O(n)。冒泡排序的最坏时间复杂度为O(n^2)。冒泡排序总的平均时间复杂度为O(n^2)。 12345678910111213const bubbleSort = (arr) =&gt; &#123; let len = arr.length; for (let i = 0; i &lt; len - 1; i++) &#123; for (let j = 0; j &lt; len - 1 - j; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; let temp = arr[j+1]; arr[j+1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; return arr;&#125;]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax实现]]></title>
    <url>%2F2018%2F05%2F16%2Fajax%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[Q1: 何谓ajax，它有何优点？A1:AJAX = 异步 JavaScript 和 XML。AJAX 是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据 交换，AJAX 可以使网页实现异步更新 Q2:ajax 如何实现？A2:步骤：(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象. (2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息. (3)设置响应HTTP请求状态变化的函数. (4)发送HTTP请求. (5)获取异步调用返回的数据. (6)使用JavaScript和DOM实现局部刷新. 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;html&gt; &lt;head&gt; &lt;title&gt;AJAX实例&lt;/title&gt; &lt;script language="javascript" type="text/javascript"&gt; var xmlHttpRequest; //定义一个变量用于存放XMLHttpRequest对象 //定义一个用于创建XMLHttpRequest对象的函数 function createXMLHttpRequest()&#123; if(window.ActiveXObject)&#123; //IE浏览器的创建方式 xmlHttpRequest = new ActiveXObject("Microsoft.XMLHTTP"); &#125;else if(windew.XMLHttpRequest)&#123; //Netscape浏览器中的创建方式 xmlHttpRequest = new XMLHttpRequest(); &#125; &#125; //响应HTTP请求状态变化的函数 function httpStateChange()&#123; //判断异步调用是否完成 if(xmlHttpRequest.readyState == 4)&#123; //判断异步调用是否成功,如果成功开始局部更新数据 if(xmlHttpRequest.status == 200||xmlHttpRequest.status == 0)&#123; //查找节点 var node = document.getElementById("myDIv"); //更新数据 node.firstChild.nodeValue = xmlHttpRequest .responseText; &#125;else&#123; //如果异步调用未成功,弹出警告框,并显示出错信息 alert("异步调用出错/n返回的HTTP状态码为:"+xmlHttpRequest.status + "/n返回的HTTP状态信息为:" + xmlHttpRequest.statusText); &#125; &#125; &#125; //异步调用服务器段数据 function getData(name,value)&#123; //创建XMLHttpRequest对象 createXMLHttpRequest(); if(xmlHttpRequest!=null)&#123; //创建HTTP请求 xmlHttpRequest.open("get","ajax.text",true) //设置HTTP请求状态变化的函数 xmlHttpRequest.onreadystatechange = httpStateChange; //发送请求 xmlHttpRequest.send(null); &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="myDiv"&gt;原数据&lt;/div&gt; &lt;input type = "button" value = "更新数据" onclick = "getData()"&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>Demo练习</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域问题探究]]></title>
    <url>%2F2018%2F05%2F15%2F%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E6%8E%A2%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[Q1: 什么是跨域？A1: 一个域上加载的脚本获取或操作另一个域上的文档属性，是指a页面想获取b页面资源，如果a、b页面的协议、域名、端口、子域名不同，或是a页面为ip地址，b页面为域名地址，所进行的访问行动都是跨域的。而浏览器为了安全问题一般都限制了跨域访问，也就是不允许跨域请求资源。 Q2: 怎么算跨域？A2: Uri 说明 是否跨域 http://www.cnblogs.com/a.js http://www.a.com/b.js 不同域名 是 http://www.a.com/lab/a.js http://www.a.com/script/b.js 同域名下不同文件 否 http://www.a.com:8000/a.js http://www.a.com/b.js 同域名下不同端口 是 http://www.a.com/a.js s https://www.a.com/b.js 同域名 不同协议 是 http://www.a.com/a.js http://70.32.92.74/b.jss 域名和域名对应ip 是 http://www.a.com/a.js http://script.a.com/b.js 主域名相同 子域名不同 是（cookie不可访问） http://www.a.com/a.js http://a.com/b.js 同一域名，不同二级域名（同上） 是 Q3: 什么是浏览器的同源策略？A3: 计算机的本地与Web是不同的层面，Web世界（通常称为Internet域）运行在浏览器上，而被限制了直接进行本地数据（通常称为本地域）的读写。同源策略是众多安全策略的一个，是Web层面上的策略，同源策略规定：不同域的客户端脚本在没明确授权的情况下，不能读写对方的资源。 Q4: 怎么解决跨域？A4: 有那么几种方法可以来解决跨域：1、Jsonp 需要目标服务器配合一个callback函数，但是注意JSONP只支持GET请求，不支持POST请求。 123456789101112131415&lt;script type="text/javascript" src="jquery.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $.ajax(&#123; url: api.testURI, dataType:'jsonp', data:'', jsonp:'callback', success:function(result) &#123; for(var i in result) &#123; alert(i+":"+result[i]);//循环输出a:1,b:2,etc. &#125; &#125;, timeout:3000 &#125;); &lt;/script&gt; 2、通过修改document.domain来跨子域将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域。主域相同的使用document.domain 3、使用window.name来进行跨域 12345window.name = data; //接着，子窗口跳回一个与主窗口同域的网址。 location = 'http://parent.url.com/xxx.html'; //然后，主窗口就可以读取子窗口的window.name了 var data = document.getElementById('iframe').contentWindow.name; 4、通过CORS解决AJAX跨域 12345678910111213141516171819function test() &#123; $.ajax(&#123; url: api.testURI, type: "get", async: false, data:&#123; "id":1 &#125;, dataType:"json", withCredentials:true, success: function(data)&#123; alert(data); alert(data.code); &#125;, error: function()&#123; alert('fail'); &#125; &#125;)&#125; 5.服务器设置Access-Control-Allow-Origin实现跨域 123456app.all("*", function(req, res, next) &#123; const host = req.headers.origin; res.header('Access-Control-Allow-Origin', host) //res.header('Access-Control-Allow-Origin', *) next();&#125;);]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[webpack 配置理解]]></title>
    <url>%2F2018%2F05%2F15%2Fwebpack-%E9%85%8D%E7%BD%AE%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 webpack 4 虽然已经不需要引入一个配置文件。但是，webpack在实际的应用中还是会配置很多东西。下面就是对webpack的配置分析：从webpack文档中找出路配置，进行了分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355const path = require('path');module.exports = &#123; mode: "production", // "production" | "development" | "none" // webpack有三种模式：生产模式，开发模式，none；选择模式告诉webpack相应地使用其内置优化。 entry: "./app/entry", // string | object | array // webpack的入口文件，这里应用程序开始执行 // webpack 开始打包 output: &#123; // webpack 如何输出结果的相关选项 path: path.resolve(__dirname, "dist"), // string // 所有输出文件的目标路径 // 必须是绝对路径（使用 Node.js 的 path 模块） filename: "bundle.js", // string // 「入口分块(entry chunk)」的文件名模板（出口分块？） publicPath: "/assets/", // string // 输出解析文件的目录，url 相对于 HTML 页面 library: "MyLibrary", // string, // 导出库(exported library)的名称 libraryTarget: "umd", // 通用模块定义 // 导出库(exported library)的类型 /* 高级输出配置 */ pathinfo: true, // boolean // 在生成代码时，引入相关的模块、导出、请求等有帮助的路径信息。 chunkFilename: "[id].js", chunkFilename: "[chunkhash].js", // 长效缓存(/guides/caching) // 「附加分块(additional chunk)」的文件名模板 jsonpFunction: "myWebpackJsonp", // string // 用于加载分块的 JSONP 函数名 sourceMapFilename: "[file].map", // string sourceMapFilename: "sourcemaps/[file].map", // string // 「source map 位置」的文件名模板 devtoolModuleFilenameTemplate: "webpack:///[resource-path]", // string // 「devtool 中模块」的文件名模板 devtoolFallbackModuleFilenameTemplate: "webpack:///[resource-path]?[hash]", // string // 「devtool 中模块」的文件名模板（用于冲突） umdNamedDefine: true, // boolean // 在 UMD 库中使用命名的 AMD 模块 crossOriginLoading: "use-credentials", // 枚举 crossOriginLoading: "anonymous", crossOriginLoading: false, // 指定运行时如何发出跨域请求问题 /* 专家级输出配置（自行承担风险） */ devtoolLineToLine: &#123; test: /\.jsx$/ &#125;, // 为这些模块使用 1:1 映射 SourceMaps（快速） hotUpdateMainFilename: "[hash].hot-update.json", // string // 「HMR 清单」的文件名模板 hotUpdateChunkFilename: "[id].[hash].hot-update.js", // string // 「HMR 分块」的文件名模板 sourcePrefix: "\t", // string // 包内前置式模块资源具有更好可读性 &#125;, module: &#123; // 关于模块配置 rules: [ // 模块规则（配置 loader、解析器等选项） &#123; test: /\.jsx?$/, include: [ path.resolve(__dirname, "app") ], exclude: [ path.resolve(__dirname, "app/demo-files") ], // 这里是匹配条件，每个选项都接收一个正则表达式或字符串 // test 和 include 具有相同的作用，都是必须匹配选项 // exclude 是必不匹配选项（优先于 test 和 include） // 最佳实践： // - 只在 test 和 文件名匹配 中使用正则表达式 // - 在 include 和 exclude 中使用绝对路径数组 // - 尽量避免 exclude，更倾向于使用 include issuer: &#123; test, include, exclude &#125;, // issuer 条件（导入源） enforce: "pre", enforce: "post", // 标识应用这些规则，即使规则覆盖（高级选项） loader: "babel-loader", // 应该应用的 loader，它相对上下文解析 // 为了更清晰，`-loader` 后缀在 webpack 2 中不再是可选的 // 查看 webpack 1 升级指南。 options: &#123; presets: ["es2015"] &#125;, // loader 的可选项 &#125;, &#123; test: /\.html$/, test: "\.html$" use: [ // 应用多个 loader 和选项 "htmllint-loader", &#123; loader: "html-loader", options: &#123; /* ... */ &#125; &#125; ] &#125;, &#123; oneOf: [ /* rules */ ] &#125;, // 只使用这些嵌套规则之一 &#123; rules: [ /* rules */ ] &#125;, // 使用所有这些嵌套规则（合并可用条件） &#123; resource: &#123; and: [ /* 条件 */ ] &#125; &#125;, // 仅当所有条件都匹配时才匹配 &#123; resource: &#123; or: [ /* 条件 */ ] &#125; &#125;, &#123; resource: [ /* 条件 */ ] &#125;, // 任意条件匹配时匹配（默认为数组） &#123; resource: &#123; not: /* 条件 */ &#125; &#125; // 条件不匹配时匹配 ], /* 高级模块配置（点击展示） */ noParse: [ /special-library\.js$/ ], // 不解析这里的模块 unknownContextRequest: ".", unknownContextRecursive: true, unknownContextRegExp: /^\.\/.*$/, unknownContextCritical: true, exprContextRequest: ".", exprContextRegExp: /^\.\/.*$/, exprContextRecursive: true, exprContextCritical: true, wrappedContextRegExp: /.*/, wrappedContextRecursive: true, wrappedContextCritical: false, // 指定动态请求的默认行为 &#125;, resolve: &#123; // 解析模块请求的选项 // （不适用于对 loader 解析） modules: [ "node_modules", path.resolve(__dirname, "app") ], // 用于查找模块的目录 extensions: [".js", ".json", ".jsx", ".css"], // 使用的扩展名 alias: &#123; // 模块别名列表 "module": "new-module", // 起别名："module" -&gt; "new-module" 和 "module/path/file" -&gt; "new-module/path/file" "only-module$": "new-module", // 起别名 "only-module" -&gt; "new-module"，但不匹配 "only-module/path/file" -&gt; "new-module/path/file" "module": path.resolve(__dirname, "app/third/module.js"), // 起别名 "module" -&gt; "./app/third/module.js" 和 "module/file" 会导致错误 // 模块别名相对于当前上下文导入 &#125;, /* 可供选择的别名语法（点击展示） */ alias: [ &#123; name: "module", // 旧的请求 alias: "new-module", // 新的请求 onlyModule: true // 如果为 true，只有 "module" 是别名 // 如果为 false，"module/inner/path" 也是别名 &#125; ], /* 高级解析选项（点击展示） */ symlinks: true, // 遵循符号链接(symlinks)到新位置 descriptionFiles: ["package.json"], // 从 package 描述中读取的文件 mainFields: ["main"], // 从描述文件中读取的属性 // 当请求文件夹时 aliasFields: ["browser"], // 从描述文件中读取的属性 // 以对此 package 的请求起别名 enforceExtension: false, // 如果为 true，请求必不包括扩展名 // 如果为 false，请求可以包括扩展名 moduleExtensions: ["-module"], enforceModuleExtension: false, // 类似 extensions/enforceExtension，但是用模块名替换文件 unsafeCache: true, unsafeCache: &#123;&#125;, // 为解析的请求启用缓存 // 这是不安全，因为文件夹结构可能会改动 // 但是性能改善是很大的 cachePredicate: (path, request) =&gt; true, // 用于选择缓存请求的谓词函数 plugins: [ // ... ] // 应用于解析器的附加插件 &#125;, performance: &#123; hints: "warning", // or "error" or false maxAssetSize: 200000, // 整数类型（以字节为单位） maxEntrypointSize: 400000, // 整数类型（以字节为单位） assetFilter: function(assetFilename) &#123; // 提供资源文件名的断言函数 return assetFilename.endsWith('.css') || assetFilename.endsWith('.js'); &#125; &#125;, devtool: "source-map", // // devtool: "inline-source-map", // 嵌入到源文件中 // devtool: "eval-source-map", // 将 SourceMap 嵌入到每个模块中 // devtool: "hidden-source-map", // SourceMap 不在源文件中引用 // devtool: "cheap-source-map", // 没有模块映射(module mappings)的 SourceMap 低级变体(cheap-variant) // devtool: "cheap-module-source-map", // 有模块映射(module mappings)的 SourceMap 低级变体 // devtool: "eval", // 没有模块映射，而是命名模块。以牺牲细节达到最快。 // 通过在浏览器调试工具(browser devtools)中添加元信息(meta info)增强调试 // 牺牲了构建速度的 `source-map' 是最详细的。 context: __dirname, // string（绝对路径！） // webpack 的主目录 // entry 和 module.rules.loader 选项 // 相对于此目录解析 target: "web", // 默认 // 包(bundle)应该运行的环境 // 更改 块加载行为(chunk loading behavior) 和 可用模块(available module) externals: ["react", /^@angular\//], // 不要遵循/打包这些模块，而是在运行时从环境中请求他们 stats: "errors-only", // 精确控制要显示的 bundle 信息 devServer: &#123; proxy: &#123; // 代理URL到后端开发服务器 '/api': 'http://localhost:3000' auth: false //授权 changeOrigin: true //跨域 &#125;, contentBase: path.join(__dirname, 'public'), // boolean | string | array, 静态文件位置 compress: true, // 启用gzip压缩 historyApiFallback: true, // 提供重定向响应 404 -- 如果使用 hot: true, // 热加载 https: false, // 是否是https noInfo: true, // 只有错误并警告热重新加载 // ... &#125;, plugins: [ // ... ], // 附加插件列表 /* 高级配置（点击展示） */ resolveLoader: &#123; /* 等同于 resolve */ &#125; // 独立解析选项的 loader parallelism: 1, // number // 限制并行处理模块的数量 profile: true, // boolean // 捕获时机信息 bail: true, //boolean // 在第一个错误出错时抛出，而不是无视错误。 cache: false, // boolean // 禁用/启用缓存 watch: true, // boolean // 启用观察 watchOptions: &#123; aggregateTimeout: 1000, // in ms // 将多个更改聚合到单个重构建(rebuild) poll: true, poll: 500, // 间隔单位 ms // 启用轮询观察模式 // 必须用在不通知更改的文件系统中 // 即 nfs shares（译者注：Network FileSystem，最大的功能就是可以透過網路，讓不同的機器、不同的作業系統、可以彼此分享個別的檔案 ( share file )） &#125;, node: &#123; // 在非node环境下填充或模拟运行node环境 console: false, // boolean | "mock" global: true, // boolean | "mock" process: true, // boolean __filename: "mock", // boolean | "mock" __dirname: "mock", // boolean | "mock" Buffer: true, // boolean | "mock" setImmediate: true // boolean | "mock" | "empty" &#125;, recordsPath: path.resolve(__dirname, "build/records.json"), recordsInputPath: path.resolve(__dirname, "build/records.json"), recordsOutputPath: path.resolve(__dirname, "build/records.json"), // TODO&#125; Webpack 的工作流从 context 文件夹开始（框架内没有配置，那就默认为 ‘’）查找 entry 对应的文件(找到文件之后) 读取文件内容. 每当遇到 import (ES6) 或者 require() (Node) 依赖项时, 它会解析这些代码, 并且打包到最终构建里. 接着它会不断递归搜索实际需要的依赖项, 直到它到达了“树”的底部递归完所有依赖之后, Webpack 会将所有东西打包到 output.path 对应的目录, 并将 output.filename 的值作为最终的资源名 ([name] 表示使用 entry 项的 key)]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在页面中获取图片的尺寸]]></title>
    <url>%2F2018%2F05%2F14%2F%E5%9C%A8%E9%A1%B5%E9%9D%A2%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%9B%BE%E7%89%87%E7%9A%84%E5%B0%BA%E5%AF%B8%2F</url>
    <content type="text"><![CDATA[在js中写了获取图片的高度，却发现高度都是0.这是因为js运行的时候，图片还没有加载好所以在获取图片高度的时候，要用window.onload在图片都加载好了之后获取就可以了。 1234window.onload = function () &#123; var imgHeight = $(".bgImg").height() console.log(imgHeight);&#125;]]></content>
      <categories>
        <category>bug汇总</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery监控浏览器大小变化]]></title>
    <url>%2F2018%2F05%2F14%2Fjquery%E7%9B%91%E6%8E%A7%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A4%A7%E5%B0%8F%E5%8F%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425var screenWidth = window.screen.width;$(window).resize(function () &#123;//当浏览器大小变化时 if($(window).width()!== screenWidth)&#123; //history.go(0) &#125;&#125;);//监控浏览器旋转function orientationChange() &#123; switch (window.orientation) &#123; case 0: //history.go(0) break; case -90: //history.go(0) break; case 90: // history.go(0) break; case 180: //history.go(0) break; &#125;&#125;window.addEventListener('orientationchange', orientationChange);]]></content>
      <categories>
        <category>Demo练习</category>
      </categories>
      <tags>
        <tag>Jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设置overflow：hidden导致相邻行内元素向下偏移的问题]]></title>
    <url>%2F2018%2F05%2F14%2F%E8%AE%BE%E7%BD%AEoverflow%EF%BC%9Ahidden%E5%AF%BC%E8%87%B4%E7%9B%B8%E9%82%BB%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E5%90%91%E4%B8%8B%E5%81%8F%E7%A7%BB%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[123456&lt;!-- html --&gt;&lt;div&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt;&lt;/div&gt; 1234567/* CSS */div span&#123; display:inline-block;&#125;div span:nth(0)&#123; overflow:hidden;&#125; 这样设置之后，后面的两个span会向下偏移一定距离实际上就是inline-block元素的默认baseline和其下外边沿的距离。常用的解决方法是为上述inline-block元素添加vertical-align: bottom。]]></content>
      <categories>
        <category>bug汇总</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何去掉两个span间的间距]]></title>
    <url>%2F2018%2F05%2F14%2F%E5%A6%82%E4%BD%95%E5%8E%BB%E6%8E%89%E4%B8%A4%E4%B8%AAspan%E9%97%B4%E7%9A%84%E9%97%B4%E8%B7%9D%2F</url>
    <content type="text"><![CDATA[12345&lt;!-- html --&gt;&lt;div&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;&lt;/div&gt; 1234567/* CSS */div&#123; font-size：10px；&#125;span&#123; display:inline-block;&#125; 设置成块级元素的span，会因为父元素设置字体的大小，导致两个span外的空格会占有空隙。所以将父元素的font-size：0；然后再单独设置span的字体大小就可以解决这个问题。]]></content>
      <categories>
        <category>bug汇总</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery对追加事件的绑定]]></title>
    <url>%2F2018%2F05%2F14%2Fjquery%E5%AF%B9%E8%BF%BD%E5%8A%A0%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[写项目的时候又用到了jquery，突然发现，对于用jquery追加的元素，on方法绑定不能用。 发现：on要原始存在才绑定上，否则要用delegate来动态绑定1$(document).delegate('selecter','click', function () &#123; alert(this.innerHTML) &#125;);]]></content>
      <categories>
        <category>bug汇总</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS中position属性总结笔记]]></title>
    <url>%2F2018%2F05%2F14%2FCSS%E4%B8%ADposition%E5%B1%9E%E6%80%A7%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[写了好多的position，一直在用它们字面的意思，最近项目写到的position的问题，竟然又出问题了。。总结一下： 1. positon:static; 静态定位（默认的 ） 这个是默认的，写不写都会是这个定位，所有的标准文档流里面的元素都是静态定位。 2. positon:relative; 相对定位 相对定位不会使有该属性的元素脱离标准文档流 相对定位会在页面原始的位置占据位置，而元素的位置会根据原始的位置进行偏移。 相对定位的作用一般是用来给子元素的绝对定位提供参考的。 3. position:absolute; 绝对定位 绝对定位会使有该属性的元素脱离标准文档流 特点： 如果这个元素没有父元素，top、left、right、bottom就相对于浏览器窗口来定位 如果绝对定位的元素有父元素，且父元素没有相对定位，top、left、right、bottom相对于浏览窗口来定位 如果绝对定位的元素有父元素，且父元素有定位（非static），top、left、right、bottom以父元素为基础偏移 绝对定位之后的元素在页面上不会占据位置 4. position:fixed; 固定定位 固定定位会使有该属性的元素脱离标准文档流 位置不变，适用于广告或者飘窗 总结：写页面时，用到最多是绝对定位与相对定位一起使用，较多的是子元素使用绝对定位，父元素使用相对定位]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[变量的作用域和变量提升]]></title>
    <url>%2F2018%2F05%2F14%2F%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%2F</url>
    <content type="text"><![CDATA[某家面试的时候面试题，面试官小姐姐给出了一道题：123456789var a = 100;function test()&#123; console.log(a); a = 10; console.log(a); console.log(this.a); var a;&#125;test(); 问我这三个会打印出来的值是什么？ 研究一下这个变量的作用域和变量提升： 一、作用域： 一个变量的作用域（scope）是程序源代码中定义这个变量的区域。全局变量拥有全局作用域，在javaScript代码中任何地方都有定义的。然而在函数内声明的变量只是在函数内部有定义，他们是局部变量，作用域也只是在局部。 在函数体内，局部变量的优先级要高于全局变量。如果在函数体内重新声明一个与局部变量重名的变量，局部变量就会覆盖全局变量的值。来看个例子： 123456789101112var num="100";function scope()&#123; var num="10"; function innerScope()&#123; var num = "1"; console.log(scope);//输出：1 &#125; innerScope(); console.log(num);//输出：10&#125;scope();console.log(num);//输出：100 这个例子会打印三个数，分别是1，10，100；局部变量的作用域仅仅在函数内部，出了函数体之后，局部变量就会被销毁。在innerScope()函数中，虽然又声明了一个num，但是innerScope()中的num是局部变量，只是与全局变量的名字相同，并不是全局变量，所以，虽然在该函数中把num赋值为1，但这仅仅是一个与全局变量名称相同的一个变量而已，并没有改变全局变量的值。 再来看一个例子: 123456789101112var num="100";function scope()&#123; var num="10"; function innerScope()&#123; num = "1"; console.log(scope);//输出：1 &#125; innerScope(); console.log(num);//输出：1&#125;scope();console.log(num);//输出：100 上面这部分代码中，在innerScope()函数中，我们并没有用var来声明num，所以，在这里的num的作用域就被提升了，即我们将scope中的num的值重置了，所以在输出的时候输出的结果为嵌套作用域内的局部变量。 二、变量提升 在Javascript中，函数及变量的声明都将被提升到函数的最顶部。在js中，变量的声明会被解析器悄悄的提升到方法体的最顶部，但是需要注意的是，提升的仅仅是变量的声明，变量的赋值并不会被提升，我们需要注意的是，函数的声明与变量的声明是不一样的。函数的函数体也会被一起提升。函数表达式和变量表达式只是其声明被提升，函数声明是函数的声明和实现都被提升。 所以上面那个题就很好理解了。我们再来看一下这个题：123456789var a = 100;function test()&#123; console.log(a); a = 10; console.log(a); console.log(this.a); var a;&#125;test(); 因为变量提升，a提升到最前面，声明未赋值，所以第一个就会打印undefined； 第二个在a声明之后，而且a赋值为10，所以第二个打印出来10； 第三个，因为test()是在window下调用的；this指的是test()调用的作用域，所以第三个打印100； 看一个函数提升的例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;script language="javascript" type="text/javascript"&gt; //在全局对象中声明两个全局函数,反模式 function foo() &#123; alert("global foo"); &#125; function bar() &#123; alert("global bar"); &#125; //定义全局变量 var v = "global var"; function hoistMe() &#123; alert(typeof foo); //function alert(typeof bar); //undefined alert(v); //undefined //为什么bar函数和变量v是未定义而不是全局变量中定义的相应的函数变量呢？ //因为函数里面定义了同名的函数和变量，无论在函数的任何位置定义这些函数和 //和变量，它们都将被提升到函数的最顶部。 foo(); //local foo bar(); //报错，TypeError "bar is not a function" //函数声明，变量foo以及其实现被提升到hoistMe函数顶部 function foo() &#123; alert("local foo"); &#125; //函数表达式,仅变量bar被提升到函数顶部，实现没有被提升 var bar = function() &#123; alert("local bar"); &#125;; //定义局部变量 var v = "local"; &#125; (function() &#123; hoistMe(); &#125;)(); //函数表达式和变量表达式只是其声明被提升，函数声明是函数的声明和实现都被提升。 /**由于函数提升的效果，hoistMe方法相当于 function hoistMe() &#123; //函数声明，变量foo以及其实现被提升到hoistMe函数顶部 function foo() &#123; alert("local foo"); &#125; //函数表达式,仅变量bar被提升到函数顶部，实现没有被提升(同变量提升) var bar = undefined; //变量声明被提升 var v = undefined; alert(typeof foo); //function alert(typeof bar); //undefined alert(v); //undefined foo(); //local foo bar(); //报错，缺少对象 bar = function() &#123; alert("local bar"); &#125;; v = "local"; &#125; */ &lt;/script&gt;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 书单]]></title>
    <url>%2F2018%2F05%2F14%2F2018-%E4%B9%A6%E5%8D%95%2F</url>
    <content type="text"><![CDATA[☐ 《原则》瑞·达利欧 著 中信出版社✔ 《爆裂》伊藤穰一 杰夫·豪 著 中信出版社☐ 《基因传》悉达多•穆克吉 著 中信出版社☐ 《未来简史》尤瓦尔·赫拉利 著 中信出版社☐ 《人类简史》尤瓦尔·赫拉利 著 中信出版社✔ 《你的第一本哲学书》托马斯·内格尔 著 中信出版社☐ 《自私的基因》理查德·道金斯 著 中信出版社☐ 《不会被机器替代的人》杰夫·科尔文 著 中信出版社☐ 《好好说话》马薇薇、黄执中、周玄毅等 著 中信出版社☐ 《跃迁》古典 著 中信出版社☐ 《智能时代》吴军 著 中信出版社☐ 《细节：如何轻松影响他人》史蒂夫·马丁 诺瓦·戈尔茨坦 等 著 中信出版社☐ 《向前一步》谢丽尔·桑德伯✔ 《人人都是产品经理》☐ 《穷爸爸富爸爸》☐ 《中国经济2018》]]></content>
      <categories>
        <category>浮生小记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[redux-devtools学习理解]]></title>
    <url>%2F2018%2F05%2F11%2Fredux-devtools%E5%AD%A6%E4%B9%A0%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[redux-devtoolsA live-editing time travel environment for Redux.redux-devtools是一个有趣而又高效的redux开发工具，通过redux-devtools，我们可以清晰的看到当前 store 仓库中的 state 是怎么样的，在可视化工具的左边，我们还可以看到触发的action的变化。这样，使得我们开发过程中很方便地进行调试。 安装123npm install --save-dev redux-devtoolsnpm install --save-dev redux-devtools-log-monitornpm install --save-dev redux-devtools-dock-monitor 使用 通过createDevTools来创建DevTools组件 1234567891011121314151617import React from 'react'//从redux-devtools中引入createDevToolslet DevTools;if (process.env.NODE_ENV === 'development') &#123; const &#123;createDevTools&#125; = require('redux-devtools'); const LogMonitor = require('redux-devtools-log-monitor').default; const DockMonitor = require('redux-devtools-dock-monitor').default; DevTools = createDevTools( &lt;DockMonitor toggleVisibilityKey="ctrl-h" changePositionKey="ctrl-w" defaultIsVisible=&#123;false&#125; defaultPosition="right"&gt; &lt;LogMonitor theme="tomorrow" preserveScrollTop=&#123;false&#125;/&gt; &lt;/DockMonitor&gt; );&#125; 采用DevTools.instrument()通过redux的compose来扩展store 1234567891011121314151617181920212223export function configureStore(history, reducers, initialState) &#123; // Installs hooks that always keep react-router and redux store in sync const middleware = [thunk, routerMiddleware(history)]; if (process.env.NODE_ENV === 'development') &#123; //开发环境 const &#123;createLogger&#125; = require('redux-logger'); middleware.push(createLogger()); &#125; let devTools = []; if (DevTools &amp;&amp; typeof document !== 'undefined') &#123; devTools = [DevTools.instrument()] &#125; const store = createStore( reducers, initialState, compose( applyMiddleware(...middleware), ...devTools )); return store;&#125; 用createDevTools()创建的DevTools组件有个特殊的静态方法instrument(),它返回一个store的增强器,在开发中你需要在compose中使用。注意：DevTools.instrument()要放在applyMiddleware后，因为你的applyMiddleware可以存在异步行为，为了确保所有的actions显示在store中，所以要放在后面 Render &lt;DevTools /&gt; 1234567891011const store = configureStore();render( &lt;Provider store=&#123;store&#125;&gt; &lt;div&gt; &lt;Router /&gt; &lt;DevTools /&gt; &lt;/div&gt; &lt;/Provider&gt; document.getElementById('app'));]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux源码学习--applyMiddleware]]></title>
    <url>%2F2018%2F05%2F11%2Fredux%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-applyMiddleware%2F</url>
    <content type="text"><![CDATA[applyMiddleware理解 中间件的本质是作为enhancer而存在的。它是通过createStore方法传递到redux的内部中的,中间件模块是一个高阶函数下面是redux中间件的基本格式：1const reduxMiddleware = (&#123;dispatch, getState&#125;[简化的store]) =&gt; (next[上一个中间件的dispatch方法]) =&gt; (action[实际派发的action对象]) =&gt; &#123;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950export default function applyMiddleware(...middlewares) &#123; // middlewares就是我们传递给applyMiddlewarez函数的一系列中间件函数 return (createStore) =&gt; (...args) =&gt; &#123; // createStore就是redux用于创建store的方法,args === [reducers, preloadedState]。下面这句话就是在中间件的内部，使用我们传递的参数创建一个store对象 // 注：这一块没有传递enhancer,所以返回的就是我们经常使用的store对象 const store = createStore(...args) // 获取store对象的dispatch方法 let dispatch = () =&gt; &#123; throw new Error( `Dispatching while constructing your middleware is not allowed. ` + `Other middleware would not be applied to this dispatch.` ) &#125; // 传递给中间件的第一层的函数的参数， const middlewareAPI = &#123; getState: store.getState, // 重写了dispatch方法，其实就是store.dispatch(...args) dispatch: (...args) =&gt; dispatch(...args) &#125; /** * 着重给大家详细的解释一下这一块 * 假设我们给applyMiddleware函数传递的中间件是 * applyMiddleware( * f1 =&gt; g1 =&gt; h1(...arg) =&gt; &#123;&#125;, * f2 =&gt; g2 =&gt; h2(...arg) =&gt; &#123;&#125; * ) * 运行下面的这行代码之后，chain中保存的内容是 * chain = [g1 =&gt; h1(...arg) =&gt; &#123;&#125;, g2 =&gt; h2(...arg) =&gt; &#123;&#125;] */ const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)) /** * 当我们把chain传入到 compose中后，根据我们对compose的分析， * compose(...chain)(store.dispatch)的结果就是: * g1(h2(...arg)) =&gt; h1(...arg) * * 也就是说，按照上面的这个形式，下面的dispatch和h1函数是一样的，所以，h1的参数，就是我们需要派发的action，当我们调用dispatch的时候，其实就相当于调用h1(action)，而在h1的内部，这个action是由g1的参数 * 也就是h2进行派发的，所以这个时候action就传递到了h2的内部，而h2的参数是由g2的参数，也就是实际传入的store.dispatch进行派发的，就这样层层传入，层层输出，就形成了我们强大的中间件机制。 */ dispatch = compose(...chain)(store.dispatch) // 返回的也是一个store对象 return &#123; ...store, // 这个dispatch其实就是，各个中间件的最底层(第三层)的哪个函数组成的圆环函数构成的 dispatch &#125; &#125;&#125;]]></content>
      <categories>
        <category>redux源码学习</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>react</tag>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux源码学习--bindActionCreators]]></title>
    <url>%2F2018%2F05%2F11%2Fredux%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-bindActionCreators%2F</url>
    <content type="text"><![CDATA[bindActionCreators 以前这样触发一个action，即dispatch(actionCreator(args))，现在变成这样触发一个action: boundActionCreator(args)。目的很单纯，简化某个action的调用。 Redux中的bindActionCreators，是通过dispatch将action包裹起来，这样可以通过bindActionCreators创建的方法，直接调用dispatch(action)(隐式调用）。一般情况下，我们可以通过Provider将store通过React的connext属性向下传递，bindActionCreators的唯一用处就是需要传递action creater到子组件，并且改子组件并没有接收到父组件上传递的store和dispatch。 实现上面那个效果，仅需一行代码，也就是源码文件中的第一个函数：1234567// 返回一个函数fn：函数目的是将actionCreator绑定到dispatch上，不用麻烦调用dispatch(actionCreator(args))了// 返回一个函数fn，该函数fn用dispatch来调用，其参数是actionCreator执行结果，function bindActionCreator(actionCreator, dispatch) &#123; return function() &#123; return dispatch(actionCreator.apply(this, arguments)) &#125;&#125; 参数理解actionCreators: actionCreators是一个对象，它的值是actions creator函数。也可以传递一个函数。dispatch: 等同于store中的store.dispatch，用于组合action 返回值boundActionCreators: 返回一个boundActionCreators对象 1234567891011121314151617181920212223242526272829export default function bindActionCreators(actionCreators, dispatch) &#123; //如果actionCreators是一个函数，则说明只有一个actionCreator，那直接调用bindActionCreator就行了 if (typeof actionCreators === 'function') &#123; return bindActionCreator(actionCreators, dispatch) &#125; //如果是actionCreator是对象，或者是null的话，报错喽 if (typeof actionCreators !== 'object' || actionCreators === null) &#123; throw new Error( `bindActionCreators expected an object or a function, instead received $&#123;actionCreators === null ? 'null' : typeof actionCreators&#125;. ` + `Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?` ) &#125; //保持actionCreators里面原来的key，只是把key对应的value都转成了boundActionCreator const keys = Object.keys(actionCreators) const boundActionCreators = &#123;&#125; for (let i = 0; i &lt; keys.length; i++) &#123; const key = keys[i] const actionCreator = actionCreators[key] //只对value是函数的key进行转换，其他的都过滤掉了 if (typeof actionCreator === 'function') &#123; boundActionCreators[key] = bindActionCreator(actionCreator, dispatch) &#125; &#125; //返回绑定之后的对象 return boundActionCreators&#125; 总结 bindActionCreators函数把actionCreators这个对象里面包含的每一个actionCreator按照原来的key的方式全部都封装了一遍。]]></content>
      <categories>
        <category>redux源码学习</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>react</tag>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux源码学习--combineReducers]]></title>
    <url>%2F2018%2F05%2F11%2Fredux%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E2%80%94combineReducers%2F</url>
    <content type="text"><![CDATA[combineReducers 理解 combineReducers.js文件对外暴露了一个函数combineReducers，combineReducer函数是redux的一个辅助性的函数，用于拆分createStore里面的第一个参数：reducer函数。combineReducer函数的返回值是一个函数，该函数是组合之后的一个标准的reducer函数。combineReducers将多个值不同的reducer对象转换为单个reducer。它将调用每个子reducer，并将它们的结果收集到单个状态对象中，该对象的键对应于传递的reducer函数的键。 参数理解{reducers}：一个对象，它的值对应于需要被组合成一个的不同的reducer函数。获得它的一种简便方法是使用ES6import * as reducers语法。对于任何的actions，reducer可能永远不会返回undefined。相反，如果传递给它们的state是undefined，则返回初始state，以及任何未识别action的当前state。1234let reducers = &#123; usersId: function getUsersIdReducer()&#123;&#125;, userName: function getUserNameReducer()&#123;&#125;&#125; 参数处理 从传入的参数里面提取出合法的reducers（reducers的每一个key对应的value值是函数，才是合法的子reducer），赋值给新的局部变量：finalReducers 12345678910111213141516const reducerKeys = Object.keys(reducers)//定义一个局部变量 finalReducersconst finalReducers = &#123;&#125;for (let i = 0; i &lt; reducerKeys.length; i++) &#123; const key = reducerKeys[i] if (process.env.NODE_ENV !== 'production') &#123; if (typeof reducers[key] === 'undefined') &#123; warning(`No reducer provided for key "$&#123;key&#125;"`) &#125; &#125; //过滤出reducers对应的value值是function的key，将其放入finalReducers对象 if (typeof reducers[key] === 'function') &#123; finalReducers[key] = reducers[key] &#125;&#125; 校验finalReducers, 判断其每一个子reducer是否能返回正常的子state 1234567891011121314//取出过滤出来的有效的keys列表const finalReducerKeys = Object.keys(finalReducers)let unexpectedKeyCacheif (process.env.NODE_ENV !== 'production') &#123; unexpectedKeyCache = &#123;&#125;&#125;let shapeAssertionErrortry &#123; assertReducerShape(finalReducers)&#125; catch (e) &#123; shapeAssertionError = e&#125; 调用assertReducerShape函数： 123456789101112131415161718192021222324252627282930313233343536//确认reducer是否是合法的reducer，即返回的state是不是undefined，如果是undefined，则是非法reducerfunction assertReducerShape(reducers) &#123; Object.keys(reducers).forEach(key =&gt; &#123; const reducer = reducers[key] const initialState = reducer(undefined, &#123;type: ActionTypes.INIT&#125;) //如果初始state是undefined，则抛出错误 if (typeof initialState === 'undefined') &#123; throw new Error( `Reducer "$&#123;key&#125;" returned undefined during initialization. ` + `If the state passed to the reducer is undefined, you must ` + `explicitly return the initial state. The initial state may ` + `not be undefined. If you don't want to set a value for this reducer, ` + `you can use null instead of undefined.` ) &#125; //如果reducer是undefined，抛出错误 if ( typeof reducer(undefined, &#123; type: ActionTypes.PROBE_UNKNOWN_ACTION() &#125;) === 'undefined' ) &#123; throw new Error( `Reducer "$&#123;key&#125;" returned undefined when probed with a random type. ` + `Don't try to handle $&#123; ActionTypes.INIT &#125; or other actions in "redux/*" ` + `namespace. They are considered private. Instead, you must return the ` + `current state for any unknown actions, unless it is undefined, ` + `in which case you must return the initial state, regardless of the ` + `action type. The initial state may not be undefined, but can be null.` ) &#125; &#125;)&#125; 返回值combineReducers函数返回一个combination函数，combination是一个标准的reducer函数，有初始化的state参数，和一个携带了actionType和数据的action对象。12345678910111213141516171819202122232425262728293031323334353637383940return function combination(state = &#123;&#125;, action) &#123; //如果有非法的reducer，就直接报错 if (shapeAssertionError) &#123; throw shapeAssertionError &#125; if (process.env.NODE_ENV !== 'production') &#123; const warningMessage = getUnexpectedStateShapeWarningMessage( state, finalReducers, action, unexpectedKeyCache ) if (warningMessage) &#123; warning(warningMessage) &#125; &#125; let hasChanged = false //定义新的nextState const nextState = &#123;&#125; // 1，遍历reducers对象中的有效key， // 2，执行该key对应的value函数，即子reducer函数，并得到对应的state对象，即子state // 3，将新的子state挂到新的nextState对象上，key不变 for (let i = 0; i &lt; finalReducerKeys.length; i++) &#123; const key = finalReducerKeys[i] const reducer = finalReducers[key] const previousStateForKey = state[key] const nextStateForKey = reducer(previousStateForKey, action) if (typeof nextStateForKey === 'undefined') &#123; const errorMessage = getUndefinedStateErrorMessage(key, action) throw new Error(errorMessage) &#125; nextState[key] = nextStateForKey //如果hasChanged为true，那就是true了 后面的判断是，只要有一次nextStateForKey!== previousStateForKey不同，就说明整个state不同 hasChanged = hasChanged || nextStateForKey !== previousStateForKey &#125; //如果state发生变化了，直接返回新的nextState，否则，还是返回旧的state return hasChanged ? nextState : state&#125; 总结 combineReducers 辅助函数的作用是，把一个由多个不同 reducer 函数作为 value 的 object，合并成一个最终的 reducer 函数，然后就可以对这个 reducer 调用 createStore。 合并后的 reducer 可以调用各个子 reducer，并把它们的结果合并成一个 state 对象。state 对象的结构由传入的多个 reducer 的 key 决定。 每个传入 combineReducers 的 reducer 都需满足以下规则： 所有未匹配到的 action，必须把它接收到的第一个参数也就是那个 state 原封不动返回。 永远不能返回 undefined。当过早 return 时非常容易犯这个错误，为了避免错误扩散，遇到这种情况时 combineReducers 会抛异常。 如果传入的 state 就是 undefined，一定要返回对应 reducer 的初始 state。根据上一条规则，初始 state 禁止使用 undefined。使用 ES6 的默认参数值语法来设置初始 state 很容易，但你也可以手动检查第一个参数是否为 undefined。]]></content>
      <categories>
        <category>redux源码学习</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>react</tag>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux源码学习--compose]]></title>
    <url>%2F2018%2F05%2F11%2Fredux%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-compose%2F</url>
    <content type="text"><![CDATA[composecompose 是一个从右向左编写单参数组成的函数。最右边的函数可以接受多个参数，因为它提供了签名由此产生的复合函数。 参数理解{...funcs}需要合成的多个函数。每个函数都接收一个函数作为参数，然后返回一个函数。 返回值(Function) 从右到左把接收到的函数合成后的最终函数。 代码理解1234567891011export default function compose(...funcs) &#123; if (funcs.length === 0) &#123; return arg =&gt; arg &#125; if (funcs.length === 1) &#123; return funcs[0] &#125; //对参数进行一个累加，就是依次以右边的参数作为左边方法的参数累加到最左边 return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))&#125; 总结compose 主要用于 applyMiddleware / createStore enhancer.compose 做的只是让你不使用深度右括号的情况下来写深度嵌套的函数compose的运行结果是一个函数，调用这个函数所传递的参数将会作为compose最后一个参数的参数，从而由内向外，逐步调用。]]></content>
      <categories>
        <category>redux源码学习</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>react</tag>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[immutable.js 学习]]></title>
    <url>%2F2018%2F05%2F11%2Fimmutable-js-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[JavaScript 中的对象一般是可变的，因为Javascript为了节省内存，都是使用引用赋值，生成一个新对象如果简单的引用了原始对象，那对新对象作出的改变，也将影响到原始对象。平时简单的应用还不会特别明显，但是如果在复杂的应用中，对象的改变就会引起比较复杂的问题。往往都会使用deepCopy来解决这个问题，但是deepCopy往往会对整个对象的树进行拷贝，也会造成 CPU 和内存的浪费。一、什么是immutable data？Immutable Data 就是被创建之后不能给改变数据。Immutable 实现的原理是 Persistent Data Structure（持久化数据结构），新数据通过旧的数据创建，需要使旧数据依旧可用而且不能被改变。Immutable的这种实现原理，也避免了deepCopy复制所有节点带来的性能损耗。Immutable的实现原理见下图： 二、Immutable 优点 Immutable 降低了 Mutable 带来的复杂度 节省内存 Undo/Redo，Copy/Paste，甚至时间旅行这些功能做起来小菜一碟 并发安全 拥抱函数式编程 三、Immutable 缺点： 需要学习新的 API 增加了资源文件大小 容易与原生对象混淆 四、Immutable的数据类型Immutable 的几种数据类型1.List: 有序索引集，类似JavaScript中的Array。2.Map: 无序索引集，类似JavaScript中的Object。3.OrderedMap: 有序的Map，根据数据的set()进行排序。4.Set: 没有重复值的集合。5.OrderedSet: 有序的Set，根据数据的add进行排序。6.Stack: 有序集合，支持使用unshift（）和shift（）添加和删除。7.Range(): 返回一个Seq.Indexed类型的集合，这个方法有三个参数，start表示开始值，默认值为0，end表示结束值，默认为无穷大，step代表每次增大的数值，默认为1.如果start = end,则返回空集合。8.Repeat(): 返回一个vSeq.Indexe类型的集合，这个方法有两个参数，value代表需要重复的值，times代表要重复的次数，默认为无穷大。9.Record: 一个用于生成Record实例的类。类似于JavaScript的Object，但是只接收特定字符串为key，具有默认值。10.Seq: 序列，但是可能不能由具体的数据结构支持。11.Collection: 是构建所有数据结构的基类，不可以直接构建。 用的最多就是List和Map，所以在这里主要介绍这两种数据类型的API。 五、常用的API1.fromJS() 将一个js数据转换为Immutable类型的数据。用法：fromJS(value, converter)简介：value是要转变的数据，converter是要做的操作。第二个参数可不填，默认情况会将数组准换为List类型，将对象转换为Map类型，其余不做操作。 1234const obj = Immutable.fromJS(&#123;a:'123',b:'234'&#125;,function (key, value, path) &#123; console.log(key, value, path) return isIndexed(value) ? value.toList() : value.toOrderedMap())&#125;) 2.toJS()作用：将一个Immutable数据转换为JS类型的数据。用法：value.toJS() 3.is()对两个对象进行比较。用法：is(map1,map2)简介：和js中对象的比较不同，在js中比较两个对象比较的是地址，但是在Immutable中比较的是这个对象hashCode和valueOf，只要两个对象的hashCode相等，值就是相同的，避免了深度遍历，提高了性能。 123456import &#123; Map, is &#125; from 'immutable'const map1 = Map(&#123; a: 1, b: 1, c: 1 &#125;)const map2 = Map(&#123; a: 1, b: 1, c: 1 &#125;)map1 === map2 //falseObject.is(map1, map2) // falseis(map1, map2) // true 4.List 和 Map创建List() 和 Map() 作用：用来创建一个新的List/Map对象 用法: 12345678910//ListList(): List&lt;any&gt;List&lt;T&gt;(): List&lt;T&gt;//MapMap(): Map&lt;any&gt;Map&lt;T&gt;(): Map&lt;T&gt;List.of() 和 Map.of() 作用：创建一个新的包含value的List/Map对象用法：123List.of&lt;T&gt;(...values: Array&lt;T&gt;): List&lt;T&gt;Map.of&lt;T&gt;(...values: Object&lt;T&gt;): Map&lt;T&gt; 判断 1List.isList() 和 Map.isMap() 作用：判断一个数据结构是不是List/Map类型用法：123List.isList(maybeList: any): booleanMap.isMap(maybeMap: any): boolean 长度size 作用：获取List/Map的长度 数据读取get() 、 getIn() 作用：获取数据结构中的数据 has() 、 hasIn() 作用:判断是否存在某一个key 用法：1234Immutable.fromJS([1,2,3,&#123;a:4,b:5&#125;]).has('0'); //trueImmutable.fromJS([1,2,3,&#123;a:4,b:5&#125;]).has('0'); //trueImmutable.fromJS([1,2,3,&#123;a:4,b:5&#125;]).hasIn([3,'b']) //trueincludes() 作用：判断是否存在某一个value 用法： 123456Immutable.fromJS([1,2,3,&#123;a:4,b:5&#125;]).includes(2); //trueImmutable.fromJS([1,2,3,&#123;a:4,b:5&#125;]).includes('2'); //false 不包含字符2Immutable.fromJS([1,2,3,&#123;a:4,b:5&#125;]).includes(5); //false Immutable.fromJS([1,2,3,&#123;a:4,b:5&#125;]).includes(&#123;a:4,b:5&#125;) //falseImmutable.fromJS([1,2,3,&#123;a:4,b:5&#125;]).includes(Immutable.fromJS(&#123;a:4,b:5&#125;)) //truefirst() 、 last() 作用：用来获取第一个元素或者最后一个元素，若没有则返回undefined代码： 12345Immutable.fromJS([1,2,3,&#123;a:4,b:5&#125;]).first()//1Immutable.fromJS([1,2,3,&#123;a:4,b:5&#125;]).last()//&#123;a:4,b:5&#125;Immutable.fromJS(&#123;a:1,b:2,c:&#123;d:3,e:4&#125;&#125;).first() //1Immutable.fromJS(&#123;a:1,b:2,c:&#123;d:3,e:4&#125;&#125;).first() //&#123;d:3,e:4&#125; 数据修改注：这里对于数据的修改，是对原数据进行操作后的值赋值给一个新的数据，并不会对原数据进行修改，因为Immutable是不可变的数据类型。 设置 set() 作用：设置第一层key、index的值 用法： 123set(index: number, value: T): List&lt;T&gt;set(key: K, value: V): thisList在使用的时候，将index为number值设置为value。Map在使用的时候，将key的值设置为value。 在List中使用时，若传入的number为负数，则将index为size+index的值设置为value，例，若传入-1，则将size-1的值设为value。若传入的number的值超过了List的长度，则将List自动补全为传入的number的值，将number设置为value，其余用undefined补全。注：跟js中不同，List中不存在空位，[,,,],List中若没有值，则为undefined。 代码实现：12345678910111213141516171819202122232425//////Listconst originalList = List([ 0 ]);// List [ 0 ]originalList.set(1, 1);// List [ 0, 1 ]originalList.set(0, 'overwritten');// List [ "overwritten" ]originalList.set(2, 2);// List [ 0, undefined, 2 ]List().set(50000, 'value').size;// 50001//////Mapconst &#123; Map &#125; = require('immutable')const originalMap = Map()const newerMap = originalMap.set('key', 'value')const newestMap = newerMap.set('key', 'newer value')originalMap// Map &#123;&#125;newerMap// Map &#123; "key": "value" &#125;newestMap// Map &#123; "key": "newer value" &#125; setIn()作用：设置深层结构中某属性的值用法：12setIn(keyPath: Iterable&lt;any&gt;, value: any): this用法与set()一样，只是第一个参数是一个数组，代表要设置的属性所在的位置 删除 delete 作用：用来删除第一层结构中的属性 用法：123delete(index: number): List&lt;T&gt; //Listdelete(key: K): this //MapdeleteIn() 用来删除深层数据，用法参考setIndeleteAll() (Map独有，List没有)作用：用来删除Map中的多个key用法：1deleteAll(keys: Iterable&lt;K&gt;): this 代码示例：123const names = Map(&#123; a: "Aaron", b: "Barry", c: "Connor" &#125;)names.deleteAll([ 'a', 'c' ])// Map &#123; "b": "Barry" &#125; 更新 update()作用：对对象中的某个属性进行更新，可对原数据进行相关操作用法：12update(index: number, updater: (value: T) =&gt; T): this //Listupdate(key: K, updater: (value: V) =&gt; V): this //Map 代码示例：12345678////Listconst list = List([ 'a', 'b', 'c' ])const result = list.update(2, val =&gt; val.toUpperCase())///Mapconst aMap = Map(&#123; key: 'value' &#125;)const newMap = aMap.update('key', value =&gt; value + value)updateIn() 用法参考setIn 清除 clear() 作用：清除所有数据 用法：clear(): this 代码示例：12Map(&#123; key: 'value' &#125;).clear() //MapList([ 1, 2, 3, 4 ]).clear() // List List中的各种删除与插入List对应的数据结构是js中的数组，所以数组的一些方法在Immutable中也是通用的，比如push，pop,shift，unshift，insert。 push()：在List末尾插入一个元素pop(): 在List末尾删除一个元素unshift: 在List首部插入一个元素shift: 在List首部删除一个元素insert：在List的index处插入元素代码实现：123456789101112List([ 0, 1, 2, 3, 4 ]).insert(6, 5) //List [ 0, 1, 2, 3, 4, 5 ]List([ 1, 2, 3, 4 ]).push(5)// List [ 1, 2, 3, 4, 5 ]List([ 1, 2, 3, 4 ]).pop()// List[ 1, 2, 3 ]List([ 2, 3, 4]).unshift(1);// List [ 1, 2, 3, 4 ]List([ 0, 1, 2, 3, 4 ]).shift();// List [ 1, 2, 3, 4 ]List中还有一个特有的方法用法设置List的长度，setSize()List([]).setSize(2).toJS() //[undefined,undefined] 关于mergemerge 作用：浅合并，新数据与旧数据对比，旧数据中不存在的属性直接添加，就数据中已存在的属性用新数据中的覆盖 mergrWith 作用：自定义浅合并，可自行设置某些属性的值 mergeIn 作用：对深层数据进行浅合并 mergeDeep 作用：深合并，新旧数据中同时存在的的属性为新旧数据合并之后的数据 mergeDeepIn 作用：对深层数据进行深合并 mergrDeepWith 作用:自定义深合并，可自行设置某些属性的值这里用一段示例彻底搞懂merge，此示例为Map结构，List与Map原理相同123456789101112131415const Map1 = Immutable.fromJS(&#123;a:111,b:222,c:&#123;d:333,e:444&#125;&#125;);const Map2 = Immutable.fromJS(&#123;a:111,b:222,c:&#123;e:444,f:555&#125;&#125;);const Map3 = Map1.merge(Map2); //Map &#123;a:111,b:222,c:&#123;e:444,f:555&#125;&#125;const Map4 = Map1.mergeDeep(Map2); //Map &#123;a:111,b:222,c:&#123;d:333,e:444,f:555&#125;&#125;const Map5 = Map1.mergeWith((oldData,newData,key)=&gt;&#123; if(key === 'a')&#123; return 666; &#125;else&#123; return newData &#125; &#125;,Map2); //Map &#123;a:666,b:222,c:&#123;e:444,f:555&#125;&#125; 序列算法concat()作用：对象的拼接，用法与js数组中的concat()相同，返回一个新的对象。用法：1const List = list1.concat(list2) map()作用：遍历整个对象，对Map/List元素进行操作，返回一个新的对象。用法：12Map(&#123;a:1,b:2&#125;).map(val=&gt;10*val)//Map&#123;a:10,b:20&#125; Map特有的mapKey()作用：遍历整个对象，对Map元素的key进行操作，返回一个新的对象。用法：12Map(&#123;a:1,b:2&#125;).mapKey(val=&gt;val+'l')//Map&#123;al:10,bl:20&#125; Map特有的mapEntries() 作用：遍历整个对象，对Map元素的key和value同时进行操作，返回一个新的对象。Map的map()也可实现此功能。用法：1234Map(&#123;a:1,b:2&#125;).map((key,val)=&gt;&#123; return [key+'l',val*10]&#125;)//Map&#123;al:10,bl:20&#125; 过滤 filter作用：返回一个新的对象，包括所有满足过滤条件的元素用法：1234Map(&#123;a:1,b:2&#125;).filter((key,val)=&gt;&#123; return val == 2&#125;)//Map&#123;b:2&#125; 还有一个filterNot()方法，与此方法正好相反。反转 reverse作用：将数据的结构进行反转代码示例：1234Immutable.fromJS([1, 2, 3, 4, 5]).reverse();// List [5,4,3,2,1]Immutable.fromJS(&#123;a:1,b:&#123;c:2,d:3&#125;,e:4&#125;).recerse();//Map &#123;e:4,b:&#123;c:2,d:3&#125;,a:1&#125; 排序 sort &amp; sortBy作用：对数据结构进行排序代码示例：1234567891011121314151617181920212223242526272829303132///ListImmutable.fromJS([4,3,5,2,6,1]).sort()// List [1,2,3,4,5,6]Immutable.fromJS([4,3,5,2,6,1]).sort((a,b)=&gt;&#123; if (a &lt; b) &#123; return -1; &#125; if (a &gt; b) &#123; return 1; &#125; if (a === b) &#123; return 0; &#125;&#125;)// List [1,2,3,4,5,6]Immutable.fromJS([&#123;a:3&#125;,&#123;a:2&#125;,&#123;a:4&#125;,&#123;a:1&#125;]).sortBy((val,index,obj)=&gt;&#123; return val.get('a')&#125;,(a,b)=&gt;&#123; if (a &lt; b) &#123; return -1; &#125; if (a &gt; b) &#123; return 1; &#125; if (a === b) &#123; return 0; &#125;&#125;)//List [ &#123;a:3&#125;, &#123;a:2&#125;, &#123;a:4&#125;, &#123;a:1&#125; ]//MapImmutable.fromJS( &#123;b:1, a: 3, c: 2, d:5&#125; ).sort()//Map &#123;b: 1, c: 2, a: 3, d: 5&#125;Immutable.fromJS( &#123;b:1, a: 3, c: 2, d:5&#125; ).sort((a,b)=&gt;&#123; if (a &lt; b) &#123; return -1; &#125; if (a &gt; b) &#123; return 1; &#125; if (a === b) &#123; return 0; &#125;&#125;)//Map &#123;b: 1, c: 2, a: 3, d: 5&#125;Immutable.fromJS( &#123;b:1, a: 3, c: 2, d:5&#125; ).sortBy((value, key, obj)=&gt; &#123; return value&#125;)//Map &#123;b: 1, c: 2, a: 3, d: 5&#125; 分组 groupBy作用：对数据进行分组12345678910111213const listOfMaps = List([ Map(&#123; v: 0 &#125;), Map(&#123; v: 1 &#125;), Map(&#123; v: 1 &#125;), Map(&#123; v: 0 &#125;), Map(&#123; v: 2 &#125;)])const groupsOfMaps = listOfMaps.groupBy(x =&gt; x.get('v'))// Map &#123;// 0: List [ Map&#123; "v": 0 &#125;, Map &#123; "v": 0 &#125; ],// 1: List [ Map&#123; "v": 1 &#125;, Map &#123; "v": 1 &#125; ],// 2: List [ Map&#123; "v": 2 &#125; ],// &#125; 查找数据indexOf() 、 lastIndexOf Map不存在此方法作用：和js数组中的方法相同，查找第一个或者最后一个value的index值，找不到则返回-1用法：12Immutable.fromJS([1,2,3,4]).indexof(3) //2Immutable.fromJS([1,2,3,4]).lastIndexof(3) //2 findIndex() 、 findLastIndex() Map不存在此方法作用：查找满足要求的元素的index值用法：123456Immutable.fromJS([1,2,3,4]).findIndex((value,index,array)=&gt;&#123; return value%2 === 0;&#125;) // 1Immutable.fromJS([1,2,3,4]).findLastIndex((value,index,array)=&gt;&#123; return index%2 === 0;&#125;) // 3 find() 、 findLast()作用：查找满足条件的元素的value值用法：1234567Immutable.fromJS([1,2,3,4]).find((value,index,array)=&gt;&#123; return value%2 === 0;&#125;) // 2Immutable.fromJS([1,2,3,4]).findLast((value,index,array)=&gt;&#123; return value%2 === 0;&#125;) // 4 findKey() 、 findLastKey()作用：查找满足条件的元素的key值用法：1234567Immutable.fromJS([1,2,3,4]).findKey((value,index,array)=&gt;&#123; return value%2 === 0;&#125;) // 1Immutable.fromJS([1,2,3,4]).findLastKey((value,index,array)=&gt;&#123; return value%2 === 0;&#125;) // 3 findEntry() 、 findLastEntry()作用：查找满足条件的元素的键值对 key:value用法：1234567Immutable.fromJS([1,2,3,4]).findEntry((value,index,array)=&gt;&#123; return value%2 === 0;&#125;) // [1,2]Immutable.fromJS([1,2,3,4]).findLastEntry((value,index,array)=&gt;&#123; return value%2 === 0;&#125;) // [3,4] keyOf() lastKeyOf()作用：查找某一个value对应的key值用法：12Immutable.fromJS([1,2,3,4]).keyOf(2) //1Immutable.fromJS([1,2,3,4]).lastKeyOf(2) //1 max() 、 maxBy()作用：查找最大值用法:12345Immutable.fromJS([1, 2, 3, 4]).max() //4Immutable.fromJS([&#123;a;1&#125;,&#123;a:2&#125;,&#123;a: 3&#125;,&#123;a:4&#125;]).maxBy((value,index,array)=&gt;&#123; return value.get('a')&#125;) //&#123;a:4&#125; min() 、 minBy() 作用：查找最小值用法:12345Immutable.fromJS([1, 2, 3, 4]).min() //1Immutable.fromJS([&#123;a;1&#125;,&#123;a:2&#125;,&#123;a: 3&#125;,&#123;a:4&#125;]).minBy((value,index,array)=&gt;&#123; return value.get('a')&#125;) //&#123;a:1&#125; 创建子集slice() 作用： 和原生js中数组的slice数组一样，包含两个参数，start和end，start代表开始截取的位置，end代表结束的位置，不包括第end的元素。若不包括end，则返回整个对象，若end为负数，则返回（start，length-end）对应的数据。若start只有一个并且为负数，则返回最后的end个元素。 用法： 1234Immutable.fromJS([1, 2, 3, 4]).slice(0); //[1,2,3,4]Immutable.fromJS([1, 2, 3, 4]).slice(0,2); //[1,2]Immutable.fromJS([1, 2, 3, 4]).slice(-2); //[3,4]Immutable.fromJS([1, 2, 3, 4]).slice(0,-2); //[1,2] rest()作用：返回除第一个元素之外的所有元素用法:1Immutable.fromJS([1, 2, 3, 4]).rest()//[2,3,4] butLast()作用：返回除最后一个元素之外的所有元素用法:1Immutable.fromJS([1, 2, 3, 4]).rest()//[1,2,3] skip()作用：有一个参数n, 返回截掉前n个元素之后剩下的所有元素用法:1Immutable.fromJS([1, 2, 3, 4]).skip(1)//[2,3,4] skipLast() 作用：有一个参数n, 返回截掉最后n个元素之后剩下的所有元素 用法: 1Immutable.fromJS([1, 2, 3, 4]).skip(1)//[1,2,3] skipWhile() 作用：返回从第一次返回false之后的所有元素 123Immutable.fromJS([1, 2, 3, 4]).skipWhile(list.skipWhile((value,index,list)=&gt;&#123; return value &gt; 2;&#125;))// [1,2,3,4] skipUntil() 作用：返回从第一次返回true之后的所有元素 123Immutable.fromJS([1, 2, 3, 4]).skipUntil(list.skipWhile((value,index,list)=&gt;&#123; return value &gt; 2;&#125;))// [3,4] take() 作用：有一个参数n, 返回前n个元素 用法:Immutable.fromJS([1, 2, 3, 4]).take(2)//[1,2] takeLast() 作用：有一个参数n, 返回最后n个元素 用法:1Immutable.fromJS([1, 2, 3, 4]).takeLast(2)//[3,4] takeWhile() 作用：返回从第一次返回false之前的所有元素 123Immutable.fromJS([1, 2, 3, 4]).skipWhile(list.takeWhile((value,index,list)=&gt;&#123; return value &gt; 2;&#125;))// [] takeUntil() 作用：返回从第一次返回true之前的所有元素 123Immutable.fromJS([1, 2, 3, 4]).skipUntil(list.takeUntil((value,index,list)=&gt;&#123; return value &gt; 2;&#125;))// [1,2] 处理数据reduce() 作用：和js中数组中的reduce相同,按索引升序的顺序处理元素 用法： 12345Immutable.fromJS([1,2,3,4]).reduce((pre,next,index,arr)=&gt;&#123; console.log(pre+next) return pre+next; &#125;)// 3 6 10 reduceRight() 作用：和js中数组中的reduce相同,按索引降序的顺序处理元素 用法： 12345Immutable.fromJS([1,2,3,4]).reduceRight((pre,next,index,arr)=&gt;&#123; console.log(pre+next) return pre+next; &#125;)// 7 9 10 every() 作用：判断整个对象总中所有的元素是不是都满足某一个条件，都满足返回true，反之返回false。 代码： 123Immutable.fromJS([1,2,3,4]).every((value,index,arr)=&gt;&#123; return value &gt; 2&#125;) // false some() 作用：判断整个对象总中所有的元素是不是存在满足某一个条件的元素，若存在返回true，反之返回false。 代码： 123Immutable.fromJS([1,2,3,4]).some((value,index,arr)=&gt;&#123; return value &gt; 2&#125;) // true join() 作用：同js中数组的join方法。把准换为字符串 用法：Immutable.fromJS([1,2,3,4]).join(‘,’) //1,2,3,4 isEmpty() 作用：判断是否为空 用法: 12Immutable.fromJS([]).isEmpty(); // trueImmutable.fromJS(&#123;&#125;).isEmpty(); // true count() 作用：返回元素个数，可自定义条件，返回满足条件的个数 用法： 12345678910const list = Immutable.fromJS([1,2,3,4]);const map = Immutable.fromJS(&#123;a:1,b:2,c:3,d:4&#125;);list.count((value,index,list)=&gt;&#123; return value &gt; 2;&#125;) //2map.count((value,index,list)=&gt;&#123; return value &gt; 2;&#125;) //2 countBy() 作用：与count不同的是，countBy返回一个对象 用法： 12345678const list = Immutable.fromJS([1,2,3,4]);const map = Immutable.fromJS(&#123;a:1,b:2,c:3,d:4&#125;);list.countBy((value,index,list)=&gt;&#123; return value &gt; 2;&#125; //&#123;false: 2, true: 2&#125;map.countBy((value,index,list)=&gt;&#123; return value &gt; 2;&#125; //&#123;false: 2, true: 2&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>immutable</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux 源码学习——createStore]]></title>
    <url>%2F2018%2F05%2F11%2Fredux-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E2%80%94createStore%2F</url>
    <content type="text"><![CDATA[createStore 理解 创建一个保存state树的Redux store，store，可以让你阅读state，发送actions，并订阅更改。改变store数据的唯一方法是调用dispatch（）方法。应用中只能有一个store，指定state树的不同部分如何响应actions，可以通过使用combineReducers方法来组合多个reducer，将其转换为单个reducer。 返回值createStore.js是redux的核心文件，对外暴露了一个createStore函数，函数执行后返回一个对象，这个对象包括四个方法，分别是dispatch, subscribe, getState, replaceReducer。这些方法都redux中store的关键方法，后面将慢慢的展开理解。12345678910export default function createStore(reducer, preloadedState, enhancer) &#123; //other codes return &#123; dispatch, subscribe, getState, replaceReducer, [$$observable]: observable &#125;&#125; createStore 的参数理解createStore有三个参数：reducer, preloadedState, enhancer。 reducer：reducer是一个函数，通过给定当前state树和要处理的actions，返回下一个state树。 preloadedState：初始state，初始状态。您可以选择指定它从应用程序的服务器中来融合state，或者还原先前序列化的用户会话。如果使用combineReducers来生成根reducer函数，则必须是一个与“combineReducers”键相同的对象。 enhancer：store增强器。您可以选择指定它通过第三方功能增强store，如中间件，时间旅行，持久化等。Redux附带的唯一store增强器是applyMiddleware（）方法。这个参数特别有意思，如果该enhancer参数存在的话，会将当前的createStore函数作为参数传入enhancer函数，并且，enhancer执行之后得到一个新函数，该新函数其实就是一个加强版的createStore函数，新的函数会把之前的reducer和preloadeState作为参数传入并执行。这个enhancer参数为redux中间件提供了入口。 参数检查及异常处理12345678910111213141516171819//如果没有传preloadedState参数，但是enhancer参数传了，把两者交换一下if (typeof preloadedState === 'function' &amp;&amp; typeof enhancer === 'undefined') &#123; enhancer = preloadedState preloadedState = undefined &#125;//如果enhancer传了，但是不是函数，就抛出错误，否则执行enhancer函数，//并继续执行enhancer函数返回的加强版的createStore函数，//参数reducer以及preloadeState和原createStore函数保持一致if (typeof enhancer !== 'undefined') &#123; if (typeof enhancer !== 'function') &#123; throw new Error('Expected the enhancer to be a function.') &#125; return enhancer(createStore)(reducer, preloadedState) &#125;//如果reducer不是函数，则抛出错误if (typeof reducer !== 'function') &#123; throw new Error('Expected the reducer to be a function.')&#125; 定义局部变量12345let currentReducer = reducer //保存了当前的reducer函数，该reducer函数可以被动态替换掉let currentState = preloadedState //保存了当前的state数据let currentListeners = [] //保存了当前注册的函数列表let nextListeners = currentListenerslet isDispatching = false //是否正在dispatch一个action 定义返回store的方法1234567//确保nextListeners和currentListeners不是同一个引用function ensureCanMutateNextListeners() &#123; if (nextListeners === currentListeners) &#123; //如果是同一个引用，则浅拷贝currentListeners到nextListeners nextListeners = currentListeners.slice() &#125;&#125; 1234//getState函数，返回局部变量currentState，以获取当前状态function getState() &#123; return currentState&#125; 123456789101112131415161718192021222324252627//注册一个函数，将注册函数放入局部变量nextListeners数组里面//注册函数的返回值是一个注销函数，注销函数执行可以将刚刚添加进nextListeners的listener函数又删除掉。这里很有意思，外部必须在调用subscribe执行现场保存好unsubscribe函数，否则将无法注销一个函数function subscribe(listener) &#123; //如果listener不是函数，直接报错 if (typeof listener !== 'function') &#123; throw new Error('Expected listener to be a function.') &#125; let isSubscribed = true //确保nextListeners不是currentListeners，以保证修改的是nextListeners，而不是currentListeners ensureCanMutateNextListeners() //将监听函数放入监听函数列表尾部 nextListeners.push(listener) //返回一个函数，该函数可以从监听函数列表中删除刚刚注册的监听函数 return function unsubscribe() &#123; if (!isSubscribed) &#123; return &#125; isSubscribed = false ensureCanMutateNextListeners() const index = nextListeners.indexOf(listener) nextListeners.splice(index, 1) &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142//触发action的函数：每次触发一个action，currentListeners中的所有函数都要执行一遍function dispatch(action) &#123; //如果action不是普通的对象，直接报错 if (!isPlainObject(action)) &#123; throw new Error( 'Actions must be plain objects. ' + 'Use custom middleware for async actions.' ) &#125; //如果action没有type属性，直接报错：说明action对象必须要包含type字段 if (typeof action.type === 'undefined') &#123; throw new Error( 'Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?' ) &#125; //如果当前正在触发另外一个action，直接报错 if (isDispatching) &#123; throw new Error('Reducers may not dispatch actions.') &#125; try &#123; //先将标志位置为true isDispatching = true //执行传入的reducer函数，该函数返回一个新的state对象，并赋值给currentState变量 currentState = currentReducer(currentState, action) &#125; finally &#123; //reducer函数执行完成后，将isDispatching恢复成false，方便下次action的触发 isDispatching = false &#125; //每一次触发一个action，所有的监听函数都要全部重新执行一遍， //并且把上次得到的新的监听函数列表赋值成为当前的监听函数列表。这是一个懒操作，并不是在subscribe的时候就操作了，而是在dispatch的时候才操作 const listeners = currentListeners = nextListeners for (let i = 0; i &lt; listeners.length; i++) &#123; const listener = listeners[i] listener() &#125; //该dispatch函数的返回值是原来的action return action&#125; 12345678910111213//替换reducer函数：这个函数允许运行时动态替换最开始调用createStore函数时传入的reducer，并且替换掉reducer之后，重新dispatch一个action，得到全新的currentState对象function replaceReducer(nextReducer) &#123; //如果nextReducer不是函数，直接报错 if (typeof nextReducer !== 'function') &#123; throw new Error('Expected the nextReducer to be a function.') &#125; //把新的reducer赋值给当前的currentReducer变量，得到一个全新的currentReducer currentReducer = nextReducer // 触发一个初始action： // 1.这样就可以完成一次监听函数列表的全部调用 // 2.可以得到一个全新的currentState； dispatch(&#123;type: ActionTypes.INIT&#125;)&#125; 1234567891011121314151617181920212223242526272829303132function observable() &#123; const outerSubscribe = subscribe return &#123; /** * The minimal observable subscription method. * @param &#123;Object&#125; observer Any object that can be used as an observer. * The observer object should have a `next` method. * @returns &#123;subscription&#125; An object with an `unsubscribe` method that can * be used to unsubscribe the observable from the store, and prevent further * emission of values from the observable. */ subscribe(observer) &#123; if (typeof observer !== 'object') &#123; throw new TypeError('Expected the observer to be an object.') &#125; function observeState() &#123; if (observer.next) &#123; observer.next(getState()) &#125; &#125; observeState() const unsubscribe = outerSubscribe(observeState) return &#123;unsubscribe&#125; &#125;, [$$observable]() &#123; return this &#125; &#125;&#125; 初始化:初始化很简单，一句代码，直接调用一次dispatch，就会执行所有的注册函数，并且执行reducer函数，生成初始化的state12//马上内部调用一次初始化的操作，根据传入的reducer函数，preloadedState生成一个全新的currentState和全新的reducerdispatch(&#123;type: ActionTypes.INIT&#125;) 总结 createStore函数定义了几个局部变量用于记录状态，主要包括currentState记录数据状态，currentListeners记录注册函数列表，currentReducer记录当前的reducer函数。 定义了几个函数用于修改上面的几个局部变量：主要包括getState函数用于获取currentState；replaceReducer用于替换currentReducer；subscribe用于修改currentListeners列表；dispatch用于触发currentReducer执行，生成新的currentState，并且，执行currentListeners列表中的每一个函数。]]></content>
      <categories>
        <category>redux源码学习</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>react</tag>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[瀑布流布局]]></title>
    <url>%2F2018%2F05%2F09%2F%E7%80%91%E5%B8%83%E6%B5%81%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[瀑布流布局 在知乎看到大佬说，学习前端的第一阶段要会一些js基本的特效，学习一下，做几个Demo来看看 好像有那么两种方法：1、通过css来搞定瀑布流2、通过js来控制 CSS方法解决瀑布流因为css3有了一个新的属性:column我们在图片或者需要瀑布流的模块的父元素设置column属性就可以达到这种瀑布流的效果。12345678#main&#123; /*定位*/ /*position: relative;*/ /*多栏布局 设置栏宽度*/ -webkit-column-width:202px; -moz-column-width:202px; column-width:202px;&#125; JS方法来解决瀑布流布局首先先把html写出来：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;瀑布流布局&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="main"&gt; &lt;div class="wrap"&gt; &lt;div class="img"&gt; &lt;img src="http://img4.imgtn.bdimg.com/it/u=3673652172,785167112&amp;fm=27&amp;gp=0.jpg"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="wrap"&gt; &lt;div class="img"&gt; &lt;img src="http://img1.imgtn.bdimg.com/it/u=2752884811,3342547378&amp;fm=27&amp;gp=0.jpg"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="wrap"&gt; &lt;div class="img"&gt; &lt;img src="http://img5.imgtn.bdimg.com/it/u=2573504723,2456120500&amp;fm=27&amp;gp=0.jpg"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="wrap"&gt; &lt;div class="img"&gt; &lt;img src="http://img0.imgtn.bdimg.com/it/u=3214770734,3861052448&amp;fm=27&amp;gp=0.jpg"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="wrap"&gt; &lt;div class="img"&gt; &lt;img src="http://img4.imgtn.bdimg.com/it/u=3407532446,2830180038&amp;fm=27&amp;gp=0.jpg"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="wrap"&gt; &lt;div class="img"&gt; &lt;img src="http://img0.imgtn.bdimg.com/it/u=30302420,912099376&amp;fm=27&amp;gp=0.jpg"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="wrap"&gt; &lt;div class="img"&gt; &lt;img src="http://img5.imgtn.bdimg.com/it/u=2347360460,2805552283&amp;fm=27&amp;gp=0.jpg"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 在html里写了很多的图片（这里没有写出来，也可以从后台拉取数据）然后对图片做一些样式的调整：1234567891011121314151617181920212223&lt;style&gt; * &#123; padding: 0px; margin: 0px; &#125; #main &#123; position: relative; &#125; .wrap &#123; padding: 15px 0px 0px 15px; float: left; &#125; .img &#123; padding: 10px; border-radius: 5px; border: 1px solid #ccc; box-shadow: 0 0 5px #ccc; &#125; .img img &#123; width: 240px; height: auto; &#125; &lt;/style&gt; 对图片做一些操作，宽度确定，高度auto;然后开始用js对这些图片做一些处理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;script&gt; window.onload = function () &#123; waterFull('main', 'wrap'); &#125; function waterFull(parent, children) &#123; var oParent = document.getElementById(parent); var oWraps = getByClass(oParent, children); //计算整个页面显示的列数 var oWrapWeight = oWraps[0].offsetWidth; var cols = Math.floor(document.documentElement.clientWidth / oWrapWeight); //设置main的宽度，并且居中 oParent.style.cssText = 'width:' + oWrapWeight * cols + 'px; margin: 0 auto'; //找出高度最小的图片，将下一个图片放在下面 //定义一个数组，存放每一列的高度，初始化存的是第一行的所有列的高度 var arrHeight = []; for (var i = 0; i &lt; oWraps.length; i++) &#123; if (i &lt; cols) &#123; arrHeight.push(oWraps[i].offsetHeight); &#125;else &#123; var minHeight = Math.min.apply(null, arrHeight); var minIndex = getMinhIndex(arrHeight, minHeight); oWraps[i].style.position = 'absolute'; oWraps[i].style.top = minHeight + 'px'; oWraps[i].style.left = minIndex * oWrapWeight + 'px'; arrHeight[minIndex] += oWraps[i].offsetHeight; &#125; &#125; &#125; function getByClass(parent, className) &#123; var boxArr = new Array();//用来获取所有class为box的元素 oElement = parent.getElementsByTagName('*'); for (var i = 0; i &lt; oElement.length; i++) &#123; if (oElement[i].className == className) &#123; boxArr.push(oElement[i]); &#125; &#125;; return boxArr; &#125; //获取当前最小值得下标 function getMinhIndex(array, min) &#123; for (var i in array) &#123; if (array[i] == min) return i; &#125; &#125; &lt;/script&gt; 搞定～]]></content>
      <categories>
        <category>Demo练习</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>CSS</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react 16.0 新特性学习]]></title>
    <url>%2F2018%2F05%2F09%2Freact-16-0-%E6%96%B0%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[1、Fragment新版本的render可以返回数组、字符串、react组件、数字、boolean值v15.x必须要一个标签来包裹Before v161234567return ( &lt;div&gt; &lt;label htmlFor="name"&gt;名字：&lt;/label&gt; &lt;input id="name" type="text" placeholder="请输入名字"/&gt; &lt;button&gt;搜索&lt;/button&gt; &lt;/div&gt; ); When v16.0.01234567return ( [ &lt;label htmlFor="name"&gt;名字：&lt;/label&gt;, &lt;input id="name" type="text" placeholder="请输入名字"/&gt;, &lt;button&gt;搜索&lt;/button&gt; ]); Now v16.2.01234567return ( &lt;React.Fragment&gt; &lt;label htmlFor="name"&gt;名字：&lt;/label&gt; &lt;input id="name" type="text" placeholder="请输入名字"/&gt; &lt;button&gt;搜索&lt;/button&gt; &lt;/React.Fragment&gt;); 片段(fragments) 可以让你将子元素列表添加到一个分组中，并且不会在DOM中增加额外节点。key 是唯一可以传递给 Fragment 的属性1234567891011return ( &lt;dl&gt; &#123;props.items.map(item =&gt; ( // 没有`key`，将会触发一个key警告 &lt;React.Fragment key=&#123;item.id&#125;&gt; &lt;dt&gt;&#123;item.term&#125;&lt;/dt&gt; &lt;dd&gt;&#123;item.description&#125;&lt;/dd&gt; &lt;/React.Fragment&gt; ))&#125; &lt;/dl&gt; ); 简明写法&lt;&gt;&lt;/&gt;，但是还没有被更多的工具支持，它不支持 键(keys) 或 属性(attributes)。Further babel v7.0.0+ , babel-plugin-transform-react-jsx-source or babel-preset-react 1234567return ( &lt;&gt; &lt;label htmlFor="name"&gt;名字：&lt;/label&gt; &lt;input id="name" type="text" placeholder="请输入名字"/&gt; &lt;button&gt;搜索&lt;/button&gt; &lt;/&gt;); DOM Fragment 12345678910const select = document.getElementById('select')const values = [1, 2, 3]const fragment = document.createDocumentFragment()values.map(item =&gt; &#123; const option = document.createElement('option') option.value = item option.innerHTML = `小明$&#123;item&#125;号` fragment.appendChild(option)&#125;)select.appendChild(fragment) 2、PortalsPortals是reactjs16提供的官方解决方案，使得组件可以脱离父组件层级挂载在DOM树的任何位置。普通情况下，组件的render函数返回的元素会被挂载在它的父级组件上。然而，有些元素需要被挂载在更高层级的位置。最典型的应用场景：当父组件具有overflow: hidden或者z-index的样式设置时，组件有可能被其他元素遮挡，就可以考虑使用Portal使组件的挂载脱离父组件。组件的挂载点虽然可以脱离父组件，但组件的事件通过冒泡机制仍可以传给父组件。1234&lt;body&gt; &lt;div id="bd"&gt;&lt;/div&gt; &lt;div id="modal"&gt;&lt;/div&gt;&lt;/body&gt; 123456789101112render( &lt;App&gt; &lt;SearchBox&gt; &lt;Modal&gt; &lt;div&gt;模态框&lt;/div&gt; &lt;/Modal&gt; &lt;/SearchBox&gt; &lt;/App&gt;, document.getElementById('bd'), () =&gt; &#123; console.log(arguments)&#125;) 1234567891011121314class App extends Component&#123; constructor(options) &#123; super(options) this.handleClick = this.handleClick.bind(this) &#125; handleClick() &#123; alert('react component tree propagation!') &#125; render() &#123; return &lt;div className="app" onClick=&#123;this.handleClick&#125;&gt; &#123;this.props.children&#125; &lt;/div&gt; &#125;&#125; 12345678class Modal extends Component &#123; constructor(options) &#123; super(options) &#125; render() &#123; return createPortal(this.props.children, document.getElementById('modal')) &#125; &#125; 12345678910&lt;div id="bd"&gt; &lt;div class="app"&gt; &lt;label for="name"&gt;名字：&lt;/label&gt; &lt;input type="text" id="name" placeholder="请输入名字"&gt; &lt;button&gt;搜索&lt;/button&gt; &lt;/div&gt;&lt;/div&gt;&lt;div id="modal"&gt; &lt;div&gt;模态框&lt;/div&gt;&lt;/div&gt; 1234567891011121314&lt;App&gt; &lt;div className=&quot;app&quot; onClick=bound handleClick()&gt; &lt;SearchBox&gt; &lt;labelhtmlFor=&quot;name&quot;&gt;名字：&lt;/label&gt; &lt;inputid=&quot;name&quot;type=&quot;text&quot;placeholder=&quot;请输入名字&quot;&gt;&lt;/input&gt; &lt;button&gt;搜索&lt;/button&gt; &lt;Modal&gt; &lt;ReactPortal target=HTMLDivElement&#123;…&#125;&gt; &lt;div&gt;模态框&lt;/div&gt; &lt;/ReactPortal&gt; &lt;/Modal&gt; &lt;/SearchBox&gt; &lt;/div&gt;&lt;/App&gt; Before portals 123456789101112131415161718ReactDom.render(reactChild, container, callback)ReactDom.unmountComponentAtNode(container)ReactDom.unstable_renderSubtreeIntoContainer( context, reactChild, domNode, callback)ReactDom.unmountComponentAtNode(container)render: ReactMount._renderSubtreeIntoContainer(null, reactChild, container, callback )unstable_renderSubtreeIntoContainer: ReactMount._renderSubtreeIntoContainer(context, reactChild, container, callback) 3、Error Boundaries之前react在渲染过程中或者是生命周期内出现了致命的错误，react会从根组件上把所有的组件都卸载下来，以防止展现错误的数据，但这不是最好的用户体验。React 16修复了这一点，引入了Error Boundary的概念，中文译为“错误边界”，当某个组件发生错误时，我们可以通过Error Boundary捕获到错误并对错误做优雅处理。（注：它并不能捕获runtime所有的错误，比如组件回调事件里的错误，可以把它想象成传统的try-catch语句） 123456789101112131415161718192021class ErrorBoundary extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; hasError: false &#125;; &#125;// 新增了componentDidCatch这个生命周期函数，它可以捕获自身及子树上的错误并对错误做优雅处理，包括上报错误日志、展示出错提示，而不是卸载整个组件树。 componentDidCatch(error, info) &#123; // 错误代理组件的展示与否 this.setState(&#123; hasError: true &#125;); // 在这里我们可以对错误进行记录 logErrorToMyService(error, info); &#125; render() &#123; if (this.state.hasError) &#123; // 在这里我们可以书写自己想要展示的ui组件 return &lt;h1&gt;Something went wrong.&lt;/h1&gt;; &#125; return this.props.children; &#125;&#125; 上面的组件是当页面中有错误时我们想要展示的效果，具体用法如下:12345678910render()&#123; return ( &lt;div&gt; &lt;ErrorBoundary&gt; // 外层组件我们定义的错误组件 &lt;Profile user=&#123;this.state.user&#125; /&gt; // 内层组件是我们将要监视的自定义组件 &lt;/ErrorBoundary&gt; &lt;button onClick=&#123;this.onClick&#125;&gt;Update&lt;/button&gt; &lt;/div&gt; )&#125; 这个组件能够不仅仅能够监听到本组件的错误，连同它下面的子组件的错误也可以监听到 ###不能捕获的错误 事件处理 异步回调 服务端渲染 error boundary组件自身抛出的错误（只能由父级捕获）###react遇到未捕获的错误会怎么办对 React16 来说，一个未捕获的错误会导致整个应用不能被挂载 4、setState传入null时不会再触发更新之前的setState不管传入什么只要调用了这么方法就会渲染123456789selectCity(e)&#123; const newValue = e.target.value; this.setState((state)=&gt;&#123; if(state.city===newValue)&#123; return null; &#125; return &#123;city:newValue&#125; &#125;)) 5、v16.0支持自定义的dom属性之前的版本对于自定义属性react会在属性前加上data-**来进行处理，现在对于部分属性去除了这种写法，拥抱了原生dom，这样可以减少react的代码，提升了性能 6、其他更好的服务器端渲染：React 16的SSR被完全重写，新的实现非常快，接近3倍性能于React 15，现在提供一种流模式streaming，可以更快地把渲染的字节发送到客户端。 react v16采用了最新的技术“Fiber.” React Server Side Rendering 解决 SPA 应用的 SEO 问题]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Event Loop 问题理解]]></title>
    <url>%2F2018%2F05%2F09%2FEvent-Loop-%E9%97%AE%E9%A2%98%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Q1:事件循环机制是什么？A1:JavaScript 是典型的单线程单并发语言，即表示在同一时间内其只能执行单个任务，同域浏览器中 JavaScript 主线程拥有一个函数调用栈(主线程)以及多个任务队列。 Q2:什么是任务？A2:任务分为两种，一种是同步任务，一种是异步任务。 同步任务，就是主线程中排队执行的任务； 异步任务，不先进入主线程，而是先进入“任务队列”的任务，只有任务队列通知了主线程，某个异步任务可以执行了，该任务才会进入主线程执行 Q3:事件循环（Event Loop）的原理是什么？A3:首先，主线程会依次执行代码。 当主线栈的函数调用栈为空时，即会根据事件循环（Event Loop）机制来从任务队列中提取出待执行的回调并执行。 执行的过程同样会进行函数帧的入栈出栈操作。这样不断的循环往复，这就是事件循环（Event Loop）。 只要主线程空了，就会去读取”任务队列”，这就是JavaScript的运行机制 Q4:任务队列中的任务有几种？A4:任务队列中的任务分为两种：MacroTask (task) 和 MicroTask 。Event Loop 处理这两种任务。 Q5:MacroTask (task) 和 MicroTask各包含什么任务？A5: microtasks:process.nextTick promise Object.observe MutationObserver macrotasks:setTimeout setInterval setImmediate I/O UI渲染 Q6:MacroTask和MicroTask的运行机制是什么？A6:事件循环的顺序，决定了JavaScript代码的执行顺序。它从script(整体代码)开始第一次循环。之后全局上下文进入函数调用栈。直到调用栈清空(只剩全局)，然后执行所有的microtask。当所有可执行的micro-task执行完毕之后。循环再次从macro-task开始，找到其中一个任务队列执行完毕，然后再执行所有的micro-task，这样一直循环下去。一句话说，microtask将会被添加到任务队列末尾进行处理。 MacroTask运行机制MicroTask运行机制Q7:来尝试一道面试题123456789101112131415161718192021222324252627282930313233343536373839console.log('start')const interval = setInterval(() =&gt; &#123; console.log('setInterval')&#125;, 0)setTimeout(() =&gt; &#123; console.log('setTimeout 1') Promise.resolve() .then(() =&gt; &#123; console.log('promise 3') &#125;) .then(() =&gt; &#123; console.log('promise 4') &#125;) .then(() =&gt; &#123; setTimeout(() =&gt; &#123; console.log('setTimeout 2') Promise.resolve() .then(() =&gt; &#123; console.log('promise 5') &#125;) .then(() =&gt; &#123; console.log('promise 6') &#125;) .then(() =&gt; &#123; clearInterval(interval) &#125;) &#125;, 0) &#125;)&#125;, 0)Promise.resolve() .then(() =&gt; &#123; console.log('promise 1') &#125;) .then(() =&gt; &#123; console.log('promise 2') &#125;) A7:startpromise 1promise 2setIntervalsetTimeout 1promise 3promise 4setIntervalsetTimeout 2promise 5promise 6]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PWA 之Q&A]]></title>
    <url>%2F2018%2F05%2F08%2FPWA-%E4%B9%8BQ-A%2F</url>
    <content type="text"><![CDATA[——吉吉《PWA初窥》学习笔记 Q1：什么是PWA？A1: PWA全称Progressive Web App，即渐进式WEB应用。一个 PWA 应用首先是一个网页, 可以通过 Web 技术编写出一个网页应用. 随后添加上 App Manifest 和 Service Worker 来实现 PWA 的安装和离线等功能 Q2: PWA解决了什么问题？A2: 1) 可以添加至主屏幕，点击主屏幕图标可以实现启动动画以及隐藏地址栏 2）实现离线缓存功能，即使用户手机没有网络，依然可以使用一些离线功能 3）实现了消息推送 Q3: App Manifest 是什么，有什么用？A3: Web应用程序清单在一个JSON文本文件中提供有关应用程序的信息（如名称，作者，图标和描述）。manifest 的目的是将Web应用程序安装到设备的主屏幕，为用户提供更快的访问和更丰富的体验。 Q4: 什么是service worker，有什么作用？A4: Service Worker 是 Chrome 团队提出和力推的一个 WEB API，用于给 web 应用提供高级的可持续的后台处理能力。 Service Workers 就像介于服务器和网页之间的拦截器，能够拦截进出的HTTP 请求，从而完全控制你的网站。 Q5: service worker 有什么特点？A5：1）resource caching and push notifications 2）client-side programmable proxy between web app and the outside world 3）service workers run independent of the application they are associated with 4）the primary uses for a service workers are to act as a caching agent to handle network requests 5）and to store content for offline use and secondly to handle push messaging the 6）information that you need to persist and reuse across restartswork with IndexedDB databases 7）promise-based 8）only available on secure origins(https) Q6: HTTP缓存与service worker缓存有什么区别A6: HTTP缓存 Web 服务器可以使用 Expires 首部来通知 Web 客户端，它可以使用资源的当前副本，直到指定的“过期 时间”。反过来，浏览器可以缓存此资源，并且只有在有效期满后才会再次检查新版本。 使用 HTTP 缓存意味着你要依赖服务器来告诉你何时缓存资源和何时过期。 service worker缓存 Service Workers 的强大在于它们拦截 HTTP 请求的能力 进入任何传入的 HTTP 请求，并决定想要如何响应。在你的 Service Worker 中，可以编写逻辑来决定 想要缓存的资源，以及需要满足什么条件和资源需要缓存多久。一切尽归你掌控！ Q7: service worker的生命周期是怎样的？A7: Q8: 怎么配置一个PWAA8: 1）准备一个html文件，以及相应的css等：12345678910&lt;head&gt; &lt;title&gt;Minimal PWA&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, user-scalable=no" /&gt; &lt;link rel="stylesheet" type="text/css" href="main.css"&gt; &lt;link rel="manifest" href="manifest.json" /&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;Revision 1&lt;/h3&gt; &lt;div class="main-text"&gt;Minimal PWA, open Console for more~~~&lt;/div&gt;&lt;/body&gt; 2）添加manifest.json文件 123456789101112131415&#123; "name": "Minimal app to try PWA", "short_name": "Minimal PWA", "display": "standalone", "start_url": "/", "theme_color": "#8888ff", "background_color": "#aaaaff", "icons": [ &#123; "src": "e.png", "sizes": "256x256", "type": "image/png" &#125; ]&#125; 3)添加Service WorkerService Worker 在网页已经关闭的情况下还可以运行, 用来实现页面的缓存和离线, 后台通知等等功能。sw.js 文件需要在 HTML 当中引入:12345678&lt;script&gt; if (navigator.serviceWorker != null) &#123; navigator.serviceWorker.register('sw.js') .then(function(registration) &#123; console.log('Registered events at scope: ', registration.scope); &#125;); &#125;&lt;/script&gt; 4)处理静态缓存12345678var cacheStorageKey = 'minimal-pwa-1'var cacheList = [ '/', "index.html", "main.css", "e.png"] 借助 Service Worker, 可以在注册完成安装 Service Worker 时, 抓取资源写入缓存:1234567self.addEventListener('install', e =&gt; &#123; e.waitUntil( caches.open(cacheStorageKey) .then(cache =&gt; cache.addAll(cacheList)) .then(() =&gt; self.skipWaiting()) )&#125;) 调用 self.skipWaiting() 方法是为了在页面更新的过程当中, 新的 Service Worker 脚本能立即激活和生效。5）处理动态缓存网页抓取资源的过程中, 在 Service Worker 可以捕获到 fetch 事件, 可以编写代码决定如何响应资源的请求:12345678910self.addEventListener('fetch', function(e) &#123; e.respondWith( caches.match(e.request).then(function(response) &#123; if (response != null) &#123; return response &#125; return fetch(e.request.url) &#125;) )&#125;) 真实的项目当中, 可以根据资源的类型, 站点的特点, 可以专门设计复杂的策略。fetch 事件当中甚至可以手动生成 Response 返回给页面。6)更新静态资源缓存的资源随着版本的更新会过期, 所以会根据缓存的字符串名称(这里变量为 cacheStorageKey, 值用了 “minimal-pwa-1”)清除旧缓存, 可以遍历所有的缓存名称逐一判断决决定是否清除(备注: 简化的写法, Promise.all 中 return undefined 可能出错, 见评论): 123456789101112self.addEventListener('activate', function(e) &#123; e.waitUntil( Promise.all( cacheNames.filter(name =&gt; &#123; return name !== cacheStorageKey &#125;).map(name =&gt; &#123; return caches.delete(name) &#125;) ).then(() =&gt; self.clients.claim()) &#125;) )&#125;) 在新安装的 Service Worker 中通过调用 self.clients.claim() 取得页面的控制权, 这样之后打开页面都会使用版本更新的缓存。旧的 Service Worker 脚本不再控制着页面之后会被停止。 相关文章： PWA 入门: 写个非常简单的 PWA 页面 讲讲PWA 您的第一个 Progressive Web App]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Javascript 继承学习]]></title>
    <url>%2F2018%2F05%2F08%2FJavascript%20%E7%BB%A7%E6%89%BF%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[javascript的继承方式有好多方式，之前ES5通过原型链继承，ES6中引入了Class，javascript可以像java一样使用extends关键字继承。现在整理一下js中的继承方式。 ES5中的继承方式 一、构造函数的继承现在有一个”动物”对象的构造函数123function Animal()&#123; this.species = "动物";&#125; 还有一个”猫”对象的构造函数。 1234function Cat(name,color)&#123; this.name = name; this.color = color;&#125; 1.构造函数绑定:使用call或apply方法，将父对象的构造函数绑定在子对象上。 1234567function Cat(name,color)&#123; Animal.apply(this, arguments); this.name = name; this.color = color;&#125;var cat1 = new Cat("大毛","黄色");alert(cat1.species); // 动物 此种继承方式只能继承父构造函数中的属性,不能继承父构造函数原型上的属性.Animal.apply(this, arguments)也可用Animal.call(this)替换.cat对象有两个层级,第一级存放着自有属性以及父构造器中的属性,第二级存放着自己函数原型上的属性(Cat.prototype) 2.prototype模式: 1234Cat.prototype = new Animal();Cat.prototype.constructor = Cat;var cat1 = new Cat("大毛","黄色");alert(cat1.species); // 动物 遵循一点，即如果替换了prototype对象，1o.prototype = &#123;&#125;; 那么，下一步必然是为新的prototype对象加上constructor属性，并将这个属性指回原来的构造函数。1o.prototype.constructor = o; 此种继承方式既能继承父构造函数中的属性,也能继承父构造函数原型上的属性.cat对象有三个层级,第一级存放着自有属性,第二级存放着父构造器的属性(加上constructor,指向创建该对象(cat)的构造器(Cat)),第三级存放着父构造器原型上的属性. 3.直接继承prototype:第3种方法是对第2种方法的改进。由于Animal对象中，不变的属性都可以直接写入Animal.prototype。所以，我们也可以让Cat()跳过 Animal()，直接继承Animal.prototype。 先将Animal对象改写 12function Animal()&#123; &#125;Animal.prototype.species = "动物"; 然后，将Cat的prototype对象，然后指向Animal的prototype对象，这样就完成了继承。 1234Cat.prototype = Animal.prototype;Cat.prototype.constructor = Cat;var cat1 = new Cat("大毛","黄色");alert(cat1.species); // 动物 此种继承方式只能继承父构造器原型上的属性.cat对象有两个层级,第一级存放着自有属性,第二级存放着父构造器原型上的属性(加上constructor,指向创建该对象(cat)的构造器(Cat)).注意:Cat.prototype.constructor = Cat会将Animal.prototype.constructor也改成Cat,从而影响父构造器创建对象 4.空对象作为中介: 1234567function extend(Child, Parent) &#123; var F = function()&#123;&#125;; F.prototype = Parent.prototype; Child.prototype = new F(); Child.prototype.constructor = Child; Child.uber = Parent.prototype;&#125; 用法： 123extend(Cat,Animal);var cat1 = new Cat("大毛","黄色");alert(cat1.species); // 动物 此种继承方式只能继承父构造器原型上的属性.cat对象有三个层级,第一级存放着自有属性,第二级存放着临时构造器F的属性(加上constructor,指向创建该对象(cat)的构造器(Cat)),第三级存放着父构造器原型上的属性.注意:临时构造器只充当中介的作用,一般不会有自己的属性. 5.浅拷贝继承:首先，还是把Animal的所有不变属性，都放到它的prototype对象上。12function Animal()&#123; &#125;Animal.prototype.species = "动物"; 然后，再写一个函数，实现属性拷贝的目的。12345678function extend2(Child, Parent) &#123; var p = Parent.prototype; var c = Child.prototype; for (var i in p) &#123; c[i] = p[i]; &#125; c.uber = p;&#125; 用法： 123extend2(Cat, Animal);var cat1 = new Cat("大毛","黄色");alert(cat1.species); // 动物 此种继承方式只能继承父构造器原型上的属性.cat对象有两个层级,第一级存放着自有属性,第二级存放着父构造器原型上的除了constructor和proto的属性(不会拷贝原型上的constructor和proto属性).适合父构造器原型上的自增属性为基本数据类型的情况. 二、非构造函数的继承比如，现在有一个对象，叫做”中国人”。123var Chinese = &#123; nation:'中国'&#125;; 还有一个对象，叫做”医生”。123var Doctor =&#123; career:'医生'&#125; 1.object()方法 12345function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125; 这个object()函数，其实只做一件事，就是把子对象的prototype属性，指向父对象，从而使得子对象与父对象连在一起。用法：第一步先在父对象的基础上，生成子对象：1var Doctor = object(Chinese); 然后，再加上子对象本身的属性：1Doctor.career = '医生'; 这时，子对象已经继承了父对象的属性了。1alert(Doctor.nation); //中国 2.浅拷贝除了使用”prototype链”以外，还有另一种思路：把父对象的属性，全部拷贝给子对象，也能实现继承。 就是在做拷贝：12345678function extendCopy(p) &#123;var c = &#123;&#125;;for (var i in p) &#123; c[i] = p[i];&#125;c.uber = p;return c;&#125; 用法，这样写：123var Doctor = extendCopy(Chinese);Doctor.career = '医生';alert(Doctor.nation); // 中国 样的拷贝有一个问题。那就是，如果父对象的属性等于数组或另一个对象，那么实际上，子对象获得的只是一个内存地址，而不是真正拷贝，因此存在父对象被篡改的可能。 3.深拷贝所谓”深拷贝”，就是能够实现真正意义上的数组和对象的拷贝。它的实现并不难，只要递归调用”浅拷贝”就行了。123456789101112function deepCopy(p, c) &#123; var c = c || &#123;&#125;; for (var i in p) &#123; if (typeof p[i] === 'object') &#123; c[i] = (p[i].constructor === Array) ? [] : &#123;&#125;; deepCopy(p[i], c[i]); &#125; else &#123; c[i] = p[i]; &#125; &#125; return c;&#125; 使用的时候这样写：1var Doctor = deepCopy(Chinese); 现在，给父对象加一个属性，值为数组。然后，在子对象上修改这个属性：这时，父对象就不会受到影响了。目前，jQuery库使用的就是这种继承方法。 ES6中的继承方式Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。123456789101112class Point &#123; //一些属性&#125;class ColorPoint extends Point &#123; //一些属性&#125;// 等同于class ColorPoint extends Point &#123; constructor(...args) &#123; super(...args); &#125;&#125; 上面代码定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Point类。 如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。 在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例。 ES6 规定，在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
</search>
