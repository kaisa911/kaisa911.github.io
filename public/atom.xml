<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Milestone</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-15T02:28:31.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>啪叽</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Javascript 基本概念（三）</title>
    <link href="http://yoursite.com/2018/06/13/Javascript%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2018/06/13/Javascript基本概念（三）/</id>
    <published>2018-06-13T15:27:09.000Z</published>
    <updated>2018-06-15T02:28:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是JS高程第三章的第三部分。这一章内容是真的多。。我觉得重新刷高程，对我来说，也是一种不一样的进步吧。<br>本节的主要内容是</p><ul><li>操作符</li></ul><h2 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符"></a>一元操作符</h2><p>只能操作一个一个值的操作符叫做<b>一元操作符</b>。<br>1、递增递减操作符<br>  有两个版本，前置型和后置型。<br>  前置型，先操作，后执行。<br>  后置型，先执行，后操作。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">5</span>, b = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> sum = ++a + b;</span><br><span class="line"><span class="keyword">let</span> sum2 = a++ + b;</span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">//12</span></span><br><span class="line"><span class="built_in">console</span>.log(sum2) <span class="comment">//12</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//7</span></span><br></pre></td></tr></table></figure></p><p>  递增递减操作符对数值，布尔，字符串，对象都有作用！！！！！<br>  规则如下：</p><ul><li>如果字符串包含有效数字，则先转化成数值变量，然后加减1；不包含有效数字，则转化成NaN。字符串变量变成数值变量</li><li>数值变量加减1；</li><li>布尔变量，true先变成1，false变成0，然后加减1,布尔变了转换成数值变量；</li><li>对象变量，先查看valueOf()方法，如果是NaN，则调用toString()，对象转换成数值变量。</li></ul><p>2、一元加减操作符。<br>  一元+操作符，会像Number()方法一样对变量转换成数值变量<code>var a; a = +a</code>;<br>  一元-操作符，主要是变成负数。会像Number()方法一样，不过是负数。</p><h2 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h2><p>首先ES里所有的数值都是有64位来储存，但是位操作符并不是操作64位，而是先转化成32位的整数，然后操作，再将结果转换成64位的，这样，NaN和Infinity就会变成0。<br>对于有符号数，第32位是符号位，0代表正数，1代表负数，符号位决定了其他位数值的格式。剩下31位用来储存数据。<br>正数都是以二进制格式存储，负数以二进制的补码格式存储。默认情况下，ES里所有的正数都是有符号数。<br>无符号数，第32位是数值。但是无符号数只能是正数。<br>位操作符对其他变量，会先用Number()方法变成数值，然后再按位操作。<br>1、按位非（NOT）<br>  按位非是用～表示，执行按位非的结果是返回数值的反码。<br>2、按位与（AND）<br>  按位与是用&amp;表示，它有两个操作符数，运算的时候，将两个数的二进制每一位对齐，都是1得1，其他为0；<br>3、按位或（OR）<br>  按位或是用|表示，它有两个操作符数，运算的时候，将两个数的二进制每一位对齐，都是0得0，其他为1；<br>4、按位异或（XOR）<br>  按位或是用^表示，它有两个操作符数，运算的时候，将两个数的二进制每一位对齐，相同得0，不同为1；<br>5、左移<br>  左移用&lt;&lt;表示，会将数值所有位数向左移动指定的位数。后面补0；左移不会影响符号。<br>6、有符号右移<br>  有符号右移用&gt;&gt;表示，会将数值所有位数向右移动指定的位数。前面补0；保留符号位，不会影响符号。<br>7、无符号右移<br>  无符号右移用&gt;&gt;&gt;表示，会将数值所有位数向右移动指定的位数。前面补0；会影响符号。而且会把负数的补码当成二进制码来运算。</p><h2 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h2><p>布尔运算符有三个，主要用来测试值的关系<br>1、逻辑非(!)<br>这个操作符会返回一个布尔值，逻辑非运算会将操作数先转换成布尔值，然后求反。<br>规则：</p><ul><li>操作数是对象，返回false</li><li>操作数是空字符串，返回true</li><li>操作数是非空字符串，返回false</li><li>操作数是非0数值，返回false</li><li>操作数是0，null，NaN，undefined，返回true<br>2、逻辑与(&amp;&amp;)<br>逻辑与操作符两边有两个操作数。都是true才为true。<br>逻辑与操作可以应用于所有变量，在有一个操作数不是布尔值的情况下，逻辑与不一定会返回布尔值。<br>规则：</li><li>如果第一个操作数是对象，则返回第二个操作数</li><li>如果第二个操作数是对象，则必须第一个操作数是true才会返回该对象。</li><li>如果两个数都是对象，则返回第二个操作数</li><li>如果有一个操作数是null，NaN，undefined，则返回null，NaN，undefined。<br>逻辑与属于短路操作，第一个操作数能决定结果，就不会对第二个操作数求值。<br>3、逻辑或(||)<br>逻辑或两边有两个操作数，有一个为true就是true。<br>逻辑或操作可以应用于所有变量，在有一个操作数不是布尔值的情况下，逻辑与不一定会返回布尔值。<br>规则：</li><li>如果第一个操作数是对象，则返回第一个操作数</li><li>如果第一个操作数是false，则返回第二个操作数</li><li>两个操作数都是对象，则返回第一个操作数</li><li>如果两个操作数是null，NaN，undefined，则返回null，NaN，undefined。</li></ul><h2 id="乘性操作符"><a href="#乘性操作符" class="headerlink" title="乘性操作符"></a>乘性操作符</h2><p>ES有三个乘性操作符，乘法，除法和求模。<br>如果乘性操作符的某一个操作数不是数值，则将会用Number()方法，先转换成数值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是JS高程第三章的第三部分。这一章内容是真的多。。我觉得重新刷高程，对我来说，也是一种不一样的进步吧。&lt;br&gt;本节的主要内容是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作符&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;一元操作符&quot;&gt;&lt;a href=&quot;#一元操作符&quot; class=&quot;heade
      
    
    </summary>
    
      <category term="JS高程填坑笔记" scheme="http://yoursite.com/categories/JS%E9%AB%98%E7%A8%8B%E5%A1%AB%E5%9D%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>display的属性们</title>
    <link href="http://yoursite.com/2018/06/13/display%E7%9A%84%E5%B1%9E%E6%80%A7%E4%BB%AC/"/>
    <id>http://yoursite.com/2018/06/13/display的属性们/</id>
    <published>2018-06-13T03:11:58.000Z</published>
    <updated>2018-06-13T03:17:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>display： none | inline | block | list-item | inline-block | table | inline-table | table-caption | table-cell | table-row | table-row-group | table-column | table-column-group | table-footer-group | table-header-group | run-in | box | inline-box | flexbox | inline-flexbox | flex | inline-flex<br>默认值：inline</p><p>none： 隐藏对象。与visibility属性的hidden值不同，其不为被隐藏的对象保留其物理空间<br>inline： 指定对象为内联元素。<br>block： 指定对象为块元素。<br>list-item： 指定对象为列表项目。<br>inline-block： 指定对象为内联块元素。（CSS2）<br>table： 指定对象作为块元素级的表格。类同于html标签&lt;table&gt;（CSS2）<br>inline-table： 指定对象作为内联元素级的表格。类同于html标签&lt;table&gt;（CSS2）<br>table-caption： 指定对象作为表格标题。类同于html标签&lt;caption&gt;（CSS2）<br>table-cell： 指定对象作为表格单元格。类同于html标签&lt;td&gt;（CSS2）<br>table-row： 指定对象作为表格行。类同于html标签&lt;tr&gt;（CSS2）<br>table-row-group： 指定对象作为表格行组。类同于html标签&lt;tbody&gt;（CSS2）<br>table-column： 指定对象作为表格列。类同于html标签&lt;col&gt;（CSS2）<br>table-column-group： 指定对象作为表格列组显示。类同于html标签&lt;colgroup&gt;（CSS2）<br>table-header-group： 指定对象作为表格标题组。类同于html标签&lt;thead&gt;（CSS2）<br>table-footer-group： 指定对象作为表格脚注组。类同于html标签&lt;tfoot&gt;（CSS2）<br>run-in： 根据上下文决定对象是内联对象还是块级对象。（CSS3）<br>box： 将对象作为弹性伸缩盒显示。（伸缩盒最老版本）（CSS3）<br>inline-box： 将对象作为内联块级弹性伸缩盒显示。（伸缩盒最老版本）（CSS3）<br>flexbox： 将对象作为弹性伸缩盒显示。（伸缩盒过渡版本）（CSS3）<br>inline-flexbox： 将对象作为内联块级弹性伸缩盒显示。（伸缩盒过渡版本）（CSS3）<br>flex： 将对象作为弹性伸缩盒显示。（伸缩盒最新版本）（CSS3）<br>inline-flex： 将对象作为内联块级弹性伸缩盒显示。（伸缩盒最新版本）（CSS3）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;display： none | inline | block | list-item | inline-block | table | inline-table | table-caption | table-cell | table-row | table-row-gro
      
    
    </summary>
    
      <category term="面试锦囊" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%94%A6%E5%9B%8A/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>link和@import之争</title>
    <link href="http://yoursite.com/2018/06/13/link%E5%92%8C-import%E4%B9%8B%E4%BA%89/"/>
    <id>http://yoursite.com/2018/06/13/link和-import之争/</id>
    <published>2018-06-13T02:52:26.000Z</published>
    <updated>2018-06-13T03:05:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>看到知乎大神说，先问是不是，再问为什么</p><p>我页不知道为什么要写这句话，反正就是很奇怪的想法，就先记下来。<br>今天研究的link和@import，是外部引入外部引入 CSS 的两种方式。<br>两者是有区别的（是不是）。<br>我们来研究一下有哪些区别（为什么）</p><ul><li>link是XHTML(HTML)标签，除了加载CSS外，还可以定义RSS,rel等其他事务； @import是 CSS 提供的语法规则, 只有导入样式表的作用。</li><li>link引用CSS时，在页面载入时同时加载； @import需要页面网页完全载入以后加载。</li><li>link是XHTML(HTML)标签，无兼容问题； @import是在CSS2.1提出的，低版本的浏览器不支持(IE5+)。</li><li>link支持使用Javascript控制DOM去改变样式；而@import不支持。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"style.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  @import url(style.css);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看到知乎大神说，先问是不是，再问为什么&lt;/p&gt;
&lt;p&gt;我页不知道为什么要写这句话，反正就是很奇怪的想法，就先记下来。&lt;br&gt;今天研究的link和@import，是外部引入外部引入 CSS 的两种方式。&lt;br&gt;两者是有区别的（是不是）。&lt;br&gt;我们来研究一下有哪些区别（为什么
      
    
    </summary>
    
      <category term="面试锦囊" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%94%A6%E5%9B%8A/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Javascript基本概念(二）</title>
    <link href="http://yoursite.com/2018/06/11/Javascript%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2018/06/11/Javascript基本概念（二）/</id>
    <published>2018-06-11T06:20:09.000Z</published>
    <updated>2018-06-15T02:28:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>JS高程的第三章第二节，对数据类型进行一下学习</p><p>JS有五种基本数据类型：Number，String，Boolean，Undefined，Null和一种复杂类型：Object，Object本质上是由一组无序的名值对组成的（说好的万物皆对象来着）。JS不支持任何创建自定义类型的机制。</p><h2 id="typeof-操作符"><a href="#typeof-操作符" class="headerlink" title="typeof 操作符"></a>typeof 操作符</h2><p>ECMAScript是松散类型的，typeof就是负责来检测给定变量的数据类型的操作符。<br>typeof是判断参数是什么类型的实例，就一个参数<br>typeof一般只能返回如下几个结果：”number”、”string”、”boolean”、”object”、”function” 和 “undefined”。</p><h2 id="Undefined类型"><a href="#Undefined类型" class="headerlink" title="Undefined类型"></a>Undefined类型</h2><p>Undefined类型只有一个值，即特殊的undefined。只有在变量声明且未初始化的时候，变量的值为undefined。<br>建议显式的初始化undefined，这样发现值为undefined的时候，就会知道该变量未声明而不是未初始化。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">'undefined'</span>;</span><br></pre></td></tr></table></figure></p><h2 id="Null类型"><a href="#Null类型" class="headerlink" title="Null类型"></a>Null类型</h2><p>Null类型只有一个值的数据类型，即特殊的null。从逻辑角度来看，null值表示一个空对象指针，使用typeof操作符检测null值时会返回’object’。<br>如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为null而不是其他值。只要直接检查null值就可以知道相应的变量是否已经保存了一个对象的引用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj != <span class="literal">null</span>)&#123;</span><br><span class="line"><span class="comment">// 对 car 对象执行某些操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>另外：undefined值是派生自null值的，在验证相等时，它们的相等性测试要返回true。但是在全等性测试时返回false。</p><h2 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h2><p>Boolean类型是JS中使用得最多的一种类型，该类型只有两个字面值:true和false。Boolean类型的字面值true和false是区分大小写的。<br>Boolean类型的字面值只有两个，但JS中所有类型的值都有与这两个Boolean值等价的值。要将一个值转换为其对应的 Boolean值，可以调用转型函数Boolean(),可以对任何数据类型的值调用Boolean()函数，而且总会返回一个Boolean值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> message = <span class="string">'hello world'</span>;</span><br><span class="line"><span class="keyword">const</span> bool = <span class="built_in">Boolean</span>(message);</span><br></pre></td></tr></table></figure></p><table><thead><tr><th>数据类型</th><th style="text-align:center">true</th><th style="text-align:center">false </th></tr></thead><tbody><tr><td>String</td><td style="text-align:center">任何非空字符串</td><td style="text-align:center">‘’(空字符串)</td></tr><tr><td>Boolean</td><td style="text-align:center">true</td><td style="text-align:center">false</td></tr><tr><td>Number</td><td style="text-align:center">任何非0值</td><td style="text-align:center">0和NaN</td></tr><tr><td>Object</td><td style="text-align:center">任何对象</td><td style="text-align:center">null</td></tr><tr><td>undefined</td><td style="text-align:center"></td><td style="text-align:center">undefined</td></tr></tbody></table><h2 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h2><p>Number类型使用IEEE754格式来表示整数和浮点数值(浮点数值在某些语言中也被称为双精度数值)。<br>最基本的数值字面量格式是十进制整数：<code>const num = 254;</code>，最高具有53位有效数字精度<br>八进制字面值的第一位必须是零(0)，然后是八进制数字序列(0~7)<code>const num2 = 03</code>;八进制字面量在严格模式下是无效的<br>十六进制字面值的前两位必须是 0x,<code>const num2 = 0xff</code><br>算术计算时，所有以八进制和十六进制表示的数值都会被转换成十进制数值<br>在JavaScript中保存数值的方式，可以保存正零(+0)和负零(0)。正零和负零被认为相等<br>1、浮点数值<br>数值中必须包含一个小数点，并且小数点后面必须至少有一位数字.浮点数保存空间是整数的两倍，如果小数点后的值为0或者没有任何数值，那么该数值就会保存成整数<br>用e或E表示10的幂。<code>2e5</code>,浮点数的最高精度为17位。算术运算的时候，精度比整数差的多。不要测试浮点数相等。<br>2、最值：<code>Number.MIN_VALUE, Number.MAX_VALUE</code><br>3、NaN：<br>该值表示一个本来要返回Number类型的操作数未返回数值的情况。<br>设计NaN的所有操作都等于NaN，且NaN与任何值都不想等，包括NaN<br>isNaN()函数,用来判断一个值是否为数值（number）<br>isNaN也适用于对象，在判断对象的时候，会先调用对象的valueOf()方法，确定该返回值是否是数值，如果不行，会调用toString()方法，再判断是否是数值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>()</span><br></pre></td></tr></table></figure></p><p>4、数值转换<br>有3个方法可以将非数值类型的值转换成数值类型：Number() parseInt()  parseFloat()。<br>Number()方法可以将任何数值类型转化成数值类型，其他两个需要字符串类型<br>Number()转换规则：</p><ul><li>Boolean的值，true转换成1， false转化成0</li><li>null 转化成0</li><li>undefined 转化成NaN</li><li>String变量 <ul><li>是整数的转换成十进制整数，前导0将被去掉</li><li>浮点数将被转化成浮点数，前导0将被去掉</li><li>十六进制的数值将被转换成十进制相同大小的值</li><li>空字符串将被转换成0</li><li>其他的将被转换成NaN</li></ul></li><li>Object对象 会先调用对象的valueOf()方法，确定该返回值是否是数值，如果NaN，会调用toString()方法，再按照string方法判断。<br>parseInt()转换规则<br>转换字符串，从第一个非空格字符开始，是数字或者进制符号就继续下一个字符。否则就NaN<br>浮点数转化成整数，空字符串转化成NaN<br><code>parseInt(&#39;&#39;) = NaN</code><br>parseFloat()转化规则<br>从第一个字符开始判断，知道遇到非浮点数字符。<br>第一个小数点有效，其他的则无效。<br>16进制会被转化成0<br>忽略前导0</li></ul><h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><p>用于表示有0到多个16位Unicode字符组成的字符序列，即字符串。用’’或者””表示<br>1、字符字面量 即转义字符<br>2、字符串特点<br>  ES中，字符串一旦创建就不能改变，要改变就会销毁之前变量，然后生产新的变量。<br>3、转换成字符串<br>toString()方法<br>  Number，Boolean，Object，String都有这个方法，转换成相应的字符串。Null和Undefined没有这个方法。<br>  如果有toString()方法，那就调用该方法<br>  如果没有，null 转换成’null’,undefined 转换成’undefined’</p><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p>ES中的对象就是一组数据和功能的集合。对象可以通过new操作符后加名字的来创建<br><code>var o = new Object()</code><br>Object类型是所有它的实例的基础，其具有的属性，在其他所有的实例中都会有。<br>Object有的属性和方法</p><ul><li>constructor：保存用于创建当前对象的函数</li><li>hasOwnProperty(propertyName): 用于判断是否有属于自己的属性，而不是在原型中的属性</li><li>isPrototypeOf(object): 用于检查传入的对象是否是传入对象的原型</li><li>propertyIsEnumerable(propertyName)：用于检查属性能否用for-in来遍历</li><li>toLocaleString()：返回对象的字符串表示</li><li>toString(): 返回对象的字符串表示</li><li>valueOf()：返回对象的字符串，数值，布尔表示，通常和toString()结果一样。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JS高程的第三章第二节，对数据类型进行一下学习&lt;/p&gt;
&lt;p&gt;JS有五种基本数据类型：Number，String，Boolean，Undefined，Null和一种复杂类型：Object，Object本质上是由一组无序的名值对组成的（说好的万物皆对象来着）。JS不支持任何创
      
    
    </summary>
    
      <category term="JS高程填坑笔记" scheme="http://yoursite.com/categories/JS%E9%AB%98%E7%A8%8B%E5%A1%AB%E5%9D%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript基本概念（一）</title>
    <link href="http://yoursite.com/2018/06/11/Javascript%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/06/11/Javascript基本概念（一）/</id>
    <published>2018-06-11T04:51:06.000Z</published>
    <updated>2018-06-13T15:26:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是JS高程的第三章，内容比较多的一章，所以拆分开来，慢慢的填坑。<br>路漫漫其修远兮啊<br>本节包括三个部分</p><ul><li>JS语法</li><li>JS关键字</li><li>JS变量</li></ul><h2 id="JS语法"><a href="#JS语法" class="headerlink" title="JS语法"></a>JS语法</h2><p>1、JS中的一切(变量、函数名和操作符)都区分大小写<br>2、标识符，就是指变量、函数、属性的名字，或者函数的参数。第一个字符必须是一个字母、下划线(_)或一个美元符号($）;其他字符可以是字母、下划线、美元符号或数字<br>3、注释：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单行注释</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 这是一个多行 </span></span><br><span class="line"><span class="comment">* (块级)注释 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>4、严格模式<br>ECMAScript5引入了严格模式(strict mode)的概念。严格模式是为JavaScript定义了一种不同的解析与执行模型。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br></pre></td></tr></table></figure></p><p>它是一个编译指示(pragma)，用于告诉支持的JavaScript引擎切换到严格模式。这是为不破坏ECMAScript 3语法而特意选定的语法。<br>5、ECMAScript 中的语句以一个分号结尾;如果省略分号，则由解析器确定语句的结尾。建议在语句结尾处添加“;”</p><h2 id="关键字和保留字"><a href="#关键字和保留字" class="headerlink" title="关键字和保留字"></a>关键字和保留字</h2><p>1、关键字，可用于表示控制语句的开始或结束，或者用于执行特定操作等。按照规则，关键字也是语言保留的，不能用作标识符。<br>2、保留字，保留字在这门语言中还没有任何特定的用途，但它们有可能在将来被用作关键字。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>ECMAScript的变量是松散类型的，松散类型就是可以用来保存任何类型的数据。换句话说，每个变量仅仅是一个用于保存值的占位符而已。ECMAScript 也支持直接初始化变量，因此在定义变量的同时就可以设置变量的值<br>用var操作符定义的变量将成为定义该变量的作用域中的局部变量。也就是说，如果在函数中使用var定义一个变量，那么这个变量在函数退出后就会被销毁。<br>（块级作用域中可以使用let 和 const来声明块级变量，形成暂时性死区）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是JS高程的第三章，内容比较多的一章，所以拆分开来，慢慢的填坑。&lt;br&gt;路漫漫其修远兮啊&lt;br&gt;本节包括三个部分&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JS语法&lt;/li&gt;
&lt;li&gt;JS关键字&lt;/li&gt;
&lt;li&gt;JS变量&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;JS语法&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="JS高程填坑笔记" scheme="http://yoursite.com/categories/JS%E9%AB%98%E7%A8%8B%E5%A1%AB%E5%9D%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>在HTML中使用JS</title>
    <link href="http://yoursite.com/2018/06/10/%E5%9C%A8HTML%E4%B8%AD%E4%BD%BF%E7%94%A8JS/"/>
    <id>http://yoursite.com/2018/06/10/在HTML中使用JS/</id>
    <published>2018-06-10T14:20:34.000Z</published>
    <updated>2018-06-10T15:06:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是js高程的第二章，主要讲的内容就是怎样在HTML中使用javascript。<br>这章的内容包含四个部分：</p><ul><li>&lt;script&gt; 标签</li><li>嵌入脚本和外部脚本</li><li>文档模式的影响</li><li>禁用javascript的场景</li></ul><h2 id="lt-script-gt-标签"><a href="#lt-script-gt-标签" class="headerlink" title="&lt;script&gt; 标签"></a>&lt;script&gt; 标签</h2><p>向HTML页面中插入JavaScript的主要方法，就是使用&lt;script&gt;元素。<br>html 4.01给script标签定义了以下属性</p><ul><li>async 异步标签，表示应该立即下载脚本，但不应妨碍页面中的其他操作。该属性只对外部脚本文件有效。但是，标记为async的脚本并不保证按照script排列的先后顺序执行。异步脚本一定会在页面的load事件前执行，但可能会在DOMContentLoaded事件触发之前或之后执行。</li><li>charset:表示通过 src 属性指定的代码的字符集。由于大多数浏览器会忽略它的值，因此这个属性很少有人用。</li><li><p>defer:表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。脚本会被延迟到整个页面都解析完毕后再运行。HTML5规范要求脚本按照它们出现的先后顺序执行，因此第一个延迟脚本会先于第二个延迟脚本执行，而这两个脚本会先于DOMContentLoaded事件执行。但是在现实当中，延迟脚本并不一定会按照顺序执行，也不一定会在 DOMContentLoaded事件触发前执行，因此最好只包含一个延迟脚本。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script defer=<span class="string">"defer"</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p>src:表示包含要执行代码的外部文件。如果要通过&lt;script&gt;元素来包含外部JavaScript文件，那么src 属性就是必需的。这个属性的值是一个指向外部JavaScript文件的链接。<br>需要注意的是，带有src属性的&lt;script&gt;元素不应该在其&lt;script&gt;和&lt;script&gt;标签之间再 包含额外的JavaScript代码。如果包含了嵌入的代码，则只会下载并执行外部脚本文件，嵌入的代码会被忽略。<br>通过&lt;script&gt;元素的 src 属性还可以包含来自外部域的 JavaScript 文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"example.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>type:type 属性规定脚本的MIME类型。type属性标示 &lt;script&gt;与&lt;/script&gt;标签之间的内容。MIME类型包括两部分：media type 和 subtype。对于JavaScript，MIME 类型是 “text/javascript”。在 HTML5中，type属性不再是必需的。默认值是”text/javascript”。</p></li></ul><h2 id="嵌入脚本和外部脚本"><a href="#嵌入脚本和外部脚本" class="headerlink" title="嵌入脚本和外部脚本"></a>嵌入脚本和外部脚本</h2><p>使用&lt;script&gt;元素的方式有两种:直接在页面中嵌入JavaScript代码和包含外部 JavaScript文件。无论如何包含代码，只要不存在defer和async属性，浏览器都会按照&lt;script&gt;元素在页面中 出现的先后顺序对它们依次进行解析。</p><p>外部脚本的优势：<br> 可维护性<br> 可缓存: 浏览器能够根据具体的设置缓存链接的所有外部 JavaScript 文件<br> 适应未来</p><h2 id="文档模式的影响"><a href="#文档模式的影响" class="headerlink" title="文档模式的影响"></a>文档模式的影响</h2><p>最初的两种文档模式是:混杂模式(quirks mode)和标准模式(standards mode)。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML 4.01 严格型 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- HTML 5 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="禁用javascript的场景"><a href="#禁用javascript的场景" class="headerlink" title="禁用javascript的场景"></a>禁用javascript的场景</h2><p>关于禁用javascript的场景，主要是&lt;noscript&gt;<br>这个元素可以包含能够出现在文档&lt;body&gt;中的任何 HTML 元素——&lt;script&gt;元素除外。包含 在&lt;noscript&gt;元素中的内容只有在下列情况下才会显示出来:<br> 浏览器不支持脚本;<br> 浏览器支持脚本，但脚本被禁用。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Example HTML Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">noscript</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>本页面需要浏览器支持(启用)JavaScript。</span><br><span class="line">    <span class="tag">&lt;/<span class="name">noscript</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">defer</span>=<span class="string">"defer"</span> <span class="attr">src</span>=<span class="string">"example1.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">defer</span>=<span class="string">"defer"</span> <span class="attr">src</span>=<span class="string">"example2.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>把 JavaScript 插入到 HTML 页面中要使用&lt;script&gt;元素。使用这个元素可以把 JavaScript 嵌入到 HTML 页面中，让脚本与标记混合在一起;也可以包含外部的 JavaScript 文件。而我们需要注意的地方有:<br> 在包含外部 JavaScript 文件时，必须将 src 属性设置为指向相应文件的 URL。而这个文件既可 以是与包含它的页面位于同一个服务器上的文件，也可以是其他任何域中的文件。<br> 所有&lt;script&gt;元素都会按照它们在页面中出现的先后顺序依次被解析。在不使用 defer 和 async 属性的情况下，只有在解析完前面&lt;script&gt;元素中的代码之后，才会开始解析后面 &lt;script&gt;元素中的代码。<br> 由于浏览器会先解析完不使用 defer 属性的&lt;script&gt;元素中的代码，然后再解析后面的内容， 所以一般应该把&lt;script&gt;元素放在页面最后，即主要内容后面，&lt;／body&gt;标签前面。<br> 使用 defer 属性可以让脚本在文档完全呈现之后再执行。延迟脚本总是按照指定它们的顺序执行。<br> 使用 async 属性可以表示当前脚本不必等待其他脚本，也不必阻塞文档呈现。不能保证异步脚<br>本按照它们在页面中出现的顺序执行。 另外，使用&lt;noscript&gt;元素可以指定在不支持脚本的浏览器中显示的替代内容。但在启用了脚本的情况下，浏览器不会显示&lt;noscript&gt;元素中的任何内容。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是js高程的第二章，主要讲的内容就是怎样在HTML中使用javascript。&lt;br&gt;这章的内容包含四个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;lt;script&amp;gt; 标签&lt;/li&gt;
&lt;li&gt;嵌入脚本和外部脚本&lt;/li&gt;
&lt;li&gt;文档模式的影响&lt;/li&gt;
&lt;li&gt;禁用ja
      
    
    </summary>
    
      <category term="JS高程填坑笔记" scheme="http://yoursite.com/categories/JS%E9%AB%98%E7%A8%8B%E5%A1%AB%E5%9D%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>window.location的属性</title>
    <link href="http://yoursite.com/2018/06/10/window.location%E7%9A%84%E5%B1%9E%E6%80%A7/"/>
    <id>http://yoursite.com/2018/06/10/window.location的属性/</id>
    <published>2018-06-10T03:23:35.000Z</published>
    <updated>2018-06-10T03:42:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>关于http的相关的BOM的问题</p><p>获取当前url的协议<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> protocol = <span class="built_in">window</span>.location.protocol;</span><br></pre></td></tr></table></figure></p><p>获取当前的host和端口号<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> host = <span class="built_in">window</span>.location.host;</span><br></pre></td></tr></table></figure></p><p>获取当前完整的URL<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> host = <span class="built_in">window</span>.location.href;</span><br></pre></td></tr></table></figure></p><p>获取当前pathName<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> host = <span class="built_in">window</span>.location.pathname;</span><br></pre></td></tr></table></figure></p><p>获取当前url的查找内容<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> host = <span class="built_in">window</span>.location.search;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于http的相关的BOM的问题&lt;/p&gt;
&lt;p&gt;获取当前url的协议&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;
      
    
    </summary>
    
      <category term="bug汇总" scheme="http://yoursite.com/categories/bug%E6%B1%87%E6%80%BB/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>CSS占坑</title>
    <link href="http://yoursite.com/2018/05/29/CSS%E5%8D%A0%E5%9D%91/"/>
    <id>http://yoursite.com/2018/05/29/CSS占坑/</id>
    <published>2018-05-29T10:15:44.000Z</published>
    <updated>2018-05-29T10:19:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>占个坑就留着回家写吧～哈哈哈</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;占个坑就留着回家写吧～哈哈哈&lt;/p&gt;

      
    
    </summary>
    
      <category term="Glory Road" scheme="http://yoursite.com/categories/Glory-Road/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="http://yoursite.com/2018/05/28/%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/05/28/链表/</id>
    <published>2018-05-28T08:20:40.000Z</published>
    <updated>2018-05-28T08:43:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>链表是由一组节点组成的集合。每一个节点都使用一个对象的引用指向它的后续借点。指向另外一个节点的引用叫做链。<br>链表元素则是靠相互之间的关系进行引用。在链表中就说这个元素是某个元素的后面一个元素。遍历链表就是跟着链表从链表的头元素（head）一直走到尾元素（但是不包含链表的头节点，头通常用来作为链表的接入点）。链表的尾元素指向一个null节点。<br><img src="https://images2015.cnblogs.com/blog/72678/201609/72678-20160917225805820-1415213828.png" alt="链表的结构"></p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>单链表<br>（见定义）</p><p>循环链表<br>循环链表的运算与单链表的运算基本一致。所不同的有以下几点：<br>1、在建立一个循环链表时，必须使其最后一个结点的指针指向表头结点，而不是象单链表那样置为NULL。此种情况还使用于在最后一个结点后插入一个新的结点。<br>2、在判断是否到表尾时，是判断该结点链域的值是否是表头结点，当链域值等于表头指针时，说明已到表尾。而非象单链表那样判断链域值是否为NULL。</p><p>双向链表<br>双向链表其实是单链表的改进。<br>当我们对单链表进行操作时，有时你要对某个结点的直接前驱进行操作时，又必须从表头开始查找。这是由单链表结点的结构所限制的。因为单链表每个结点只有一个存储直接后继结点地址的链域，那么能不能定义一个既有存储直接后继结点地址的链域，又有存储直接前驱结点地址的链域的这样一个双链域结点结构呢？这就是双向链表。<br>在双向链表中，结点除含有数据域外，还有两个链域，一个存储直接后继结点地址，一般称之为右链域；一个存储直接前驱结点地址，一般称之为左链域。</p><h2 id="链表的操作"><a href="#链表的操作" class="headerlink" title="链表的操作"></a>链表的操作</h2><p>链表的操作通常需要操作两个节点，例如，向链表中插入一个节点，需要修改它前面的节点，使其指向新加入的节点，而新加入的节点则指向前面指向的节点<br>从链表中删除一个节点也很简单，将待删除的元素的前驱节点指向待删除的后续节点，同时将待删除元素指向null来释放。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Definition for singly-linked list.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ListNode</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.val = val;</span><br><span class="line">  <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> findListNode = <span class="function">(<span class="params">listNode, target</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">while</span>(listNode) &#123;</span><br><span class="line">    <span class="keyword">if</span> (listNode.val === target) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    listNode = listNode.next ? listNode.next : <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="string">"not hava this target"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>插入<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在第target个元素后添加一个节点</span></span><br><span class="line"><span class="keyword">const</span> insertListNode = <span class="function">(<span class="params">listNode1, node, target</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> count = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span>(listNode) &#123;</span><br><span class="line">    <span class="keyword">if</span> (count === target) &#123;</span><br><span class="line">      node.next = listNode.next;</span><br><span class="line">      listNode.next = node</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    listNode = listNode.next ? listNode.next : <span class="literal">null</span></span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;链表是由一组节点组成的集合。每一个节点都使用一个对象的引用指向它的后续借点。指向另外一个节点的引用叫做链。&lt;br&gt;链表元素则是靠相互之间的关
      
    
    </summary>
    
      <category term="算法学习" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>html5语意化学习</title>
    <link href="http://yoursite.com/2018/05/28/html5%E8%AF%AD%E6%84%8F%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2018/05/28/html5语意化学习/</id>
    <published>2018-05-28T02:46:36.000Z</published>
    <updated>2018-05-28T03:54:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1>百度前端技术学院学习笔记（二）</h1><p>百度前端技术学院，第二天课程已经脱了好几天了，最近项目上线以及一些其他的事情，一只拖延着我这只拖延狗的进度。。今天终于抽出时间来整理一下这个知识点。</p><h2 id="目标简介"><a href="#目标简介" class="headerlink" title="目标简介"></a>目标简介</h2><ul><li>Date: 2018.05.28 Mon</li><li>Target: 熟悉html语意化。</li><li>Time: 1day</li></ul><h2 id="语意化探究"><a href="#语意化探究" class="headerlink" title="语意化探究"></a>语意化探究</h2><p>语意化，就是根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。那通俗一点来说，就是为了让编写让人和机器都认识的代码。</p><p>语意化的意义</p><ul><li>为了在没有样式的时候，页面也能呈现出很好地内容结构、代码结构</li><li>更好的用户体验</li><li>便于SEO</li><li>方便其他设备解析</li><li>便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。</li></ul><p>部分语意化标签</p><table><thead><tr><th style="text-align:center">标签</th><th style="text-align:center">意义</th><th style="text-align:center">用法 </th></tr></thead><tbody><tr><td style="text-align:center">header</td><td style="text-align:center">头部标签</td><td style="text-align:center">用于网页顶部，作为头部</td></tr><tr><td style="text-align:center">footer</td><td style="text-align:center">底部标签</td><td style="text-align:center">用于网页底部，内容多相关信息</td></tr><tr><td style="text-align:center">hgroup</td><td style="text-align:center">网页标签</td><td style="text-align:center">网页或者含有多个h标签的</td></tr><tr><td style="text-align:center">nav</td><td style="text-align:center">导航标签</td><td style="text-align:center">放置导航栏</td></tr><tr><td style="text-align:center">aside</td><td style="text-align:center">侧栏标签</td><td style="text-align:center">侧边栏的内容</td></tr><tr><td style="text-align:center">section</td><td style="text-align:center">区块的标签</td><td style="text-align:center">一个独立的区域</td></tr><tr><td style="text-align:center">article</td><td style="text-align:center">文章标签</td><td style="text-align:center">一片文章的区域</td></tr><tr><td style="text-align:center">h1-h6</td><td style="text-align:center">标题标签</td><td style="text-align:center">按照标题的大小选择</td></tr><tr><td style="text-align:center">p</td><td style="text-align:center">段落标签</td><td style="text-align:center">一个段落</td></tr><tr><td style="text-align:center">audio</td><td style="text-align:center">声音标签</td><td style="text-align:center">用来链接音频</td></tr><tr><td style="text-align:center">video</td><td style="text-align:center">视频标签</td><td style="text-align:center">用来链接视频</td></tr></tbody></table><h2 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h2><p>Q1: HTML是什么，HTML5是什么？<br>A1: 超级文本标记语言是标准通用标记语言下的一个应用，也是一种规范，一种标准，它通过标记符号来标记要显示的网页中的各个部分。HTML5是HTML的第五次修改，HTML5的革新之一：语义化标签一节元素标签。</p><p>Q2: HTML元素标签、属性都是什么概念？<br>A2: HTML的标签就是一个个网页的结构元素，一个网页是由一个个元素组合起来的。属性是标签的一些性质，包括ID、名称、URI、数字、长度单位、语言、媒体描述符、颜色、字符编码、日期和时间等。</p><p>Q3: 文档类型是什么概念，起什么作用？<br>A3: 文档类型有严格模式和非严格模式，应用严格模式来编写页面，更严谨。H5没有文档类型。</p><p>Q4: meta标签都用来做什么的？<br>A4: 元素可提供相关页面的元信息（meta-information），标签位于文档的头部，不包含任何内容。标签的属性定义了与文档相关联的名称/值对。</p><ul><li>meta标签共有两个属性，它们分别是http-equiv属性和name属性，不同的属性又有不同的参数值，这些不同的参数值就实现了不同的网页功能。</li><li>meta 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。</li><li>meta 标签位于文档的头部，不包含任何内容。</li><li>meta 标签的属性定义了与文档相关联的名称/值对。</li></ul><p>Q5: Web语义化是什么，是为了解决什么问题<br>A5：就是根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析<br>解决了SEO等问题</p><p>Q6: 链接是什么概念，对应什么标签？<br>A6: 是支持浏览器文档与外部资源的关系。对应link标签</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;百度前端技术学院学习笔记（二）&lt;/h1&gt;

&lt;p&gt;百度前端技术学院，第二天课程已经脱了好几天了，最近项目上线以及一些其他的事情，一只拖延着我这只拖延狗的进度。。今天终于抽出时间来整理一下这个知识点。&lt;/p&gt;
&lt;h2 id=&quot;目标简介&quot;&gt;&lt;a href=&quot;#目标简介&quot; cl
      
    
    </summary>
    
      <category term="Glory Road" scheme="http://yoursite.com/categories/Glory-Road/"/>
    
    
      <category term="html" scheme="http://yoursite.com/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>插入排序</title>
    <link href="http://yoursite.com/2018/05/25/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/05/25/插入排序/</id>
    <published>2018-05-25T08:07:55.000Z</published>
    <updated>2018-05-25T08:12:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，但将最后一个元素除外（让数组多一个空间才有插入的位置），而第二部分就只包含这一个元素（即待插入元素）。在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。<br>插入排序的基本思想是：每步将一个待排序的记录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。</p><p>直接插入排序的算法思路：<br>（1） 设置监视哨r[0]，将待插入记录的值赋值给r[0]；<br>（2） 设置开始查找的位置j；<br>（3） 在数组中进行搜索，搜索中将第j个记录后移，直至r[0].key≥r[j].key为止；<br>（4） 将r[0]插入r[j+1]的位置上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> insertionSort = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> len = arr.length;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;len; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> j = i;</span><br><span class="line">    <span class="keyword">let</span> tmp = arr[i];</span><br><span class="line">    <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; arr[j<span class="number">-1</span>] &gt; tmp) &#123;</span><br><span class="line">        arr[j] = arr[j<span class="number">-1</span>];</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，但将最后一个元素除外（让数组多一个空
      
    
    </summary>
    
      <category term="算法学习" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>正则填坑</title>
    <link href="http://yoursite.com/2018/05/25/%E6%AD%A3%E5%88%99%E5%A1%AB%E5%9D%91/"/>
    <id>http://yoursite.com/2018/05/25/正则填坑/</id>
    <published>2018-05-25T05:58:47.000Z</published>
    <updated>2018-05-25T07:07:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1>正则表达式</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为”元字符”）。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>通过使用正则表达式，可以：<br>1、测试字符串内的模式。<br>例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。<br>替换文本。<br>2、可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。<br>基于模式匹配从字符串中提取子字符串。<br>3、可以查找文档内或输入域内特定的文本。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>正则表达式包含好多种字符，普通字符，非打印字符，特殊字符，限定符，定位符</p><p>元字符</p><table><thead><tr><th>字符</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td>\</td><td style="text-align:center">将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\n’ 匹配一个换行符。序列 ‘\‘ 匹配 “\” 而 “(“ 则匹配 “(“。</td></tr><tr><td>^</td><td style="text-align:center">匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。</td></tr><tr><td>$</td><td style="text-align:center">匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。</td></tr><tr><td>*</td><td style="text-align:center">匹配前面的子表达式零次或多次。例如，zo<em> 能匹配 “z” 以及 “zoo”。</em> 等价于{0,}。</td></tr><tr><td>+</td><td style="text-align:center">匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td></tr><tr><td>?</td><td style="text-align:center">匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 。? 等价于 {0,1}。</td></tr><tr><td>{n}</td><td style="text-align:center">n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td></tr><tr><td>{n,}</td><td style="text-align:center">n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td></tr><tr><td>{n,m}</td><td style="text-align:center">m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td></tr><tr><td>?</td><td style="text-align:center">当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。</td></tr><tr><td>.</td><td style="text-align:center">匹配除换行符（\n、\r）之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用像”(.\n)”的模式。</td></tr><tr><td>[xyz]</td><td style="text-align:center">字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。</td></tr><tr><td>[^xyz]</td><td style="text-align:center">负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’、’l’、’i’、’n’。</td></tr><tr><td>[a-z]</td><td style="text-align:center">字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。</td></tr><tr><td>[^a-z]</td><td style="text-align:center">负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。</td></tr><tr><td>\b</td><td style="text-align:center">匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</td></tr><tr><td>\B</td><td style="text-align:center">匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。</td></tr><tr><td>\cx</td><td style="text-align:center">匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td></tr><tr><td>\d</td><td style="text-align:center">匹配一个数字字符。等价于 [0-9]。</td></tr><tr><td>\D</td><td style="text-align:center">匹配一个非数字字符。等价于 [^0-9]。</td></tr><tr><td>\f</td><td style="text-align:center">匹配一个换页符。等价于 \x0c 和 \cL。</td></tr><tr><td>\n</td><td style="text-align:center">匹配一个换行符。等价于 \x0a 和 \cJ。</td></tr><tr><td>\r</td><td style="text-align:center">匹配一个回车符。等价于 \x0d 和 \cM。</td></tr><tr><td>\s</td><td style="text-align:center">匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。</td></tr><tr><td>\S</td><td style="text-align:center">匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td></tr><tr><td>\t</td><td style="text-align:center">匹配一个制表符。等价于 \x09 和 \cI。</td></tr><tr><td>\v</td><td style="text-align:center">匹配一个垂直制表符。等价于 \x0b 和 \cK。</td></tr><tr><td>\w</td><td style="text-align:center">匹配字母、数字、下划线。等价于’[A-Za-z0-9_]’。</td></tr><tr><td>\W</td><td style="text-align:center">匹配非字母、数字、下划线。等价于 ‘[^A-Za-z0-9_]’。</td></tr><tr><td>\xn</td><td style="text-align:center">匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，’\x41’ 匹配 “A”。’\x041’ 则等价于 ‘\x04’ &amp; “1”。正则表达式中可以使用 ASCII 编码。</td></tr><tr><td>\num</td><td style="text-align:center">匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，’(.)\1’ 匹配两个连续的相同字符。</td></tr><tr><td>\n</td><td style="text-align:center">标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。</td></tr><tr><td>\nm</td><td style="text-align:center">标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。</td></tr><tr><td>\nml</td><td style="text-align:center">如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。</td></tr><tr><td>\un</td><td style="text-align:center">匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。</td></tr></tbody></table><p><img src="https://github.com/kaisa911/studyNotes/blob/master/public/image/reg.png?raw=true" alt="其他"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;正则表达式&lt;/h1&gt;

&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>放飞的thinking～</title>
    <link href="http://yoursite.com/2018/05/24/%E6%94%BE%E9%A3%9E%E7%9A%84thinking%EF%BD%9E/"/>
    <id>http://yoursite.com/2018/05/24/放飞的thinking～/</id>
    <published>2018-05-24T08:53:09.000Z</published>
    <updated>2018-05-28T02:55:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1>百度前端技术学院学习笔记（一）</h1><h2 id="目标简介"><a href="#目标简介" class="headerlink" title="目标简介"></a>目标简介</h2><ul><li>Date: 2018.05.24 Thr</li><li>Flag: 真男人就坚持66天。</li><li>Target: 了解前端。</li><li>Time: 1h</li></ul><h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><p>1、什么是前端？<br>  前端这个概念，我觉得应该这么来理解，<b>前</b>：表示与用户直接有关的部分，比如页面的展示，与用户的交互等，<b>端</b>：是终端的部分，包括pc，移动端以及其他的一些可以与用于交互的终端。<br>  从百度百科上看到了前端的解释：<br>  <blockquote>前端即网站前台部分，运行在PC端，移动端等浏览器上展现给用户浏览的网页。随着互联网技术的发展，HTML5，CSS3，前端框架的应用，跨平台响应式网页设计能够适应各种屏幕分辨率，完美的动效设计，给用户带来极高的用户体验。</blockquote><br>  感觉差不多吧…</p><p>2、什么是html？<br>  <blockquote>html：超文本标记语言，标准通用标记语言下的一个应用。</blockquote><br>  我理解的是，用来构建页面的骨架的语言。<br>  html提供了语义化的标签，以及相关的属性，根据标签和属性以及内容构建页面的骨架。</p><p>3、什么是CSS？<br>  <blockquote>CSS：层叠样式表(英文全称：Cascading Style Sheets)是一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的计算机语言。CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。</blockquote><br>  CSS，可以理解成骨架的衣服，好的页面有了骨架还不行，还得需要漂亮的衣服。html写好了骨架，通过写CSS来写样式，让页面变得更好看。</p><p>4、什么是Javascript？<br>  <blockquote>JavaScript一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加动态功能。</blockquote><br>  js是一种脚本语言，可以给页面添加交互，以及相关的逻辑，还有和后台通过接口交互数据等。</p><h2 id="课程疑问"><a href="#课程疑问" class="headerlink" title="课程疑问"></a>课程疑问</h2><p>1、现在背景下的大前端该如何发展？<br>2、框架的不断推出，框架的学习和个人技能的发展的均衡？<br>3、因为node的存在，前端工程师往全栈工程师的发展是否成为必要？</p><p></p><h1>总结</h1><br>学习前端有一年的时间了，半路出家，从机械转到了前端。从开始写外包，囫囵吞枣，会用就行，到工作之后，发现自己欠缺的东西还有好多好多。开始逐渐的弥补自己的知识。<br>虽然起步比较晚，但是还是很喜欢js这个不断进步的语言～<br>希望能够通过自己的努力，成为一个真正的FE developer！<p></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;百度前端技术学院学习笔记（一）&lt;/h1&gt;

&lt;h2 id=&quot;目标简介&quot;&gt;&lt;a href=&quot;#目标简介&quot; class=&quot;headerlink&quot; title=&quot;目标简介&quot;&gt;&lt;/a&gt;目标简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Date: 2018.05.24 Thr&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="Glory Road" scheme="http://yoursite.com/categories/Glory-Road/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
      <category term="html" scheme="http://yoursite.com/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>koa2源码学习--application.js</title>
    <link href="http://yoursite.com/2018/05/24/koa2%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0--application.js/"/>
    <id>http://yoursite.com/2018/05/24/koa2源码学习--application.js/</id>
    <published>2018-05-24T06:00:14.000Z</published>
    <updated>2018-05-25T05:58:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>一直很想研究下koa2，虽然还是小白一枚，但终于决定入坑koa2。之前只知道koa2采用了ES2015和ES2016的一些东西，还知道洋葱头的中间件的运行机制。还是先研究一下源码，学习一下大神写代码的畅快感。</p><p>把代码拉下来之后，发现lib里只有四个源码文件：application.js, context.js, request.js, response.js。</p><p>application.js 是koa的入口文件,是一个构造函数，它暴露整个应用的class, 这个class继承自node自带的events，并且把 context、request 和 response 属性指向了原型链指向其他三个文件导出对象的实例。</p><p>application暴露了一些公用的api, 比如listen，use, callback等。</p><p>下面来研究一些application.js的源码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 依赖的模块</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isGeneratorFunction = <span class="built_in">require</span>(<span class="string">'is-generator-function'</span>); <span class="comment">//判断函数是否为generator函数</span></span><br><span class="line"><span class="keyword">const</span> debug = <span class="built_in">require</span>(<span class="string">'debug'</span>)(<span class="string">'koa:application'</span>); <span class="comment">//调试模式</span></span><br><span class="line"><span class="keyword">const</span> onFinished = <span class="built_in">require</span>(<span class="string">'on-finished'</span>); <span class="comment">//HTTP请求关闭，完成或错误时执行回调。</span></span><br><span class="line"><span class="keyword">const</span> response = <span class="built_in">require</span>(<span class="string">'./response'</span>); <span class="comment">//reponse.js</span></span><br><span class="line"><span class="keyword">const</span> compose = <span class="built_in">require</span>(<span class="string">'koa-compose'</span>); <span class="comment">//koa中间件组合工具</span></span><br><span class="line"><span class="keyword">const</span> isJSON = <span class="built_in">require</span>(<span class="string">'koa-is-json'</span>); <span class="comment">//检查body应该是一个json格式</span></span><br><span class="line"><span class="keyword">const</span> context = <span class="built_in">require</span>(<span class="string">'./context'</span>); <span class="comment">//上下文context.js</span></span><br><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">'./request'</span>); <span class="comment">//request.js</span></span><br><span class="line"><span class="keyword">const</span> statuses = <span class="built_in">require</span>(<span class="string">'statuses'</span>); <span class="comment">////http状态工具status(403) // =&gt; 'Forbidden'，可以通过code转换成msg，也可以通过msg转换成code</span></span><br><span class="line"><span class="keyword">const</span> Cookies = <span class="built_in">require</span>(<span class="string">'cookies'</span>); <span class="comment">//提供一个读写cookie的API</span></span><br><span class="line"><span class="keyword">const</span> accepts = <span class="built_in">require</span>(<span class="string">'accepts'</span>); <span class="comment">//一个比较高级的API用来http处理请求中的接受类型，</span></span><br><span class="line"><span class="keyword">const</span> Emitter = <span class="built_in">require</span>(<span class="string">'events'</span>); <span class="comment">//node的events模块？</span></span><br><span class="line"><span class="keyword">const</span> assert = <span class="built_in">require</span>(<span class="string">'assert'</span>); <span class="comment">//通过状态码进行断言？</span></span><br><span class="line"><span class="keyword">const</span> Stream = <span class="built_in">require</span>(<span class="string">'stream'</span>); <span class="comment">//流文件？</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>); <span class="comment">// node的http模块？</span></span><br><span class="line"><span class="keyword">const</span> only = <span class="built_in">require</span>(<span class="string">'only'</span>); <span class="comment">//返回白名单中的值。其实就是根据一个列表获取一个对象中的部分属性返回一个obj</span></span><br><span class="line"><span class="keyword">const</span> convert = <span class="built_in">require</span>(<span class="string">'koa-convert'</span>); <span class="comment">//提供function *的语法的转换器</span></span><br><span class="line"><span class="keyword">const</span> deprecate = <span class="built_in">require</span>(<span class="string">'depd'</span>)(<span class="string">'koa'</span>); <span class="comment">//提示？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 暴露一个application的类</span></span><br><span class="line"><span class="comment"> * 继承自 `Emitter.prototype`.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="title">Application</span> <span class="keyword">extends</span> <span class="title">Emitter</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 初始化一个新的 `Application`.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @api public</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义下面的属性</span></span><br><span class="line">    <span class="keyword">this</span>.proxy = <span class="literal">false</span>; <span class="comment">//代理</span></span><br><span class="line">    <span class="keyword">this</span>.middleware = []; <span class="comment">//中间件的队列</span></span><br><span class="line">    <span class="keyword">this</span>.subdomainOffset = <span class="number">2</span>; <span class="comment">//对于要忽略的 .subdomains 偏移[2]</span></span><br><span class="line">    <span class="keyword">this</span>.env = process.env.NODE_ENV || <span class="string">'development'</span>; <span class="comment">//env默认是 NODE_ENV 或 "development"</span></span><br><span class="line">    <span class="keyword">this</span>.context = <span class="built_in">Object</span>.create(context); <span class="comment">//创建一个新context对象，使用context对象来提供新创建的对象的__proto__。 </span></span><br><span class="line">    <span class="keyword">this</span>.request = <span class="built_in">Object</span>.create(request);<span class="comment">//创建一个新request对象</span></span><br><span class="line">    <span class="keyword">this</span>.response = <span class="built_in">Object</span>.create(response);<span class="comment">//创建一个新response对象</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Shorthand for:</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   *    http.createServer(app.callback()).listen(...)</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @param &#123;Mixed&#125; ...</span></span><br><span class="line"><span class="comment">   * @return &#123;Server&#125;</span></span><br><span class="line"><span class="comment">   * @api public</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//listen(),调用node的createServer方法，返回一个服务器。参数为端口号，</span></span><br><span class="line">  listen(...args) &#123;</span><br><span class="line">    debug(<span class="string">'listen'</span>);</span><br><span class="line">    <span class="keyword">const</span> server = http.createServer(<span class="keyword">this</span>.callback());<span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> server.listen(...args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Return JSON representation.</span></span><br><span class="line"><span class="comment">   * We only bother showing settings.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @return &#123;Object&#125;</span></span><br><span class="line"><span class="comment">   * @api public</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//toJSON 方法，通过only方法，把key放到obj里 返回一个object对象</span></span><br><span class="line">  toJSON() &#123;</span><br><span class="line">    <span class="keyword">return</span> only(<span class="keyword">this</span>, [</span><br><span class="line">      <span class="string">'subdomainOffset'</span>,</span><br><span class="line">      <span class="string">'proxy'</span>,</span><br><span class="line">      <span class="string">'env'</span></span><br><span class="line">    ]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Inspect implementation.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @return &#123;Object&#125;</span></span><br><span class="line"><span class="comment">   * @api public</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">//检查,返回一个object对象</span></span><br><span class="line">  inspect() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.toJSON();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 把给定的中间件函数fn，推入到middleware队列中</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 以前写法的中间件将会被转换</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @param &#123;Function&#125; fn</span></span><br><span class="line"><span class="comment">   * @return &#123;Application&#125; self</span></span><br><span class="line"><span class="comment">   * @api public</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  use(fn) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">'function'</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'middleware must be a function!'</span>);</span><br><span class="line">    <span class="keyword">if</span> (isGeneratorFunction(fn)) &#123;</span><br><span class="line">      deprecate(<span class="string">'Support for generators will be removed in v3. '</span> +</span><br><span class="line">                <span class="string">'See the documentation for examples of how to convert old middleware '</span> +</span><br><span class="line">                <span class="string">'https://github.com/koajs/koa/blob/master/docs/migration.md'</span>);</span><br><span class="line">      fn = convert(fn);</span><br><span class="line">    &#125;</span><br><span class="line">    debug(<span class="string">'use %s'</span>, fn._name || fn.name || <span class="string">'-'</span>);</span><br><span class="line">    <span class="keyword">this</span>.middleware.push(fn);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Return a request handler callback</span></span><br><span class="line"><span class="comment">   * for node's native http server.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @return &#123;Function&#125;</span></span><br><span class="line"><span class="comment">   * @api public</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回适用于 http.createServer() 方法的回调函数来处理请求。</span></span><br><span class="line">  <span class="comment">//启动server和接收请求</span></span><br><span class="line">  callback() &#123;</span><br><span class="line">    <span class="keyword">const</span> fn = compose(<span class="keyword">this</span>.middleware);<span class="comment">//启动server时执行，初始化中间件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.listenerCount(<span class="string">'error'</span>)) <span class="keyword">this</span>.on(<span class="string">'error'</span>, <span class="keyword">this</span>.onerror);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收请求时执行处理请求的函数</span></span><br><span class="line">    <span class="keyword">const</span> handleRequest = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> ctx = <span class="keyword">this</span>.createContext(req, res);<span class="comment">//创建一个最终可用的context</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.handleRequest(ctx, fn);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> handleRequest;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * callback里的一个处理请求的方法，</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @api private</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  handleRequest(ctx, fnMiddleware) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = ctx.res;</span><br><span class="line">    res.statusCode = <span class="number">404</span>;</span><br><span class="line">    <span class="keyword">const</span> onerror = <span class="function"><span class="params">err</span> =&gt;</span> ctx.onerror(err);</span><br><span class="line">    <span class="keyword">const</span> handleResponse = <span class="function"><span class="params">()</span> =&gt;</span> respond(ctx);</span><br><span class="line">    onFinished(res, onerror);</span><br><span class="line">    <span class="keyword">return</span> fnMiddleware(ctx).then(handleResponse).catch(onerror);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Initialize a new context.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @api private</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  createContext(req, res) &#123;</span><br><span class="line">    <span class="keyword">const</span> context = <span class="built_in">Object</span>.create(<span class="keyword">this</span>.context);</span><br><span class="line">    <span class="keyword">const</span> request = context.request = <span class="built_in">Object</span>.create(<span class="keyword">this</span>.request);</span><br><span class="line">    <span class="keyword">const</span> response = context.response = <span class="built_in">Object</span>.create(<span class="keyword">this</span>.response);</span><br><span class="line">    context.app = request.app = response.app = <span class="keyword">this</span>;</span><br><span class="line">    context.req = request.req = response.req = req;</span><br><span class="line">    context.res = request.res = response.res = res;</span><br><span class="line">    request.ctx = response.ctx = context;</span><br><span class="line">    request.response = response;</span><br><span class="line">    response.request = request;</span><br><span class="line">    context.originalUrl = request.originalUrl = req.url;</span><br><span class="line">    context.cookies = <span class="keyword">new</span> Cookies(req, res, &#123;</span><br><span class="line">      keys: <span class="keyword">this</span>.keys,</span><br><span class="line">      secure: request.secure</span><br><span class="line">    &#125;);</span><br><span class="line">    request.ip = request.ips[<span class="number">0</span>] || req.socket.remoteAddress || <span class="string">''</span>;</span><br><span class="line">    context.accept = request.accept = accepts(req);</span><br><span class="line">    context.state = &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Default error handler.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @param &#123;Error&#125; err</span></span><br><span class="line"><span class="comment">   * @api private</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  onerror(err) &#123;</span><br><span class="line">    assert(err <span class="keyword">instanceof</span> <span class="built_in">Error</span>, <span class="string">`non-error thrown: <span class="subst">$&#123;err&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">404</span> == err.status || err.expose) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.silent) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> msg = err.stack || err.toString();</span><br><span class="line">    <span class="built_in">console</span>.error();</span><br><span class="line">    <span class="built_in">console</span>.error(msg.replace(<span class="regexp">/^/gm</span>, <span class="string">'  '</span>));</span><br><span class="line">    <span class="built_in">console</span>.error();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Response helper.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">respond</span>(<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// allow bypassing koa</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span> === ctx.respond) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> res = ctx.res;</span><br><span class="line">  <span class="keyword">if</span> (!ctx.writable) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> body = ctx.body;</span><br><span class="line">  <span class="keyword">const</span> code = ctx.status;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ignore body</span></span><br><span class="line">  <span class="keyword">if</span> (statuses.empty[code]) &#123;</span><br><span class="line">    <span class="comment">// strip headers</span></span><br><span class="line">    ctx.body = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> res.end();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'HEAD'</span> == ctx.method) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!res.headersSent &amp;&amp; isJSON(body)) &#123;</span><br><span class="line">      ctx.length = Buffer.byteLength(<span class="built_in">JSON</span>.stringify(body));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.end();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// status body</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">null</span> == body) &#123;</span><br><span class="line">    body = ctx.message || <span class="built_in">String</span>(code);</span><br><span class="line">    <span class="keyword">if</span> (!res.headersSent) &#123;</span><br><span class="line">      ctx.type = <span class="string">'text'</span>;</span><br><span class="line">      ctx.length = Buffer.byteLength(body);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.end(body);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// responses</span></span><br><span class="line">  <span class="keyword">if</span> (Buffer.isBuffer(body)) <span class="keyword">return</span> res.end(body);</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'string'</span> == <span class="keyword">typeof</span> body) <span class="keyword">return</span> res.end(body);</span><br><span class="line">  <span class="keyword">if</span> (body <span class="keyword">instanceof</span> Stream) <span class="keyword">return</span> body.pipe(res);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// body: json</span></span><br><span class="line">  body = <span class="built_in">JSON</span>.stringify(body);</span><br><span class="line">  <span class="keyword">if</span> (!res.headersSent) &#123;</span><br><span class="line">    ctx.length = Buffer.byteLength(body);</span><br><span class="line">  &#125;</span><br><span class="line">  res.end(body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一直很想研究下koa2，虽然还是小白一枚，但终于决定入坑koa2。之前只知道koa2采用了ES2015和ES2016的一些东西，还知道洋葱头的中间件的运行机制。还是先研究一下源码，学习一下大神写代码的畅快感。&lt;/p&gt;
&lt;p&gt;把代码拉下来之后，发现lib里只有四个源码文件：a
      
    
    </summary>
    
      <category term="koa2源码学习" scheme="http://yoursite.com/categories/koa2%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Koa" scheme="http://yoursite.com/tags/Koa/"/>
    
      <category term="Node" scheme="http://yoursite.com/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>react生命周期理解</title>
    <link href="http://yoursite.com/2018/05/22/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/05/22/react生命周期理解/</id>
    <published>2018-05-22T06:13:57.000Z</published>
    <updated>2018-05-24T08:29:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1>react组建的生命周期</h1><p>React组件的生命周期有两种情况，初次渲染和状态更新导致再次渲染。<br>React 生命周期分为三种状态 1. 挂载 2.更新 3.销毁</p><h2 id="组件加载"><a href="#组件加载" class="headerlink" title="组件加载"></a>组件加载</h2><p>组件的初次挂载，有以下几个步骤，分别是<br>1、构造函数，指定This，初始状态，绑定函数（constructor）<br>2、组件安装（componentWillMount）<br>3、将组建或者虚拟DOM元素渲染到真实的DOM上（render）<br>4、组件生成，DOM查找等(componentDidMount)</p><h2 id="组件更新"><a href="#组件更新" class="headerlink" title="组件更新"></a>组件更新</h2><p>组件的更新，有三种情况：<br>1.父组件的props发生更新<br>2.调用this.forceUpdate更新（重复componentWillUpdate方法之后的操作）<br>3.调用this.setState方法更新组件state,触发组件更新</p><h3 id="状态更新"><a href="#状态更新" class="headerlink" title="状态更新"></a>状态更新</h3><p>步骤：<br>1、构造函数，指定This，初始状态，绑定函数（constructor）<br>2、组件安装（componentWillMount）<br>3、将组建或者虚拟DOM元素渲染到真实的DOM上（render）<br>4、组件生成，DOM查找等(componentDidMount)<br>5、组建更新状态(componentWillUpdate)<br>6、将组建或者虚拟DOM元素渲染到真实的DOM上（render）<br>7、组建更新完成(componentDidUpdate)</p><h3 id="调用this-forceUpdate更新"><a href="#调用this-forceUpdate更新" class="headerlink" title="调用this.forceUpdate更新"></a>调用this.forceUpdate更新</h3><p>当组件调用forceUpdata方法更新时，会进入componentWillUpdate方法。<br>直接跳过shouldComponentUpdtavoid<br>之后执行render函数更新DOMReactElement<br>执行完render函数之后执行componentDidUpdata,<br>除了首次render之后调用componentDidMount，其它render结束之后都是调用componentDidUpdate。</p><h3 id="父组建更新props"><a href="#父组建更新props" class="headerlink" title="父组建更新props"></a>父组建更新props</h3><p>步骤：<br>1、父组件构造函数，指定This，初始状态，绑定函数（constructor）<br>2、父组件安装（componentWillMount）<br>3、父组件或者虚拟DOM元素渲染到真实的DOM上（render）<br>4、子组件或者虚拟DOM元素渲染到真实的DOM上（render）<br>5、父组件生成，DOM查找等(componentDidMount)<br>6、父组建更新状态(componentWillUpdate)<br>7、父组件或者虚拟DOM元素渲染到真实的DOM上（render）<br>8、子组件接收父组件props(componentWillReceiveProps)<br>9、子组件判断是否更新(shouldComponentUpdate)<br>10、子组建更新状态(componentWillUpdate)<br>11、子组件或者虚拟DOM元素渲染到真实的DOM上（render）<br>12、子组件更新完成(componentDidUpdate)<br>12、父组件更新完成(componentDidUpdate)</p><h2 id="组件销毁"><a href="#组件销毁" class="headerlink" title="组件销毁"></a>组件销毁</h2><p>单页应用中，切换页面原组件需要销毁释放资源，如果原组件中有定时器等不能销毁时，需要在componentWillUnmount中清理资源占用，手动销毁定时器。</p><h1>总结</h1><p><img src="https://github.com/kaisa911/studyNotes/blob/master/public/image/reactLifeCycle.png?raw=true" alt="react生命周期"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;react组建的生命周期&lt;/h1&gt;

&lt;p&gt;React组件的生命周期有两种情况，初次渲染和状态更新导致再次渲染。&lt;br&gt;React 生命周期分为三种状态 1. 挂载 2.更新 3.销毁&lt;/p&gt;
&lt;h2 id=&quot;组件加载&quot;&gt;&lt;a href=&quot;#组件加载&quot; class=&quot;he
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>堆排序</title>
    <link href="http://yoursite.com/2018/05/21/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/05/21/堆排序/</id>
    <published>2018-05-21T07:05:00.000Z</published>
    <updated>2018-05-21T09:51:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] &gt;= A[i]。在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶。</p><p>具体算法描述如下：</p><p>1、将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；<br>2、将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),<br>  且满足R[1,2…n-1]&lt;=R[n]；<br>3、由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</p><p>时间复杂度：<br>最好：O(nlog2n)，<br>最坏：O(nlog2n)，<br>平均：O(nlog2n)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*方法说明：堆排序</span></span><br><span class="line"><span class="comment">@param  array 待排序数组*/</span>            </span><br><span class="line"><span class="keyword">const</span> heapSort = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(array).slice(<span class="number">8</span>, <span class="number">-1</span>) === <span class="string">'Array'</span>) &#123;</span><br><span class="line">    <span class="comment">//建堆</span></span><br><span class="line">    <span class="keyword">let</span> heapSize = array.length, temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="built_in">Math</span>.floor(heapSize / <span class="number">2</span>); i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        heapify(array, i, heapSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//堆排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = heapSize - <span class="number">1</span>; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">        temp = array[<span class="number">0</span>];</span><br><span class="line">        array[<span class="number">0</span>] = array[j];</span><br><span class="line">        array[j] = temp;</span><br><span class="line">        heapify(array, <span class="number">0</span>, --heapSize);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'array is not an Array!'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*方法说明：维护堆的性质</span></span><br><span class="line"><span class="comment">@param  arr 数组</span></span><br><span class="line"><span class="comment">@param  x   数组下标</span></span><br><span class="line"><span class="comment">@param  len 堆大小*/</span></span><br><span class="line"><span class="keyword">const</span> heapify = <span class="function">(<span class="params">arr, x, len</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(arr).slice(<span class="number">8</span>, <span class="number">-1</span>) === <span class="string">'Array'</span> &amp;&amp; <span class="keyword">typeof</span> x === <span class="string">'number'</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> l = <span class="number">2</span> * x, r = <span class="number">2</span> * x + <span class="number">1</span>, largest = x, temp;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (largest != x) &#123;</span><br><span class="line">        temp = arr[x];</span><br><span class="line">        arr[x] = arr[largest];</span><br><span class="line">        arr[largest] = temp;</span><br><span class="line">        heapify(arr, largest, len);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'arr is not an Array or x is not a number!'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] &amp;gt;= A[i]
      
    
    </summary>
    
      <category term="算法学习" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>归并排序</title>
    <link href="http://yoursite.com/2018/05/19/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/05/19/归并排序/</id>
    <published>2018-05-19T06:45:11.000Z</published>
    <updated>2018-05-21T07:03:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p><p>把长度为n的输入序列分成两个长度为n/2的子序列；<br>对这两个子序列分别采用归并排序；<br>将两个排序好的子序列合并成一个最终的排序序列。</p><p>归并操作的工作原理如下：<br>第一步：申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列<br>第二步：设定两个指针，最初位置分别为两个已经排序序列的起始位置<br>第三步：比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置<br>重复步骤3直到某一指针超出序列尾<br>将另一序列剩下的所有元素直接复制到合并序列尾</p><p>最佳情况：T(n) = O(n)<br>最差情况：T(n) = O(nlogn)<br>平均情况：T(n) = O(nlogn)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mergeSort = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> len = arr.lenght;</span><br><span class="line">  <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> m = (len &gt;&gt; <span class="number">1</span>), <span class="comment">//通过位运算符，将len取为一半。</span></span><br><span class="line">    left = array.slice(<span class="number">0</span>, m),</span><br><span class="line">    right = array.slice(m); <span class="comment">//拆分为两个子数组</span></span><br><span class="line">  <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));<span class="comment">//子数组继续递归拆分,然后再合并</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> merge = <span class="function">(<span class="params">left, right</span>) =&gt;</span> &#123; <span class="comment">//合并两个子数组</span></span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">while</span> (left.length &amp;&amp; right.length) &#123;</span><br><span class="line">    <span class="keyword">let</span> item = left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>] ? left.shift() : right.shift();<span class="comment">//注意:判断的条件是小于或等于,如果只是小于,那么排序将不稳定.</span></span><br><span class="line">    result.push(item);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result.concat(left.length ? left : right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二
      
    
    </summary>
    
      <category term="算法学习" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>选择排序</title>
    <link href="http://yoursite.com/2018/05/19/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/05/19/选择排序/</id>
    <published>2018-05-19T06:27:21.000Z</published>
    <updated>2018-05-19T06:39:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法。</p><p>简单选择排序的基本思想：<br>第1趟，在待排序记录r[1]~r[n]中选出最小的记录，将它与r[1]交换；<br>第2趟，在待排序记录r[2]~r[n]中选出最小的记录，将它与r[2]交换；<br>以此类推，<br>第i趟在待排序记录r[i]~r[n]中选出最小的记录，将它与r[i]交换，使有序序列不断增长直到全部排序完毕。</p><p>最佳情况：T(n) = O(n^2)<br>最差情况：T(n) = O(n^2)<br>平均情况：T(n) = O(n^2)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> selectSort = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> len = arr.length, min;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    min = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len; j++)&#123;</span><br><span class="line">      arr[j] &lt; arr[min] &amp;&amp; (min = j);</span><br><span class="line">    &#125;</span><br><span class="line">    min != i &amp;&amp; swap(i,min,arr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法。&lt;/p&gt;
&lt;p&gt;简单选择排序的基本思想：&lt;br&gt;第1趟，
      
    
    </summary>
    
      <category term="算法学习" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="http://yoursite.com/2018/05/19/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/05/19/快速排序/</id>
    <published>2018-05-19T06:01:19.000Z</published>
    <updated>2018-05-21T08:11:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>快速排序（Quicksort）是对冒泡排序的一种改进。<br>快速排序的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><p>一趟快速排序的算法是：<br>（1）在数据集之中，选择一个元素作为”基准”（pivot）。<br>（2）所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。<br>（3）对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。</p><p>最佳情况：T(n) = O(nlogn)<br>最差情况：T(n) = O(n2)<br>平均情况：T(n) = O(nlogn)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> quickSort = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) &#123; <span class="keyword">return</span> arr; &#125;</span><br><span class="line">  <span class="keyword">let</span> pivotIndex = arr.length &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(pivotIndex);</span><br><span class="line">  <span class="keyword">let</span> pivot = arr.splice(pivotIndex, <span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">let</span> left = [];</span><br><span class="line">  <span class="keyword">let</span> right = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">      left.push(arr[i]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> quickSort(left).concat([pivot], quickSort(right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;快速排序（Quicksort）是对冒泡排序的一种改进。&lt;br&gt;快速排序的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成
      
    
    </summary>
    
      <category term="算法学习" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>冒泡排序</title>
    <link href="http://yoursite.com/2018/05/19/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/05/19/冒泡排序/</id>
    <published>2018-05-19T05:35:51.000Z</published>
    <updated>2018-05-19T05:43:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。<br>它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。</p><p>冒泡排序算法的运作如下：（从后往前）<br>比较相邻的元素。如果第一个比第二个大，就交换他们两个。<br>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。<br>针对所有的元素重复以上的步骤，除了最后一个。<br>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 </p><p>时间复杂度：<br>冒泡排序最好的时间复杂度为O(n)。<br>冒泡排序的最坏时间复杂度为O(n^2)。<br>冒泡排序总的平均时间复杂度为O(n^2)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bubbleSort = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> len = arr.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - j; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = arr[j+<span class="number">1</span>];</span><br><span class="line">        arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。&lt;br&gt;它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。&lt;/p&gt;
&lt;p&gt;冒泡排序算法的运作
      
    
    </summary>
    
      <category term="算法学习" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
