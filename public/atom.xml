<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Milestone</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-11-16T05:52:35.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>啪叽</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>react 主要概念笔记</title>
    <link href="http://yoursite.com/2018/11/08/react-%E4%B8%BB%E8%A6%81%E6%A6%82%E5%BF%B5%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/11/08/react-主要概念笔记/</id>
    <published>2018-11-08T06:15:22.000Z</published>
    <updated>2018-11-16T05:52:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>React v16.5.2 文档学习</p><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>React 应用的构成模块：元素和组件</p><h2 id="JSX-简介"><a href="#JSX-简介" class="headerlink" title="JSX 简介"></a>JSX 简介</h2><p>JSX 是一种 JavaScript 的语法扩展，推荐在 React 中使用 JSX 来描述用户界面。<br>可以在 JSX 中任意的使用 JS 表达式，但是 JS 表达式要放在大括号里。</p><p>JSX 本身也是一种表达式，在编译之后，JSX 会被转化成普通的 JS 对象。<br>JSX 的中，ReactDOM 使用小驼峰来命名。</p><p>JSX 防注入攻击，因为 React DOM 在渲染之前默认会过滤所有传入的值，所有的内容在渲染之前都被转换成了字符串。可以有效的防止 XSS 攻击。</p><p>JSX 代表 Objects，Babel 转译器会把 JSX 专换成一个名为<code>React.createElement()</code>的方法调用。<br><code>React.createElement()</code>会返回一个对象，这个对象被称为“React 元素”。React 通过读取这些对象来构建 DOM 并且保持数据一致。</p><h2 id="元素渲染"><a href="#元素渲染" class="headerlink" title="元素渲染"></a>元素渲染</h2><p>元素是构成 React 应用的最小单位。<br>元素用来描述在屏幕上看到的东西，React 中的元素是普通的 JS 对象，ReactDOM 可以确保浏览器 DOM 的数据和 react 元素保持一致。</p><p>在 Html 页面里定义一个<code>id=&quot;root&quot;</code>根节点。<br>然后通过<code>ReactDOM.render()</code>方法，将 React 元素渲染到根 DOM 里。</p><p>更新元素渲染，是创建一个新的元素，然后用<code>ReactDOM.render()</code>方法，将 React 元素渲染到根 DOM 里。<br>但是，React DOM 会比较元素内容先后的不同，然后在渲染过程中，只更新改变了的部分。</p><h2 id="组件-amp-props"><a href="#组件-amp-props" class="headerlink" title="组件&amp;props"></a>组件&amp;props</h2><p>组件是独立的可复用的 ui 部件，从概念上看就像是函数，可以接受任意的输入值（props），并返回一个 React 元素。</p><p>定义组件，可以是一个 JavaScript 函数或者用一个 ES6 的 class 来定义一个组件。<br>React 元素可以是 DOM 标签，也可以是自定义的组件。<br>组件名称必须以大写字母开头。并且在使用组件时，需要引入或者定义它。<br>组件可以在输出中引用其他组件，但是组件的返回值只能有一个根元素。</p><p>Props 的只读性，无论是使用函数或者时类来声明一个组件，它不允许修改自己的 props。所有的 React 组件必须像纯函数那样使用它们的 props。</p><h2 id="State-amp-生命周期"><a href="#State-amp-生命周期" class="headerlink" title="State&amp;生命周期"></a>State&amp;生命周期</h2><p>使用类来声明一个组件，可以允许使用局部状态，生命周期钩子等。<br>使用类声明组件时，使用<code>constructor</code>把 props 传递到组件里:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">  <span class="keyword">super</span>(props);</span><br><span class="line">  <span class="keyword">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生命周期：<br>当组件第一次加载到 DOM 中的时候，称为挂载；<br>当组件生成的 DOM 被移除时，称为卸载。</p><p>正确的使用状态：<br>1、不要直接更新状态，直接更新不会重新渲染组件，应使用<code>this.setState({})</code>来更新。<br>2、状态更新可能是异步的。<br>3、状态更新合并，也可以独立更新。</p><p>数据自顶向下流动。<br>父组件和子组件都不知道某一个组件是否有状态，所以状态被称为局部状态，除了拥有并设置它的组件外，其他组件不可访问。组件可以选择状态，当作属性传给子组件。这被称为单向数据流。<br>任何状态始终由某些特定组件所有，并且从该状态导出的任何数据或 UI 只能影响树中下方的组件。</p><p>在 React 应用程序中，组件是有状态还是无状态被认为是可能随时间而变化的组件的实现细节。 可以在有状态组件中使用无状态组件，反之亦然。</p><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>React 的事件绑定属性的命名采用驼峰式写法，并为其赋值一个事件处理函数。<br>在函数中，要调用<code>preventDefault()</code>方法来阻止默认行为。</p><p>事件绑定 this：<br>因为类的方法不会默认绑定 this，所以用 ES5 写函数的时候，在调用的时候，需要在 constructor 里绑定 this。<br>也可以用 ES6 的箭头函数来写。</p><p>用 ES6 class 语法来定义一个组件的时候，事件处理器会成为类的一个方法</p><p>向事件处理程序传递参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;(e) =&gt; <span class="keyword">this</span>.deleteRow(id, e)&#125;&gt;Delete Row&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;button onClick=&#123;this.deleteRow.bind(this, id)&#125;&gt;Delete Row&lt;/</span>button&gt;</span><br></pre></td></tr></table></figure><h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><p>可以使用 if..else..语句来条件渲染。<br>可以使用与运算符 &amp;&amp;来条件渲染<br>可以使用 JavaScript 的条件运算符 condition ? true : false 来条件渲染</p><p>阻止条件渲染，可以用三目运算符，让 render 方法返回 null 而不是它的渲染结果即可实现。<br>组件的 render 方法返回 null 并不会影响该组件生命周期方法的回调。</p><h2 id="列表-amp-Keys"><a href="#列表-amp-Keys" class="headerlink" title="列表 &amp; Keys"></a>列表 &amp; Keys</h2><p>使用 map()函数，让每一个元素返回一个标签或者组件。</p><p>Keys 可以在 DOM 中的某些元素被增加或删除的时候帮助 React 识别哪些元素发生了变化。因此你应当给列表中的每一个元素赋予一个确定的标识</p><p>元素的 key 在他的兄弟元素之间应该唯一</p><h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><p>其值由 React 控制的输入表单元素称为“受控组件”</p><p>通过受控组件，来构造一个处理提交表单并可访问用户输入表单数据的函数<br>在 react 中，受控组件需要使用 this.setState 来进行更新。<br>使用”受控组件”,每个状态的改变都有一个与之相关的处理函数。这样就可以直接修改或验证用户输入。</p><h2 id="状态提升"><a href="#状态提升" class="headerlink" title="状态提升"></a>状态提升</h2><p>使用 react 经常会遇到几个组件需要共用状态数据的情况。这种情况下，我们最好将这部分共享的状态提升至他们最近的父组件当中进行管理。<br>在 React 应用中，对应任何可变数据理应只有一个单一“数据源”。通常，状态都是首先添加在需要渲染数据的组件中。此时，如果另一个组件也需要这些数据，你可以将数据提升至离它们最近的父组件中。你应该在应用中保持 自上而下的数据流，而不是尝试在不同组件中同步状态。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;React v16.5.2 文档学习&lt;/p&gt;
&lt;h2 id=&quot;Hello-World&quot;&gt;&lt;a href=&quot;#Hello-World&quot; class=&quot;headerlink&quot; title=&quot;Hello World&quot;&gt;&lt;/a&gt;Hello World&lt;/h2&gt;&lt;p&gt;React 应用
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>linux 服务器安装nginx及配置</title>
    <link href="http://yoursite.com/2018/11/02/linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85nginx/"/>
    <id>http://yoursite.com/2018/11/02/linux-服务器安装nginx/</id>
    <published>2018-11-02T02:53:39.000Z</published>
    <updated>2018-11-02T07:09:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 linux 服务器上安装 nginx，是想把自己写的项目配置到服务器上, 于是就研究了一下 nginx</p><h2 id="安装-nginx"><a href="#安装-nginx" class="headerlink" title="安装 nginx"></a>安装 nginx</h2><p>我是用 yum 安装的 nginx，简单快捷，命令也简单</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">yum -y install nginx;</span><br><span class="line"></span><br><span class="line">已加载插件：fastestmirror, security</span><br><span class="line">设置安装进程</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line">解决依赖关系</span><br><span class="line">--&gt; 执行事务检查</span><br><span class="line">---&gt; Package nginx.i686 0:1.0.15-12.el6 will be 安装</span><br><span class="line">--&gt; 完成依赖关系计算</span><br><span class="line"></span><br><span class="line">依赖关系解决</span><br><span class="line"></span><br><span class="line">========================================================================================================================================</span><br><span class="line"> 软件包                        架构                         版本                                     仓库                          大小</span><br><span class="line">========================================================================================================================================</span><br><span class="line">正在安装:</span><br><span class="line"> nginx                         i686                         1.0.15-12.el6                            epel                         410 k</span><br><span class="line"></span><br><span class="line">事务概要</span><br><span class="line">========================================================================================================================================</span><br><span class="line">Install       1 Package(s)</span><br><span class="line"></span><br><span class="line">总下载量：410 k</span><br><span class="line">Installed size: 1.1 M</span><br><span class="line">下载软件包：</span><br><span class="line">nginx-1.0.15-12.el6.i686.rpm                                                                                     | 410 kB     00:00</span><br><span class="line">运行 rpm_check_debug</span><br><span class="line">执行事务测试</span><br><span class="line">事务测试成功</span><br><span class="line">执行事务</span><br><span class="line">Warning: RPMDB altered outside of yum.</span><br><span class="line">  正在安装   : nginx-1.0.15-12.el6.i686                                                                                             1/1</span><br><span class="line">  Verifying  : nginx-1.0.15-12.el6.i686                                                                                             1/1</span><br><span class="line"></span><br><span class="line">已安装:</span><br><span class="line">  nginx.i686 0:1.0.15-12.el6</span><br><span class="line"></span><br><span class="line">完毕！</span><br></pre></td></tr></table></figure><p>然后可以查看一下 nginx 的版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx -v</span><br><span class="line">nginx version: nginx/1.12.2</span><br></pre></td></tr></table></figure><p>然后记一下 nginx 的启动，停止，和重启的问题就好了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 启动服务</span><br><span class="line">service nginx start</span><br><span class="line"></span><br><span class="line">// 关闭服务</span><br><span class="line">service nginx stop</span><br><span class="line"></span><br><span class="line">// 重启服务</span><br><span class="line">service nginx restart</span><br></pre></td></tr></table></figure><p>然后把项目记得放在／usr 目录下，然后你就需要配置 nginx.conf 了</p><p>我的 nginx.conf 是放在/etc/nginx/目录下，打开目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim nginx.conf</span><br></pre></td></tr></table></figure><p>然后可以在 vim 里处理 nginx.conf 文件</p><p>默认配置可以不动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 由于是单页应用虚拟路由的原因，需要将nginx的所有请求都转发到index.html页面，所以需要修改配置文件：</span><br><span class="line">server &#123;</span><br><span class="line">        listen       80 default_server;</span><br><span class="line">        listen       [::]:80 default_server;</span><br><span class="line">        server_name  _;</span><br><span class="line">        root         /usr/project/projectName/dist;</span><br><span class="line"></span><br><span class="line">        # Load configuration files for the default server block.</span><br><span class="line">        include /etc/nginx/default.d/*.conf;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        location ~* html &#123;</span><br><span class="line">            rewrite .* /index.html break;</span><br><span class="line">            root /usr/project/projectName/dist/;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 404 /404.html;</span><br><span class="line">            location = /index.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 500 502 503 504 /50x.html;</span><br><span class="line">            location = /50x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后重启nginx服务，在浏览器里输入ip地址就可以看到你的项目啦～</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 linux 服务器上安装 nginx，是想把自己写的项目配置到服务器上, 于是就研究了一下 nginx&lt;/p&gt;
&lt;h2 id=&quot;安装-nginx&quot;&gt;&lt;a href=&quot;#安装-nginx&quot; class=&quot;headerlink&quot; title=&quot;安装 nginx&quot;&gt;&lt;/a&gt;安
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>前端性能优化</title>
    <link href="http://yoursite.com/2018/10/10/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2018/10/10/前端性能优化/</id>
    <published>2018-10-10T07:14:35.000Z</published>
    <updated>2018-10-10T09:35:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在整理前端面试的一些知识点，感觉前端的性能优化是一个很重要的方面，还是得好好整理一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">问题：前端优化有那些解决方案？</span><br></pre></td></tr></table></figure><p>前端性能优化的原则以<b>更好的用户体验为标准</b>,具体就是要实现以下两个目标</p><ul><li>多使用内存、缓存或者其他方法</li><li>减少 CPU 和GPU 计算，更快展现</li></ul><p>而前端优化的方向有两个：</p><ul><li>减少页面体积，提升网络加载</li><li>优化页面渲染</li></ul><p>具体的方案有：</p><h2 id="减少页面体积，提升网络加载："><a href="#减少页面体积，提升网络加载：" class="headerlink" title="减少页面体积，提升网络加载："></a>减少页面体积，提升网络加载：</h2><p>1、静态资源压缩合并<br>    webpack 打包，把js，css，等文件压缩打包<br>2、静态资源缓存</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在整理前端面试的一些知识点，感觉前端的性能优化是一个很重要的方面，还是得好好整理一下。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端性能优化" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Javascript原型学习</title>
    <link href="http://yoursite.com/2018/10/09/Javascript%E5%8E%9F%E5%9E%8B%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2018/10/09/Javascript原型学习/</id>
    <published>2018-10-09T03:21:29.000Z</published>
    <updated>2018-10-09T03:38:59.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p><code>prototype</code>是函数才有的一个属性。</p></li><li><p>函数的 prototype 属性指向了一个对象，这个对象正是<b>调用该构造函数而创建的<i>实例</i></b>的原型。</p></li><li><p>原型可以理解成：每一个 JS 对象（null 除外），在创建的时候，就会与之关联另一个对象，这个对象就是我们说的原型。每个对象都会从原型继承属性。</p></li><li><p>每一个 JS 对象（null 除外）都有一个<code>_proto_</code>的属性，该属性指向该对象的原型。</p></li><li><p>每一个原型都会有一个<code>constructor</code>属性，指向关联的构造函数。</p></li><li><p>原型也是一个对象，是通过<code>Object()</code>构造函数生成的。</p></li><li><p><code>Object.prototype</code>没有原型</p></li><li><p>关系图<br><img src="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype5.png" alt="关系图"></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;prototype&lt;/code&gt;是函数才有的一个属性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;函数的 prototype 属性指向了一个对象，这个对象正是&lt;b&gt;调用该构造函数而创建的&lt;i&gt;实例&lt;/i&gt;&lt;/b&gt;的原型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>for 循环作用域的探究</title>
    <link href="http://yoursite.com/2018/09/29/for-%E5%BE%AA%E7%8E%AF%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%8E%A2%E7%A9%B6/"/>
    <id>http://yoursite.com/2018/09/29/for-循环作用域的探究/</id>
    <published>2018-09-29T06:22:18.000Z</published>
    <updated>2018-09-29T08:05:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前看到这么一个题，问最后输出什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="function">(<span class="params">setTimeout((</span>) =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">2333</span>), <span class="number">0</span>); i &lt; <span class="number">2</span>; i++) &#123;&#125;</span><br></pre></td></tr></table></figure><p>答案是在 2333ms 之后，输出了 0。</p><p>一直在想什么原因。今天闲着没事重新在看阮一峰 es6 入门，然后想起来这个问题。</p><p>es6 入门的 let 和 const 的那一章里，他说了一个问题：</p><p><b>for 循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</b></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="string">'abc'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br></pre></td></tr></table></figure><p><strong> 因为输出了 3 遍 abc，这表明函数内部的变量 i 与循环变量 i 不在同一个作用域，有各自单独的作用域。</strong></p><p>我 google 了一下，发现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br></pre></td></tr></table></figure><p>在声明的（）内存在一个变量 i，会存在 JavaScript 引擎内部。 每一次循环的时候， JavaScript 引擎内部会记住上一轮循环的值，然后将新的 i 的值赋值给 i。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="string">'abc'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在循环体里面，这是一个新的作用域，重新声明一个 i；不会影响（）里 i 的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  i = <span class="string">'abc'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// abc</span></span><br></pre></td></tr></table></figure><p>但是如果不声明 i，直接给 i 赋值，会影响（）里 i 的值，说明（）是循环体的上一级作用域，在循环体里直接改变 i 的值会影响上一级作用域里的 i 值。</p><p>回到最初的那道题里面：</p><p>for 循环有三个语句：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (语句 <span class="number">1</span>; 语句 <span class="number">2</span>; 语句 <span class="number">3</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  被执行的代码块</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>语句 1 在循环（代码块）开始前执行，就是 for()之前开始执行，只会执行一次。并且在 js 引擎里记住这个变量，他的值随着条件改变。</p><p>语句 2 定义运行循环（代码块）的条件。</p><p>语句 3 在循环（代码块）已被执行之后执行。</p><p>语句1如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="function">(<span class="params">setTimeout((</span>) =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">2333</span>), <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>这个表达式，同步执行的时候，因为括号里是逗号表达式，所以返回了 0，i=0；同时把 setTimeout 放到了 macrotasks 中。并继续向下执行。</p><p>这个题目，就会变成这样了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> o = <span class="function">(<span class="params">setTimeout((</span>) =&gt;</span> <span class="built_in">console</span>.log(o), <span class="number">2333</span>), <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = o; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> j = i;</span><br><span class="line">    <span class="built_in">console</span>.log(j);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就好理解了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前看到这么一个题，问最后输出什么？&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;
      
    
    </summary>
    
      <category term="Demo练习" scheme="http://yoursite.com/categories/Demo%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>实现一个解构数组的方法</title>
    <link href="http://yoursite.com/2018/09/10/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%A7%A3%E6%9E%84%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/09/10/实现一个解构数组的方法/</id>
    <published>2018-09-10T06:48:28.000Z</published>
    <updated>2018-09-10T07:47:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>一道笔试题：</p><p>实现 destructuringArray 方法，<br>达到如下效果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// destructuringArray( [1,[2,4],3], "[a,[b],c]" );</span></span><br><span class="line"><span class="comment">// result</span></span><br><span class="line"><span class="comment">// &#123; a:1, b:2, c:3 &#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> targetArray = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> formater = <span class="string">'[a, [b], c]'</span>;</span><br><span class="line"><span class="keyword">const</span> formaterArray = [<span class="string">'a'</span>, [<span class="string">'b'</span>], <span class="string">'c'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> destructuringArray = <span class="function">(<span class="params">values, keys</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> keys === <span class="string">'string'</span>) &#123;</span><br><span class="line">      keys = <span class="built_in">JSON</span>.parse(keys.replace(<span class="regexp">/\w+/g</span>, <span class="string">'"$&amp;"'</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> iterate = <span class="function">(<span class="params">values, keys</span>) =&gt;</span></span><br><span class="line">      keys.forEach(<span class="function">(<span class="params">key, i</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(key)) iterate(values[i], key);</span><br><span class="line">        <span class="keyword">else</span> obj[key] = values[i];</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">    iterate(values, keys);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(e.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.dir(destructuringArray(targetArray, formater));</span><br><span class="line"><span class="built_in">console</span>.dir(destructuringArray(targetArray, formaterArray));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一道笔试题：&lt;/p&gt;
&lt;p&gt;实现 destructuringArray 方法，&lt;br&gt;达到如下效果&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class
      
    
    </summary>
    
      <category term="面试锦囊" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%94%A6%E5%9B%8A/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>如何判断一个整数是否在40亿个整数中？</title>
    <link href="http://yoursite.com/2018/09/10/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E6%98%AF%E5%90%A6%E5%9C%A840%E4%BA%BF%E4%B8%AA%E6%95%B4%E6%95%B0%E4%B8%AD%EF%BC%9F/"/>
    <id>http://yoursite.com/2018/09/10/如何判断一个整数是否在40亿个整数中？/</id>
    <published>2018-09-10T06:47:45.000Z</published>
    <updated>2018-09-10T07:06:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>题目：我有 40 亿个整数，再给一个新的整数，我需要判断新的整数是否在 40 亿个整数中，你会怎么做（每个整数是32位的）？</p><p>一个数在不在就是两个状态，在或者不在，就可以用1个位来代表。<br>每个整数是32位的，那么所有的整数也就2^32个，大概42亿个数左右。<br>可以申请2^32的位，把每一个整数都覆盖了，40亿个数的位分别为1，剩下的位为0。<br>新的整数，就可以跟进它的大小来判断相应的位，比如1245，就去看1245位是1还是0来判断是否在这40亿个整数中。</p><p>2^32个位，就是2^29个字节，也就是500M左右。</p><p>位图法（bitmap）</p><p>链接：<br><a href="https://mp.weixin.qq.com/s/XC7Wpc5ZdvcT_7h3I956RQ" target="_blank" rel="noopener">漫画：如何判断一个数是否在 40 亿个整数中</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目：我有 40 亿个整数，再给一个新的整数，我需要判断新的整数是否在 40 亿个整数中，你会怎么做（每个整数是32位的）？&lt;/p&gt;
&lt;p&gt;一个数在不在就是两个状态，在或者不在，就可以用1个位来代表。&lt;br&gt;每个整数是32位的，那么所有的整数也就2^32个，大概42亿个数左
      
    
    </summary>
    
      <category term="面试锦囊" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%94%A6%E5%9B%8A/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>关于xss和csrf</title>
    <link href="http://yoursite.com/2018/09/06/%E5%85%B3%E4%BA%8Exss%E5%92%8Ccsrf/"/>
    <id>http://yoursite.com/2018/09/06/关于xss和csrf/</id>
    <published>2018-09-06T08:10:57.000Z</published>
    <updated>2018-09-10T03:01:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>xss 是跨网站指令码，是代码注入的一种，它允许恶意使用者将程式码注入到网页上，其他使用者在观看网页时就会受到影响。这类攻击通常包含了 HTML 以及使用者端脚本语言。</p><p>攻击方式: XSS 通过修改 HTML 节点或者执行 JS 代码来攻击网站。比如通过 url 来在页面上添加 html 后者 js 文件。</p><p>防止: 最普遍的方法，是将输出的内容进行转义，比如对于引号，尖括号，斜杠进行转义等，再就是设置白名单或者黑名单等。比如只允许加载本站资源等。。</p><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>csrf 跨站请求伪造，是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。简单点说，CSRF 就是利用用户的登录态发起恶意请求。</p><p>防止：防范 CSRF 可以遵循以下几种规则：</p><ul><li>Get 请求不对数据进行修改</li><li>不让第三方网站访问到用户 Cookie</li><li>阻止第三方网站请求接口</li><li>请求时附带验证信息，比如验证码或者 token</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;XSS&quot;&gt;&lt;a href=&quot;#XSS&quot; class=&quot;headerlink&quot; title=&quot;XSS&quot;&gt;&lt;/a&gt;XSS&lt;/h2&gt;&lt;p&gt;xss 是跨网站指令码，是代码注入的一种，它允许恶意使用者将程式码注入到网页上，其他使用者在观看网页时就会受到影响。这类攻击通常包含
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端安全" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>一些JS小技巧</title>
    <link href="http://yoursite.com/2018/08/23/%E4%B8%80%E4%BA%9BJS%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2018/08/23/一些JS小技巧/</id>
    <published>2018-08-23T09:08:51.000Z</published>
    <updated>2018-09-10T07:59:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>整理一些自己遇到的 js 小技巧，希望以后能变成一个炫技派，哈哈哈～</p><p>0、对象深拷贝的小方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br></pre></td></tr></table></figure><p>1、数组去重</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> deleteSame = <span class="function"><span class="params">array</span> =&gt;</span> [...new <span class="built_in">Set</span>(array)];</span><br></pre></td></tr></table></figure><p>去重只能基本数据类型的，String，Number，Boolean, undefined, null, Symbol。<br>如果是对象，都不会去重。</p><p>2、用<code>Object.is(a, b)</code> 代替 <code>===</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Object</span>.is(a, b)) &#123;</span><br><span class="line">  <span class="comment">//TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、用<code>+ a</code>操作符去代替<code>Number(a)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="string">'123'</span>;</span><br><span class="line"><span class="keyword">typeof</span> a; <span class="comment">// "string"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Number</span>(a); <span class="comment">// "number"</span></span><br><span class="line"><span class="keyword">typeof</span> +a; <span class="comment">// "number"</span></span><br></pre></td></tr></table></figure><p>4、短路操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!foo) &#123;</span><br><span class="line">  foo = bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo = foo || bar;</span><br></pre></td></tr></table></figure><p>5、通过!!确认 bool 值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (!!foo) &#123;</span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、判断变量的类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(data);</span><br><span class="line"><span class="comment">// "[object String]"</span></span><br><span class="line"><span class="comment">// "[object Array]"</span></span><br><span class="line"><span class="comment">// "[object Number]"</span></span><br><span class="line"><span class="comment">// "[object Object]"</span></span><br><span class="line"><span class="comment">// "[object Function]"</span></span><br><span class="line"><span class="comment">// "[object Undefined]"</span></span><br><span class="line"><span class="comment">// "[object RegExp]"</span></span><br></pre></td></tr></table></figure><p>7、<code>str.trim()</code>来清除前后空格</p><p>8、遍历对象的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="string">'0'</span>: <span class="string">'a'</span>, <span class="string">'1'</span>: <span class="string">'b'</span>, <span class="string">'2'</span>: <span class="string">'c'</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, obj[key]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>9、删除数组里的某个元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">const</span> target = <span class="number">3</span>;</span><br><span class="line">arr = arr.filter(<span class="function"><span class="params">v</span> =&gt;</span> !<span class="built_in">Object</span>.is(v, target));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;整理一些自己遇到的 js 小技巧，希望以后能变成一个炫技派，哈哈哈～&lt;/p&gt;
&lt;p&gt;0、对象深拷贝的小方法&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span c
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>react 是怎样工作的</title>
    <link href="http://yoursite.com/2018/08/23/react-%E6%98%AF%E6%80%8E%E6%A0%B7%E5%B7%A5%E4%BD%9C%E7%9A%84/"/>
    <id>http://yoursite.com/2018/08/23/react-是怎样工作的/</id>
    <published>2018-08-23T06:23:33.000Z</published>
    <updated>2018-08-23T06:23:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>占坑</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;占坑&lt;/p&gt;

      
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>理解虚拟DOM</title>
    <link href="http://yoursite.com/2018/08/23/%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9FDOM/"/>
    <id>http://yoursite.com/2018/08/23/理解虚拟DOM/</id>
    <published>2018-08-23T06:23:07.000Z</published>
    <updated>2018-08-23T07:18:31.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>什么是虚拟 DOM</li></ul><p>Virtual DOM 就是一个模拟 DOM 树的 Javascript 的对象。</p><ul><li>虚拟的 DOM 的核心思想</li></ul><p>对复杂的文档 DOM 结构，提供一种方便的工具，进行最小化地 DOM 操作。</p><ul><li>React 工作原理</li></ul><p>React 使用了虚拟 DOM，每次状态更新，React 比较虚拟 DOM 的差异之后，再更改变化的内容，最后统一由 React 去修改真实 DOM、完成页面的更新、渲染。</p><ul><li>Virtrual DOM 和真实 DOM 的区别</li></ul><p>真实 DOM 的的工作流程：<br>大致分 5 步：创建 DOM tree –&gt; 创建 Style Rules -&gt; 构建 Render tree -&gt; 布局 Layout –&gt; 绘制 Painting</p><p>第一步，用 HTML 分析器，分析 HTML 的各种元素，构建一颗 DOM 树。</p><p>第二步：用 CSS 分析器，分析 CSS 文件和元素上的 inline 样式，生成页面的样式表。</p><p>第三步：将上面的 DOM 树和样式表，关联起来，构建一颗 Render 树。这一过程又称为 Attachment。每个 DOM 节点都有 attach 方法，接受样式信息，返回一个 render 对象（又名 renderer）。这些 render 对象最终会被构建成一颗 Render 树。</p><p>第四步：有了 Render 树后，浏览器开始布局，会为每个 Render 树上的节点确定一个在显示屏上出现的精确坐标值。</p><p>第五步：Render 数有了，节点显示的位置坐标也有了，最后就是调用每个节点的 paint 方法，让它们显示出来。</p><p>然而操作 DOM，浏览器会从构建 DOM 树开始从头到尾执行一遍流程。然而 DOM 的批量操作不会被合并，只会第一个 DOM 操作处理完之后再重新从构建 DOM 树开始第二个操作，一直到最后一个操作结束。</p><p>Virtrual DOM 的工作流程：<br>Virtrual DOM 会对批量的操作合并到 Virtrual DOM 树上，然后根据 diff 算法，查看哪一部分发生了变化，然后将 diff 的内容保存到本地的一个 js 对象里，然后这个对象再 attach 到 DOM 树上，通知浏览器重新绘制。</p><ul><li>实现一个 Virtrual DOM</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//虚拟dom，参数分别为标签名、属性对象、子DOM列表</span></span><br><span class="line"><span class="keyword">const</span> VElement = <span class="function">(<span class="params">tagName, props, children</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//保证只能通过如下方式调用：new VElement</span></span><br><span class="line">  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> VElement)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> VElement(tagName, props, children);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//可以通过只传递tagName和children参数</span></span><br><span class="line">  <span class="keyword">if</span> (util.isArray(props)) &#123;</span><br><span class="line">    children = props;</span><br><span class="line">    props = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//设置虚拟dom的相关属性</span></span><br><span class="line">  <span class="keyword">this</span>.tagName = tagName;</span><br><span class="line">  <span class="keyword">this</span>.props = props || &#123;&#125;;</span><br><span class="line">  <span class="keyword">this</span>.children = children || [];</span><br><span class="line">  <span class="keyword">this</span>.key = props ? props.key : <span class="keyword">void</span> <span class="number">666</span>;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  util.each(<span class="keyword">this</span>.children, (child, i) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (child <span class="keyword">instanceof</span> VElement) &#123;</span><br><span class="line">      count += child.count;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      children[i] = <span class="string">""</span> + child;</span><br><span class="line">    &#125;</span><br><span class="line">    count++;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">this</span>.count = count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">VElement.prototype.render = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//创建标签</span></span><br><span class="line">  <span class="keyword">const</span> el = <span class="built_in">document</span>.createElement(<span class="keyword">this</span>.tagName);</span><br><span class="line">  <span class="comment">//设置标签的属性</span></span><br><span class="line">  <span class="keyword">const</span> props = <span class="keyword">this</span>.props;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> propName <span class="keyword">in</span> props) &#123;</span><br><span class="line">    <span class="keyword">const</span> propValue = props[propName];</span><br><span class="line">    util.setAttr(el, propName, propValue);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//依次创建子节点的标签</span></span><br><span class="line">  util.each(<span class="keyword">this</span>.children, child =&gt; &#123;</span><br><span class="line">    <span class="comment">//如果子节点仍然为velement，则递归的创建子节点，否则直接创建文本类型节点</span></span><br><span class="line">    <span class="keyword">const</span> childEl = child <span class="keyword">instanceof</span> VElement ? child.render() : <span class="built_in">document</span>.createTextNode(child);</span><br><span class="line">    el.appendChild(childEl);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> el;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对一个虚拟的 DOM 对象 VElement，调用其原型的 render 方法，就可以产生一颗真实的 DOM 树</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;什么是虚拟 DOM&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Virtual DOM 就是一个模拟 DOM 树的 Javascript 的对象。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虚拟的 DOM 的核心思想&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对复杂的文档 DOM 结构，提供一种方便的工具，
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>偷得浮生半日闲</title>
    <link href="http://yoursite.com/2018/08/19/%E5%81%B7%E5%BE%97%E6%B5%AE%E7%94%9F%E5%8D%8A%E6%97%A5%E9%97%B2/"/>
    <id>http://yoursite.com/2018/08/19/偷得浮生半日闲/</id>
    <published>2018-08-19T13:28:50.000Z</published>
    <updated>2018-08-19T13:57:17.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>没有什么事情是理所应当的，所有的结果都是之前付出努力的一种回报。</li><li>我是比较相信这样的努力和付出的论点的。毕竟付出努力，肯定会有回报，不一定会是在你期望的方面，但是他也会有结果，也许是另一个方面的回报。</li><li>这只是我的一段碎碎念。</li></ul><p>工作的第 8 个月零 1 天，感觉我需要更多方面的进步了。感觉到了很大的压力，最近整个人都比较的佛系，靠着工作，拿着薪水，奋斗的动力感觉少了很多。当工作忙的时候，就没时间写博客了，时间都浪费在了铺页面，联调，提测，改 bug 的过程中。我觉得我需要有一些规划，让自己能在工作期间，也能学习到一些东西。</p><p>前几天，还被说每天三个小时的通勤时间，竟然还不搬家。平时都不觉得，路上的时间总觉得都过的很快，但是有一天，突然想了一下，就是觉得，每天三个小时通勤时间确实好长啊，每天好累啊 balaba，但是又一想，唉，每天这 3 个小时都被我浪费掉了。有时候在书签里存了好多想看的书啊，想看的网页啊，教程啊，到了地铁上，就没了兴趣，游戏真好玩，虎扑真好玩，知乎真好玩，歌真好听等等等等。</p><p><blockquote> 我觉得一个人的自制力或者自控力，是不会随着长大逐渐提高的，除非有什么事情逼迫着你。</blockquote></p><div></div><p>这就是一种个人的体验，也算是一种总结吧。<br>觉得自己会写好多东西出来。其实我也写不动了。<br>但是我想我可以没事给自己打一点鸡血，让自己兴奋一些。</p><p>加油吧，少年（也许已经不是少年了）。</p><p>想想 2018 年来的时候，我还在票圈里说，我出生的时候就比别的孩子长得老，2017 过去了，我很想念它。<br>希望不要在 2019 年来的时候，继续怀念 2018.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;没有什么事情是理所应当的，所有的结果都是之前付出努力的一种回报。&lt;/li&gt;
&lt;li&gt;我是比较相信这样的努力和付出的论点的。毕竟付出努力，肯定会有回报，不一定会是在你期望的方面，但是他也会有结果，也许是另一个方面的回报。&lt;/li&gt;
&lt;li&gt;这只是我的一段碎碎念。&lt;
      
    
    </summary>
    
      <category term="浮生小记" scheme="http://yoursite.com/categories/%E6%B5%AE%E7%94%9F%E5%B0%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>axios jquery.ajax fetch 区别</title>
    <link href="http://yoursite.com/2018/08/03/axios-jquery-ajax-fetch-%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2018/08/03/axios-jquery-ajax-fetch-区别/</id>
    <published>2018-08-03T02:41:38.000Z</published>
    <updated>2018-08-03T03:52:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近项目在用 axios，好像出现好久了，才开始学习。</p><p>这三个都是发起 http 请求的东西,都算是对原生 XHR 的封装。从 XHR -&gt; Jquery ajax() -&gt; fetch -&gt; axios<br>现在来分别看一下这三个东西</p><ul><li>Jquery ajax<br>它是对原生 XHR 的封装，支持 JsonP，是 MVC 编程的一种请求方式，已经逐渐的不适应前端的 MVVM 框架的潮流了。<br>而且，在项目中使用的时候，要使用 ajax，就得把 jquery 都引进来，很冗余。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  type: <span class="string">"POST"</span>,</span><br><span class="line">  url: url,</span><br><span class="line">  data: data,</span><br><span class="line">  dataType: dataType,</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  error: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>fetch</li></ul><p>fetch 是一个出现比较久的，但是依旧有好多不兼容的 ajax 的替代品。<br>采用了 es 的 promise。<br>fetch 不会默认的传 cookies，需要添加配置项<code>credentials: &#39;include&#39;</code><br>fetch 只会对网络请求错误报错，400，500 等问题会进入 then，而不会进入 catch。<br>fetch 不支持超时的问题。<br>fetch 不能监听请求的进度，而 XHR 可以。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(url);</span><br><span class="line">  <span class="keyword">let</span> data = response.json();</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Oops, error"</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>axios 是一个很高档的东西。它不仅支持浏览器的数据请求，还支持 node 创建 http 请求。<br>它和 fetch 一样，也是基于 Promise 的 API，能够从客户端支持防止 CSRF，提供了很多接口，可以并发等。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">  method: <span class="string">"GET"</span>,</span><br><span class="line">  url: url</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近项目在用 axios，好像出现好久了，才开始学习。&lt;/p&gt;
&lt;p&gt;这三个都是发起 http 请求的东西,都算是对原生 XHR 的封装。从 XHR -&amp;gt; Jquery ajax() -&amp;gt; fetch -&amp;gt; axios&lt;br&gt;现在来分别看一下这三个东西&lt;/
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>react-router 4.0使用笔记</title>
    <link href="http://yoursite.com/2018/07/23/react-router-4-0%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/07/23/react-router-4-0使用笔记/</id>
    <published>2018-07-23T05:51:44.000Z</published>
    <updated>2018-07-23T06:28:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近项目里的 react-router 从 3.0 更新到了 4.0，重新学习了一下 react-router 的东西，感觉从 3 到 4，变化还是很多的。通过<a href="http://reacttraining.cn/" target="_blank" rel="noopener">react-router 4.0 中文文档</a>和一些其他的教程，大概学会了如何使用。记下来防止以后忘记了。。</p><p>v3 的时候，是把所有的路由都写在一个地方，通常就是组件和路由分开。<br>到了 v4，路由就变成了一个和 UI 组件并列的组件，在你需要的地方把路由组件写在合适的地方。不在需要用<route>组件的嵌套来实现路由嵌套。</route></p><h2 id="exact"><a href="#exact" class="headerlink" title="exact"></a>exact</h2><p>exact 关键字，可以让路由只匹配一个 path，path 为’/‘的路由将不会匹配’/xxx’的</p><h2 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h2><p>可以使用 Switch 组件，来启用排他性的路由。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">  &lt;Route path=<span class="string">"/"</span> exact component=&#123;Home&#125; /&gt;</span><br><span class="line">  &lt;Route path=<span class="string">"/about"</span> component=&#123;About&#125; /&gt;</span><br><span class="line">  &lt;Route path=<span class="string">"/user"</span> component=&#123;User&#125; /&gt;</span><br><span class="line">&lt;<span class="regexp">/Switch&gt;</span></span><br></pre></td></tr></table></figure><h2 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h2><p>如果需要嵌套路由，在 app 组件中可以把嵌套路由的父组件<route path="/xx" component="{xxx}"> /&gt;，在 xxx 组件中，在根据父组件来匹配路由。</route></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XXX</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; history, match &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Layout&gt;</span><br><span class="line">        &lt;Layout.Content style=&#123;&#123; <span class="attr">padding</span>: <span class="string">"0 50px"</span> &#125;&#125;&gt;</span><br><span class="line">          &lt;div style=&#123;&#123; <span class="attr">background</span>: <span class="string">"#fff"</span>, <span class="attr">padding</span>: <span class="number">24</span> &#125;&#125;&gt;</span><br><span class="line">            &lt;Divider /&gt;</span><br><span class="line">            &lt;Route</span><br><span class="line">              exact</span><br><span class="line">              path=&#123;<span class="string">`<span class="subst">$&#123;match.path&#125;</span>/loan-info`</span>&#125;</span><br><span class="line">              component=&#123;LoanInfo&#125;</span><br><span class="line">            /&gt;</span><br><span class="line">            &lt;Route exact path=&#123;<span class="string">`<span class="subst">$&#123;match.path&#125;</span>/img-info`</span>&#125; component=&#123;ImgInfo&#125; /&gt;</span><br><span class="line">            &lt;Route exact path=&#123;<span class="string">`<span class="subst">$&#123;match.path&#125;</span>`</span>&#125; component=&#123;LoanInfo&#125; /&gt;</span><br><span class="line">          &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Layout.Content&gt;</span><br><span class="line">      &lt;<span class="regexp">/Layout&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="withRouter"><a href="#withRouter" class="headerlink" title="withRouter"></a>withRouter</h2><p>想通过代码跳转子路由，可以用 withRouter,包装 react 组件,让它获得 history 属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; withRouter &#125; <span class="keyword">from</span> <span class="string">"react-router"</span>;</span><br><span class="line">withRouter(MyComponent);</span><br></pre></td></tr></table></figure><p>然后用<code>this.props.history</code>来跳转。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近项目里的 react-router 从 3.0 更新到了 4.0，重新学习了一下 react-router 的东西，感觉从 3 到 4，变化还是很多的。通过&lt;a href=&quot;http://reacttraining.cn/&quot; target=&quot;_blank&quot; rel=&quot;n
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="react-router" scheme="http://yoursite.com/tags/react-router/"/>
    
  </entry>
  
  <entry>
    <title>BOM 学习</title>
    <link href="http://yoursite.com/2018/07/10/BOM-%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2018/07/10/BOM-学习/</id>
    <published>2018-07-10T07:54:21.000Z</published>
    <updated>2018-07-10T08:49:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是js高程的第8章，这是我第一次系统的学习bom，以前都是随便用，也没有成体系的东西，这次要好好学习一下。<br>主要内容：<br> 理解 window 对象——BOM 的核心<br> 控制窗口、框架和弹出窗口<br> 利用 location 对象中的页面信息<br> 使用 navigator 对象了解浏览器</p><h2 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h2><p>BOM的核心对象是window，它表示浏览器的一个实例。在浏览器中，window对象有双重角色，它既是通过JavaScript访问浏览器窗口的一个接口，又是ECMAScript规定的Global对象</p><p>1、1全局作用域<br>由于 window 对象同时扮演着 ECMAScript 中 Global 对象的角色，因此所有在全局作用域中声明的变量、函数都会变成 window 对象的属性和方法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是js高程的第8章，这是我第一次系统的学习bom，以前都是随便用，也没有成体系的东西，这次要好好学习一下。&lt;br&gt;主要内容：&lt;br&gt; 理解 window 对象——BOM 的核心&lt;br&gt; 控制窗口、框架和弹出窗口&lt;br&gt; 利用 location 对象中的页面信息&lt;br
      
    
    </summary>
    
      <category term="JS高程填坑笔记" scheme="http://yoursite.com/categories/JS%E9%AB%98%E7%A8%8B%E5%A1%AB%E5%9D%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>科学上网小记</title>
    <link href="http://yoursite.com/2018/07/10/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E5%B0%8F%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/07/10/科学上网小记/</id>
    <published>2018-07-10T02:10:49.000Z</published>
    <updated>2018-07-11T05:50:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>整理一下前一段时间研究科学上网的方法。<br><b style="font-size: 20px;"><i>科学上网需要购买国外的服务器, 会有一定的花费, 请自行判断<i></i></i></b></p><h2 id="购买服务器"><a href="#购买服务器" class="headerlink" title="购买服务器"></a>购买服务器</h2><p>科学上网是通过 VPS，搭建 ss 或者 ssr 服务器（梯子）来实现的。<br>vps 服务器需要选择国外的（毕竟要翻墙）。一般都会在搬瓦工或者 vultr 购买服务器。<br>我是看了同事在 vultr 买的，我也就在这里买的,感觉还不错，能够随时改变和删除服务器。<br>网站：<code>https://www.vultr.com/</code></p><p>1、注册账号<br><img src="https://github.com/kaisa911/studyNotes/blob/master/public/image/zhucezhanghao.png?raw=true" alt="注册账号"><br>2、充值<br>因为可以用支付宝，我就选择了支付宝支付。<br><img src="https://github.com/kaisa911/studyNotes/blob/master/public/image/chongzhi.png?raw=true" alt="充值"><br>3、购买服务器<br>vultr 官方最近进行了调整，2.5 美元套餐只提供 ipv6，可以用来上 BT，教育网等，但是不能实用 ipv4 的流量，如果你有 ipv4 需求，那么你至少要买 5 美元的套餐。<br>3.1 选择地区<br><img src="https://github.com/kaisa911/studyNotes/blob/master/public/image/fuwuqi01.png?raw=true" alt="选择地区"><br>3.2 选择服务器种类<br>我选的 ubuntu 16.04 x64 版本的，当然也可以选其他的种类，<br><img src="https://github.com/kaisa911/studyNotes/blob/master/public/image/fuwuqi02.png?raw=true" alt="选择服务器种类"><br>3.3 选择服务器大小<br>我当时选的$2.5/mo 的，现在貌似得选$5/mo 的了。。<br><img src="https://github.com/kaisa911/studyNotes/blob/master/public/image/fuwuqi03.png?raw=true" alt="选择服务器大小"><br>然后就可以买了。会得到一个服务器。。<br>服务器列表<br><img src="https://github.com/kaisa911/studyNotes/blob/master/public/image/fuwuqi04.png?raw=true" alt="服务器列表"><br>服务器详情<br><img src="https://github.com/kaisa911/studyNotes/blob/master/public/image/fuwuqi05.png?raw=true" alt="服务器详情"><br>开启 ipv6<br><img src="https://github.com/kaisa911/studyNotes/blob/master/public/image/fuwuqi06.png?raw=true" alt="开启ipv6"></p><p>到这里，购买服务器就一步就可以了。</p><h2 id="搭建-ss-服务"><a href="#搭建-ss-服务" class="headerlink" title="搭建 ss 服务"></a>搭建 ss 服务</h2><p>1、首先需要连接到服务器，可以先 ping 一下 ip 地址看看，能 ping 通应该就可以用，没有 ping 通，就把刚才的服务器换一个。mac 可以用终端直接连接，windows 可以用 git bash，Xshell，Putty 等也都可以<br>连接到远程服务器的方法是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@ip</span><br></pre></td></tr></table></figure><p>ip 就是你新买服务器的 ip，然后会提示让你输入密码，可以把密码复制进去就可以登陆了.<br><img src="https://github.com/kaisa911/studyNotes/blob/master/public/image/lianjie01.png?raw=true" alt="连接服务器"></p><p>2、搭建 ss 服务器<br>我是使用的 ubuntu 的服务器，其他服务器可以 google 其他教程。<br>在刚刚连接的命令行里</p><ul><li><p>安装pip前需要前置安装setuptools</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate  https://pypi.python.org/packages/source/s/setuptools/setuptools-19.6.tar.gz#md5=c607dd118eae682c44ed146367a17e26</span><br><span class="line"></span><br><span class="line">tar -zxvf setuptools-19.6.tar.gz</span><br><span class="line"></span><br><span class="line">cd setuptools-19.6</span><br><span class="line"></span><br><span class="line">python3 setup.py build</span><br><span class="line"></span><br><span class="line">python3 setup.py install</span><br></pre></td></tr></table></figure></li><li><p>安装 pip<br>首先安装 pip3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python3-pip</span><br></pre></td></tr></table></figure></li><li><p>安装 Shadowsocks<br>安装最新版的 Shadowsocks：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install https://github.com/shadowsocks/shadowsocks/archive/master.zip</span><br></pre></td></tr></table></figure><p>查看 Shadowsocks 的版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ssserver --version</span><br></pre></td></tr></table></figure></li><li><p>创建配置文件<br>创建 Shadowsocks 配置文件所在文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /etc/shadowsocks</span><br></pre></td></tr></table></figure><p>创建配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/shadowsocks/config.json</span><br></pre></td></tr></table></figure><p>复制粘贴如下内容（注意修改密码“password”,服务器端口号也可以自行修改）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;server&quot;:&quot;::&quot;,</span><br><span class="line">  &quot;server_port&quot;:8388,</span><br><span class="line">  &quot;local_address&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">  &quot;local_port&quot;:1080,</span><br><span class="line">  &quot;password&quot;:&quot;mypassword&quot;,</span><br><span class="line">  &quot;timeout&quot;:300,</span><br><span class="line">  &quot;method&quot;:&quot;aes-256-cfb&quot;,</span><br><span class="line">  &quot;fast_open&quot;: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后按 Ctrl + O 保存文件，Ctrl + X 退出。</p></li><li><p>测试 Shadowsocks 配置<br>测试下 Shadowsocks 能不能正常工作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssserver -c /etc/shadowsocks/config.json</span><br></pre></td></tr></table></figure><p>测试完毕，按 Ctrl + C 关闭 Shadowsocks。</p></li><li><p>配置 Systemd 管理 Shadowsocks<br>新建 Shadowsocks 管理文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/systemd/system/shadowsocks-server.service</span><br></pre></td></tr></table></figure><p>复制粘贴：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Shadowsocks Server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/local/bin/ssserver -c /etc/shadowsocks/config.json</span><br><span class="line">Restart=on-abort</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>Ctrl + O 保存文件，Ctrl + X 退出<br>启动 Shadowsocks：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start shadowsocks-server</span><br></pre></td></tr></table></figure><p>设置开机启动 Shadowsocks：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable shadowsocks-server</span><br></pre></td></tr></table></figure></li><li><p>优化（主要就是开启 BBR）<br>BBR 系 Google 最新开发的 TCP 拥塞控制算法，目前有着较好的带宽提升效果。</p><p>升级 Linux 内核<br>  BBR 在 Linux kernel 4.9 引入。首先检查服务器 kernel 版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure><p>如果其显示版本在 4.9.0 之下，则需要升级 Linux 内核，否则请忽略下文。</p><p>更新包管理器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><p>查看可用的 Linux 内核版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-cache showpkg linux-image</span><br></pre></td></tr></table></figure><p>找到一个你想要升级的 Linux 内核版本，如“linux-image-4.10.0-22-generic”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install linux-image-4.10.0-22-generic</span><br></pre></td></tr></table></figure><p>等待安装完成后重启服务器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure><p>删除老的 Linux 内核：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo purge-old-kernels</span><br></pre></td></tr></table></figure><p>开启 BBR<br>  运行 <code>lsmod | grep bbr</code>，如果结果中没有 <code>tcp_bbr</code>，则先运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">modprobe tcp_bbr</span><br><span class="line">echo &quot;tcp_bbr&quot; &gt;&gt; /etc/modules-load.d/modules.conf</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;net.core.default_qdisc=fq&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">echo &quot;net.ipv4.tcp_congestion_control=bbr&quot; &gt;&gt; /etc/sysctl.conf</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><p>保存生效。运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sysctl net.ipv4.tcp_available_congestion_control</span><br><span class="line">sysctl net.ipv4.tcp_congestion_control</span><br></pre></td></tr></table></figure><p>若均有 bbr，则开启 BBR 成功。<br>至此，Shadowsock服务器端的基本配置已经全部完成了！</p></li></ul><h2 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h2><p>需要下载shadowsocks客户端<br>mac下载地址：<code>https://github.com/shadowsocks/ShadowsocksX-NG/releases</code><br>windows下载地址：<code>https://github.com/shadowsocks/shadowsocks-windows/releases</code></p><p>在Shadowsocks客户端添加服务器，如果你使用的是我提供的那个配置文件的话，地址填写你的IPv4地址或IPv6地址，端口号为8388，加密方法为aes-256-cfb，密码为你设置的密码。然后设置客户端使用全局模式，浏览器登录Google试试应该能直接打开了。<br>mac下的配置：<br><img src="https://github.com/kaisa911/studyNotes/blob/master/public/image/kehuduan01.png?raw=true" alt="mac下的配置"><br>windows下的配置<br><img src="https://github.com/kaisa911/studyNotes/blob/master/public/image/kehuduan02.png?raw=true" alt="win下的配置"></p><p>在mac下可能需要在偏好设置里设置一下socket5和http代理<br><img src="https://github.com/kaisa911/studyNotes/blob/master/public/image/macpeizhi01.png?raw=true" alt="win下的配置"><br><img src="https://github.com/kaisa911/studyNotes/blob/master/public/image/macpeizhi02.png?raw=true" alt="win下的配置"></p><p>在mac下需要全局模式才能科学上网。可以直接上bt。<br>在window下，代理模式可以科学上网，但是全局模式，外加需要设置一下ut才可以上bt<br>设置utorrent<br>打开设置 -&gt; 连接<br>代理服务选择Http，代理127.0.0.1，端口1080，勾选通过代理服务器解析主机名 和 对于点对点连接使用代理服务器<br>然后点应用，就可以上网了。<br><img src="https://github.com/kaisa911/studyNotes/blob/master/public/image/bt01.png?raw=true" alt="mac上bt"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;整理一下前一段时间研究科学上网的方法。&lt;br&gt;&lt;b style=&quot;font-size: 20px;&quot;&gt;&lt;i&gt;科学上网需要购买国外的服务器, 会有一定的花费, 请自行判断&lt;i&gt;&lt;/i&gt;&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;
&lt;h2 id=&quot;购买服务器&quot;&gt;&lt;a href=&quot;#购买服务器&quot; c
      
    
    </summary>
    
      <category term="Demo练习" scheme="http://yoursite.com/categories/Demo%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="科学上网" scheme="http://yoursite.com/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>函数表达式</title>
    <link href="http://yoursite.com/2018/07/09/%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/07/09/函数表达式/</id>
    <published>2018-07-09T06:57:14.000Z</published>
    <updated>2018-07-10T07:42:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>JS 高程第 7 章，主要讲函数的表达式。主要内容有下面几个：</p><ul><li>函数表达式的特征</li><li>递归</li><li>闭包等问题</li></ul><p>一、函数表达的式的特征：<br>1、函数声明提升<br>具名函数会有函数生命提升，匿名函数，函数表达式，箭头函数声明不能被提升</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数声明提升</span></span><br><span class="line">sayHi();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayHi();</span><br><span class="line"><span class="keyword">const</span> sayHi = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Uncaught ReferenceError: sayHi is not defined</span></span><br><span class="line"></span><br><span class="line">sayHi();</span><br><span class="line"><span class="keyword">const</span> sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Uncaught ReferenceError: sayHi is not defined</span></span><br><span class="line"></span><br><span class="line">sayHi()(<span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>二、递归<br>递归函数就是一个函数通过名字调用自身的情况下构成的</p><p>三、闭包<br>闭包是指有权访问另一个函数作用域中变量的函数。常见的闭包创建方式，是在函数内创建另一个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">plusFive</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">5</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>四、模拟块级作用域<br>ES5 中，可以用匿名函数来模拟块级作用域</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//这里是块级作用域</span></span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">var</span> someFunction = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//这里是块级作用域</span></span><br><span class="line">&#125;;</span><br><span class="line">someFunction();</span><br></pre></td></tr></table></figure><p>五、私有变量<br>严格来讲，JS没有私有成员的概念，所有的属性都是公有的，不过，倒是有一个私有变量的概念<br>任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量。 私有变量包括函数的参数、局部变量和在函数内部定义的其他函数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JS 高程第 7 章，主要讲函数的表达式。主要内容有下面几个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数表达式的特征&lt;/li&gt;
&lt;li&gt;递归&lt;/li&gt;
&lt;li&gt;闭包等问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一、函数表达的式的特征：&lt;br&gt;1、函数声明提升&lt;br&gt;具名函数会有函数生命提升，匿
      
    
    </summary>
    
      <category term="JS高程填坑笔记" scheme="http://yoursite.com/categories/JS%E9%AB%98%E7%A8%8B%E5%A1%AB%E5%9D%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>圣杯布局，双飞翼布局</title>
    <link href="http://yoursite.com/2018/07/03/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%EF%BC%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/"/>
    <id>http://yoursite.com/2018/07/03/圣杯布局，双飞翼布局/</id>
    <published>2018-07-03T05:51:38.000Z</published>
    <updated>2018-07-10T02:09:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>等待填坑</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;等待填坑&lt;/p&gt;

      
    
    </summary>
    
      <category term="面试锦囊" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%94%A6%E5%9B%8A/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>变量、作用域和内存问题</title>
    <link href="http://yoursite.com/2018/06/28/%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/06/28/变量、作用域和内存问题/</id>
    <published>2018-06-28T10:02:07.000Z</published>
    <updated>2018-07-02T03:11:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是JS高程的第四章，讲的是变量，作用域，以及JS的内存问题。<br>现在来填坑<br>本节包括三个部分</p><ul><li>基本类型和引用类型</li><li>执行环境</li><li>垃圾收集</li></ul><h2 id="基本类型和引用类型"><a href="#基本类型和引用类型" class="headerlink" title="基本类型和引用类型"></a>基本类型和引用类型</h2><ul><li>基本类型值：简单的数据段，Undefined，Null，number，string，boolean五种基本类型，在操作的时候，可以操作保存在变量中实际的值。</li><li>引用类型的值是保存在内存中的对象。Js不允许直接访问内存的位置，也就是不允许直接操作对象的内存空间，在操作对象时，复制对象时，操作的时对象的引用，在为对象添加属性时，操作的是对象</li><li>传递参数<br>ES中所有的参数都是按值传递的。基本类型传的值就是变量的值，引用类型传的值是引用内存的地址。</li></ul><h2 id="执行环境与作用域"><a href="#执行环境与作用域" class="headerlink" title="执行环境与作用域"></a>执行环境与作用域</h2><p>全局执行环境，是最外围的一个执行环境。<br>每一个函数都会有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中，而在环境执行结束后，栈将其环境弹出，把控制权返回之前的执行环境。<br>当代码在一个环境中执行时，会产生一个作用域链。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问</p><p>可以通过try-catch 和 with语句来延长作用域链</p><h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><p>垃圾收集一般有两个策略：<br>标记清楚，进入环境和弹出环境分别有标记，清除弹出环境标记的变量或者函数。<br>引用计数，引用为0的会被清除</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是JS高程的第四章，讲的是变量，作用域，以及JS的内存问题。&lt;br&gt;现在来填坑&lt;br&gt;本节包括三个部分&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本类型和引用类型&lt;/li&gt;
&lt;li&gt;执行环境&lt;/li&gt;
&lt;li&gt;垃圾收集&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;基本类型和引用类型&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="JS高程填坑笔记" scheme="http://yoursite.com/categories/JS%E9%AB%98%E7%A8%8B%E5%A1%AB%E5%9D%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>对象深拷贝方法</title>
    <link href="http://yoursite.com/2018/06/25/%E5%AF%B9%E8%B1%A1%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/06/25/对象深拷贝方法/</id>
    <published>2018-06-25T03:34:53.000Z</published>
    <updated>2018-06-28T10:00:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>分享大佬写的深拷贝的方法。。<br>1、JSON.parse(JSON.stringify(obj))<br>这个小方法可以把 obj 里的除了 RegExp 和 function 的属性拷贝下来。function 就忽略了，RegExp 转成{}</p><p>2、大佬们写的两个方法。。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> deepClone = <span class="function"><span class="params">obj</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> innerIterator = <span class="function">(<span class="params">v, key, nb</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (v <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> result = v.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (item <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(item);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">          <span class="keyword">typeof</span> item === <span class="string">'function'</span> ||</span><br><span class="line">          item === <span class="literal">null</span> ||</span><br><span class="line">          <span class="keyword">typeof</span> item !== <span class="string">'object'</span></span><br><span class="line">        ) &#123;</span><br><span class="line">          <span class="keyword">return</span> item;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> innerIterator(item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reduceKeys(item)();</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> key &amp;&amp; nb ? &#123; ...nb, [key]: result &#125; : result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> newObj = reduceKeys(v)();</span><br><span class="line">    <span class="keyword">return</span> &#123; ...nb, [key]: newObj &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> reduceKeys = <span class="function"><span class="params">value</span> =&gt;</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> ks = <span class="built_in">Object</span>.keys(value);</span><br><span class="line">    <span class="keyword">return</span> ks.reduce(<span class="function">(<span class="params">pre, current</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> v = value[current];</span><br><span class="line">      <span class="keyword">if</span> (v <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; ...pre, [current]: <span class="keyword">new</span> <span class="built_in">RegExp</span>(v) &#125;;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">        v === <span class="literal">null</span> ||</span><br><span class="line">        <span class="keyword">typeof</span> v === <span class="string">'function'</span> ||</span><br><span class="line">        <span class="keyword">typeof</span> v !== <span class="string">'object'</span></span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; ...pre, [current]: v &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> innerIterator(v, current, pre);</span><br><span class="line">    &#125;, &#123;&#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> reduceKeys(obj)();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> deepClone = <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> notIn = [<span class="string">'[object Function]'</span>, <span class="string">'[object Object]'</span>, <span class="string">'[object Array]'</span>];</span><br><span class="line">  <span class="keyword">const</span> getType = <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(data);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> isObject = <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getType(data) === <span class="string">'[object Object]'</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> isArray = <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getType(data) === <span class="string">'[object Array]'</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> isFunction = <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getType(data) === <span class="string">'[object Function]'</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result;</span><br><span class="line">  <span class="keyword">if</span> (isObject(data)) &#123;</span><br><span class="line">    result = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> p <span class="keyword">in</span> data) &#123;</span><br><span class="line">      <span class="keyword">if</span> (notIn.includes(getType(data[p]))) &#123;</span><br><span class="line">        result[p] = deepClone(data[p]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result[p] = data[p];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isArray(data)) &#123;</span><br><span class="line">    result = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">of</span> data) &#123;</span><br><span class="line">      <span class="keyword">if</span> (notIn.includes(getType(i))) &#123;</span><br><span class="line">        result.push(deepClone(i));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result.push(i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isFunction(data)) &#123;</span><br><span class="line">    result = data;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;分享大佬写的深拷贝的方法。。&lt;br&gt;1、JSON.parse(JSON.stringify(obj))&lt;br&gt;这个小方法可以把 obj 里的除了 RegExp 和 function 的属性拷贝下来。function 就忽略了，RegExp 转成{}&lt;/p&gt;
&lt;p&gt;2、大佬们
      
    
    </summary>
    
      <category term="Demo练习" scheme="http://yoursite.com/categories/Demo%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
</feed>
