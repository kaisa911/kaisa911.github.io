<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Milestone</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-10T04:46:39.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>啪叽</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>科学上网小记</title>
    <link href="http://yoursite.com/2018/07/10/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E5%B0%8F%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/07/10/科学上网小记/</id>
    <published>2018-07-10T02:10:49.000Z</published>
    <updated>2018-07-10T04:46:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>整理一下前一段时间研究科学上网的方法。<br><b style="font-size: 20px;"><i>科学上网需要购买国外的服务器, 会有一定的花费, 请自行判断<i></i></i></b></p><h2 id="购买服务器"><a href="#购买服务器" class="headerlink" title="购买服务器"></a>购买服务器</h2><p>科学上网是通过 VPS，搭建 ss 或者 ssr 服务器（梯子）来实现的。<br>vps 服务器需要选择国外的（毕竟要翻墙）。一般都会在搬瓦工或者 vultr 购买服务器。<br>我是看了同事在 vultr 买的，我也就在这里买的,感觉还不错，能够随时改变和删除服务器。<br>网站：<code>https://www.vultr.com/</code></p><p>1、注册账号<br><img src="https://github.com/kaisa911/studyNotes/blob/master/public/image/zhucezhanghao.png?raw=true" alt="注册账号"><br>2、充值<br>因为可以用支付宝，我就选择了支付宝支付。<br><img src="https://github.com/kaisa911/studyNotes/blob/master/public/image/chongzhi.png?raw=true" alt="充值"><br>3、购买服务器<br>vultr 官方最近进行了调整，2.5 美元套餐只提供 ipv6，可以用来上 BT，教育网等，但是不能实用 ipv4 的流量，如果你有 ipv4 需求，那么你至少要买 5 美元的套餐。<br>3.1 选择地区<br><img src="https://github.com/kaisa911/studyNotes/blob/master/public/image/fuwuqi01.png?raw=true" alt="选择地区"><br>3.2 选择服务器种类<br>我选的 ubuntu 16.04 x64 版本的，当然也可以选其他的种类，<br><img src="https://github.com/kaisa911/studyNotes/blob/master/public/image/fuwuqi02.png?raw=true" alt="选择服务器种类"><br>3.3 选择服务器大小<br>我当时选的$2.5/mo 的，现在貌似得选$5/mo 的了。。<br><img src="https://github.com/kaisa911/studyNotes/blob/master/public/image/fuwuqi03.png?raw=true" alt="选择服务器大小"><br>然后就可以买了。会得到一个服务器。。<br>服务器列表<br><img src="https://github.com/kaisa911/studyNotes/blob/master/public/image/fuwuqi04.png?raw=true" alt="服务器列表"><br>服务器详情<br><img src="https://github.com/kaisa911/studyNotes/blob/master/public/image/fuwuqi05.png?raw=true" alt="服务器详情"><br>开启 ipv6<br><img src="https://github.com/kaisa911/studyNotes/blob/master/public/image/fuwuqi06.png?raw=true" alt="开启ipv6"></p><p>到这里，购买服务器就一步就可以了。</p><h2 id="搭建-ss-服务"><a href="#搭建-ss-服务" class="headerlink" title="搭建 ss 服务"></a>搭建 ss 服务</h2><p>1、首先需要连接到服务器，可以先 ping 一下 ip 地址看看，能 ping 通应该就可以用，没有 ping 通，就把刚才的服务器换一个。mac 可以用终端直接连接，windows 可以用 git bash，Xshell，Putty 等也都可以<br>连接到远程服务器的方法是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@ip</span><br></pre></td></tr></table></figure><p>ip 就是你新买服务器的 ip，然后会提示让你输入密码，可以把密码复制进去就可以登陆了.<br><img src="https://github.com/kaisa911/studyNotes/blob/master/public/image/lianjie01.png?raw=true" alt="连接服务器"></p><p>2、搭建 ss 服务器<br>我是使用的 ubuntu 的服务器，其他服务器可以 google 其他教程。<br>在刚刚连接的命令行里</p><ul><li><p>安装 pip<br>首先安装 pip3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python3-pip</span><br></pre></td></tr></table></figure></li><li><p>安装 Shadowsocks<br>安装最新版的 Shadowsocks：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install https://github.com/shadowsocks/shadowsocks/archive/master.zip</span><br></pre></td></tr></table></figure><p>查看 Shadowsocks 的版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ssserver --version</span><br></pre></td></tr></table></figure></li><li><p>创建配置文件<br>创建 Shadowsocks 配置文件所在文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /etc/shadowsocks</span><br></pre></td></tr></table></figure><p>创建配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/shadowsocks/config.json</span><br></pre></td></tr></table></figure><p>复制粘贴如下内容（注意修改密码“password”,服务器端口号也可以自行修改）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;server&quot;:&quot;::&quot;,</span><br><span class="line">  &quot;server_port&quot;:8388,</span><br><span class="line">  &quot;local_address&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">  &quot;local_port&quot;:1080,</span><br><span class="line">  &quot;password&quot;:&quot;mypassword&quot;,</span><br><span class="line">  &quot;timeout&quot;:300,</span><br><span class="line">  &quot;method&quot;:&quot;aes-256-cfb&quot;,</span><br><span class="line">  &quot;fast_open&quot;: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后按 Ctrl + O 保存文件，Ctrl + X 退出。</p></li><li><p>测试 Shadowsocks 配置<br>测试下 Shadowsocks 能不能正常工作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssserver -c /etc/shadowsocks/config.json</span><br></pre></td></tr></table></figure><p>测试完毕，按 Ctrl + C 关闭 Shadowsocks。</p></li><li><p>配置 Systemd 管理 Shadowsocks<br>新建 Shadowsocks 管理文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/systemd/system/shadowsocks-server.service</span><br></pre></td></tr></table></figure><p>复制粘贴：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Shadowsocks Server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/local/bin/ssserver -c /etc/shadowsocks/config.json</span><br><span class="line">Restart=on-abort</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>Ctrl + O 保存文件，Ctrl + X 退出<br>启动 Shadowsocks：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start shadowsocks-server</span><br></pre></td></tr></table></figure><p>设置开机启动 Shadowsocks：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable shadowsocks-server</span><br></pre></td></tr></table></figure></li><li><p>优化（主要就是开启 BBR）<br>BBR 系 Google 最新开发的 TCP 拥塞控制算法，目前有着较好的带宽提升效果。</p><p>升级 Linux 内核<br>  BBR 在 Linux kernel 4.9 引入。首先检查服务器 kernel 版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure><p>如果其显示版本在 4.9.0 之下，则需要升级 Linux 内核，否则请忽略下文。</p><p>更新包管理器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><p>查看可用的 Linux 内核版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-cache showpkg linux-image</span><br></pre></td></tr></table></figure><p>找到一个你想要升级的 Linux 内核版本，如“linux-image-4.10.0-22-generic”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install linux-image-4.10.0-22-generic</span><br></pre></td></tr></table></figure><p>等待安装完成后重启服务器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure><p>删除老的 Linux 内核：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo purge-old-kernels</span><br></pre></td></tr></table></figure><p>开启 BBR<br>  运行 <code>lsmod | grep bbr</code>，如果结果中没有 <code>tcp_bbr</code>，则先运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">modprobe tcp_bbr</span><br><span class="line">echo &quot;tcp_bbr&quot; &gt;&gt; /etc/modules-load.d/modules.conf</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;net.core.default_qdisc=fq&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">echo &quot;net.ipv4.tcp_congestion_control=bbr&quot; &gt;&gt; /etc/sysctl.conf</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><p>保存生效。运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sysctl net.ipv4.tcp_available_congestion_control</span><br><span class="line">sysctl net.ipv4.tcp_congestion_control</span><br></pre></td></tr></table></figure><p>若均有 bbr，则开启 BBR 成功。<br>至此，Shadowsock服务器端的基本配置已经全部完成了！</p></li></ul><h2 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h2><p>需要下载shadowsocks客户端<br>mac下载地址：<code>https://github.com/shadowsocks/ShadowsocksX-NG/releases</code><br>windows下载地址：<code>https://github.com/shadowsocks/shadowsocks-windows/releases</code></p><p>在Shadowsocks客户端添加服务器，如果你使用的是我提供的那个配置文件的话，地址填写你的IPv4地址或IPv6地址，端口号为8388，加密方法为aes-256-cfb，密码为你设置的密码。然后设置客户端使用全局模式，浏览器登录Google试试应该能直接打开了。<br>mac下的配置：<br><img src="https://github.com/kaisa911/studyNotes/blob/master/public/image/kehuduan01.png?raw=true" alt="mac下的配置"><br>windows下的配置<br><img src="https://github.com/kaisa911/studyNotes/blob/master/public/image/kehuduan02.png?raw=true" alt="win下的配置"></p><p>在mac下可能需要在偏好设置里设置一下socket5和http代理<br><img src="https://github.com/kaisa911/studyNotes/blob/master/public/image/macpeizhi01.png?raw=true" alt="win下的配置"><br><img src="https://github.com/kaisa911/studyNotes/blob/master/public/image/macpeizhi02.png?raw=true" alt="win下的配置"></p><p>在mac下需要全局模式才能科学上网。可以直接上bt。<br>在window下，代理模式可以科学上网，但是全局模式，外加需要设置一下ut才可以上bt<br>设置utorrent<br>打开设置 -&gt; 连接<br>代理服务选择Http，代理127.0.0.1，端口1080，勾选通过代理服务器解析主机名 和 对于点对点连接使用代理服务器<br>然后点应用，就可以上网了。<br><img src="https://github.com/kaisa911/studyNotes/blob/master/public/image/bt01.png?raw=true" alt="mac上bt"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;整理一下前一段时间研究科学上网的方法。&lt;br&gt;&lt;b style=&quot;font-size: 20px;&quot;&gt;&lt;i&gt;科学上网需要购买国外的服务器, 会有一定的花费, 请自行判断&lt;i&gt;&lt;/i&gt;&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;
&lt;h2 id=&quot;购买服务器&quot;&gt;&lt;a href=&quot;#购买服务器&quot; c
      
    
    </summary>
    
      <category term="Demo练习" scheme="http://yoursite.com/categories/Demo%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="科学上网" scheme="http://yoursite.com/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>函数表达式</title>
    <link href="http://yoursite.com/2018/07/09/%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/07/09/函数表达式/</id>
    <published>2018-07-09T06:57:14.000Z</published>
    <updated>2018-07-10T07:42:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>JS 高程第 7 章，主要讲函数的表达式。主要内容有下面几个：</p><ul><li>函数表达式的特征</li><li>递归</li><li>闭包等问题</li></ul><p>一、函数表达的式的特征：<br>1、函数声明提升<br>具名函数会有函数生命提升，匿名函数，函数表达式，箭头函数声明不能被提升</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数声明提升</span></span><br><span class="line">sayHi();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayHi();</span><br><span class="line"><span class="keyword">const</span> sayHi = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Uncaught ReferenceError: sayHi is not defined</span></span><br><span class="line"></span><br><span class="line">sayHi();</span><br><span class="line"><span class="keyword">const</span> sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Uncaught ReferenceError: sayHi is not defined</span></span><br><span class="line"></span><br><span class="line">sayHi()(<span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>二、递归<br>递归函数就是一个函数通过名字调用自身的情况下构成的</p><p>三、闭包<br>闭包是指有权访问另一个函数作用域中变量的函数。常见的闭包创建方式，是在函数内创建另一个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">plusFive</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">5</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>四、模拟块级作用域<br>ES5 中，可以用匿名函数来模拟块级作用域</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//这里是块级作用域</span></span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">var</span> someFunction = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//这里是块级作用域</span></span><br><span class="line">&#125;;</span><br><span class="line">someFunction();</span><br></pre></td></tr></table></figure><p>五、私有变量<br>严格来讲，JS没有私有成员的概念，所有的属性都是公有的，不过，倒是有一个私有变量的概念<br>任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量。 私有变量包括函数的参数、局部变量和在函数内部定义的其他函数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JS 高程第 7 章，主要讲函数的表达式。主要内容有下面几个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数表达式的特征&lt;/li&gt;
&lt;li&gt;递归&lt;/li&gt;
&lt;li&gt;闭包等问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一、函数表达的式的特征：&lt;br&gt;1、函数声明提升&lt;br&gt;具名函数会有函数生命提升，匿
      
    
    </summary>
    
      <category term="JS高程填坑笔记" scheme="http://yoursite.com/categories/JS%E9%AB%98%E7%A8%8B%E5%A1%AB%E5%9D%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>圣杯布局，双飞翼布局</title>
    <link href="http://yoursite.com/2018/07/03/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%EF%BC%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/"/>
    <id>http://yoursite.com/2018/07/03/圣杯布局，双飞翼布局/</id>
    <published>2018-07-03T05:51:38.000Z</published>
    <updated>2018-07-10T02:09:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>等待填坑</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;等待填坑&lt;/p&gt;

      
    
    </summary>
    
      <category term="面试锦囊" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%94%A6%E5%9B%8A/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>变量、作用域和内存问题</title>
    <link href="http://yoursite.com/2018/06/28/%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/06/28/变量、作用域和内存问题/</id>
    <published>2018-06-28T10:02:07.000Z</published>
    <updated>2018-07-02T03:11:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是JS高程的第四章，讲的是变量，作用域，以及JS的内存问题。<br>现在来填坑<br>本节包括三个部分</p><ul><li>基本类型和引用类型</li><li>执行环境</li><li>垃圾收集</li></ul><h2 id="基本类型和引用类型"><a href="#基本类型和引用类型" class="headerlink" title="基本类型和引用类型"></a>基本类型和引用类型</h2><ul><li>基本类型值：简单的数据段，Undefined，Null，number，string，boolean五种基本类型，在操作的时候，可以操作保存在变量中实际的值。</li><li>引用类型的值是保存在内存中的对象。Js不允许直接访问内存的位置，也就是不允许直接操作对象的内存空间，在操作对象时，复制对象时，操作的时对象的引用，在为对象添加属性时，操作的是对象</li><li>传递参数<br>ES中所有的参数都是按值传递的。基本类型传的值就是变量的值，引用类型传的值是引用内存的地址。</li></ul><h2 id="执行环境与作用域"><a href="#执行环境与作用域" class="headerlink" title="执行环境与作用域"></a>执行环境与作用域</h2><p>全局执行环境，是最外围的一个执行环境。<br>每一个函数都会有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中，而在环境执行结束后，栈将其环境弹出，把控制权返回之前的执行环境。<br>当代码在一个环境中执行时，会产生一个作用域链。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问</p><p>可以通过try-catch 和 with语句来延长作用域链</p><h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><p>垃圾收集一般有两个策略：<br>标记清楚，进入环境和弹出环境分别有标记，清除弹出环境标记的变量或者函数。<br>引用计数，引用为0的会被清除</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是JS高程的第四章，讲的是变量，作用域，以及JS的内存问题。&lt;br&gt;现在来填坑&lt;br&gt;本节包括三个部分&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本类型和引用类型&lt;/li&gt;
&lt;li&gt;执行环境&lt;/li&gt;
&lt;li&gt;垃圾收集&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;基本类型和引用类型&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="JS高程填坑笔记" scheme="http://yoursite.com/categories/JS%E9%AB%98%E7%A8%8B%E5%A1%AB%E5%9D%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>对象深拷贝方法</title>
    <link href="http://yoursite.com/2018/06/25/%E5%AF%B9%E8%B1%A1%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/06/25/对象深拷贝方法/</id>
    <published>2018-06-25T03:34:53.000Z</published>
    <updated>2018-06-28T10:00:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>分享大佬写的深拷贝的方法。。<br>1、JSON.parse(JSON.stringify(obj))<br>这个小方法可以把 obj 里的除了 RegExp 和 function 的属性拷贝下来。function 就忽略了，RegExp 转成{}</p><p>2、大佬们写的两个方法。。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> deepClone = <span class="function"><span class="params">obj</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> innerIterator = <span class="function">(<span class="params">v, key, nb</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (v <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> result = v.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (item <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(item);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">          <span class="keyword">typeof</span> item === <span class="string">'function'</span> ||</span><br><span class="line">          item === <span class="literal">null</span> ||</span><br><span class="line">          <span class="keyword">typeof</span> item !== <span class="string">'object'</span></span><br><span class="line">        ) &#123;</span><br><span class="line">          <span class="keyword">return</span> item;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> innerIterator(item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reduceKeys(item)();</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> key &amp;&amp; nb ? &#123; ...nb, [key]: result &#125; : result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> newObj = reduceKeys(v)();</span><br><span class="line">    <span class="keyword">return</span> &#123; ...nb, [key]: newObj &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> reduceKeys = <span class="function"><span class="params">value</span> =&gt;</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> ks = <span class="built_in">Object</span>.keys(value);</span><br><span class="line">    <span class="keyword">return</span> ks.reduce(<span class="function">(<span class="params">pre, current</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> v = value[current];</span><br><span class="line">      <span class="keyword">if</span> (v <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; ...pre, [current]: <span class="keyword">new</span> <span class="built_in">RegExp</span>(v) &#125;;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">        v === <span class="literal">null</span> ||</span><br><span class="line">        <span class="keyword">typeof</span> v === <span class="string">'function'</span> ||</span><br><span class="line">        <span class="keyword">typeof</span> v !== <span class="string">'object'</span></span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; ...pre, [current]: v &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> innerIterator(v, current, pre);</span><br><span class="line">    &#125;, &#123;&#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> reduceKeys(obj)();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> deepClone = <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> notIn = [<span class="string">'[object Function]'</span>, <span class="string">'[object Object]'</span>, <span class="string">'[object Array]'</span>];</span><br><span class="line">  <span class="keyword">const</span> getType = <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(data);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> isObject = <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getType(data) === <span class="string">'[object Object]'</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> isArray = <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getType(data) === <span class="string">'[object Array]'</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> isFunction = <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getType(data) === <span class="string">'[object Function]'</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result;</span><br><span class="line">  <span class="keyword">if</span> (isObject(data)) &#123;</span><br><span class="line">    result = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> p <span class="keyword">in</span> data) &#123;</span><br><span class="line">      <span class="keyword">if</span> (notIn.includes(getType(data[p]))) &#123;</span><br><span class="line">        result[p] = deepClone(data[p]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result[p] = data[p];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isArray(data)) &#123;</span><br><span class="line">    result = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">of</span> data) &#123;</span><br><span class="line">      <span class="keyword">if</span> (notIn.includes(getType(i))) &#123;</span><br><span class="line">        result.push(deepClone(i));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result.push(i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isFunction(data)) &#123;</span><br><span class="line">    result = data;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;分享大佬写的深拷贝的方法。。&lt;br&gt;1、JSON.parse(JSON.stringify(obj))&lt;br&gt;这个小方法可以把 obj 里的除了 RegExp 和 function 的属性拷贝下来。function 就忽略了，RegExp 转成{}&lt;/p&gt;
&lt;p&gt;2、大佬们
      
    
    </summary>
    
      <category term="Demo练习" scheme="http://yoursite.com/categories/Demo%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>项目action封装</title>
    <link href="http://yoursite.com/2018/06/25/%E9%A1%B9%E7%9B%AEaction%E5%B0%81%E8%A3%85/"/>
    <id>http://yoursite.com/2018/06/25/项目action封装/</id>
    <published>2018-06-25T02:37:11.000Z</published>
    <updated>2018-06-28T10:00:35.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> callApi <span class="keyword">from</span> <span class="string">'../../utils/callApi'</span>;</span><br><span class="line"><span class="keyword">import</span> api <span class="keyword">from</span> <span class="string">'../../api'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * callApi</span></span><br><span class="line"><span class="comment"> * @param dispatch</span></span><br><span class="line"><span class="comment"> * @param formData </span></span><br><span class="line"><span class="comment"> * @param requestUrl</span></span><br><span class="line"><span class="comment"> * @param type  设置action的type</span></span><br><span class="line"><span class="comment"> * @returns &#123;function(*)&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> commonCallApi = <span class="function">(<span class="params">dispatch, formData, requestUrl, type</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> callApi.post(requestUrl, formData).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.code === <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> data = type</span><br><span class="line">        ? dispatch(&#123;</span><br><span class="line">            type,</span><br><span class="line">            data: res.data</span><br><span class="line">          &#125;)</span><br><span class="line">        : res;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(res);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 公共action</span></span><br><span class="line"><span class="comment"> * @param requestUrl</span></span><br><span class="line"><span class="comment"> * @param formData</span></span><br><span class="line"><span class="comment"> * @param type  设置action的type</span></span><br><span class="line"><span class="comment"> * @returns &#123;function(*)&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> commonAction = <span class="function">(<span class="params">requestUrl, formData, type</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">dispatch</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> commonCallApi(dispatch, requestUrl, formData, type);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取列表</span></span><br><span class="line"><span class="comment"> * @param formData</span></span><br><span class="line"><span class="comment"> * @returns &#123;function(*)&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> getList = <span class="function"><span class="params">formData</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> commonAction(api.getList, formData, <span class="string">'get_list'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  getList</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span 
      
    
    </summary>
    
      <category term="Demo练习" scheme="http://yoursite.com/categories/Demo%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="Javascript redux" scheme="http://yoursite.com/tags/Javascript-redux/"/>
    
  </entry>
  
  <entry>
    <title>对象字面量声明和构造函数声明的比较</title>
    <link href="http://yoursite.com/2018/06/20/%E5%AF%B9%E8%B1%A1%E5%AD%97%E9%9D%A2%E9%87%8F%E5%A3%B0%E6%98%8E%E5%92%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E7%9A%84%E6%AF%94%E8%BE%83/"/>
    <id>http://yoursite.com/2018/06/20/对象字面量声明和构造函数声明的比较/</id>
    <published>2018-06-20T15:58:01.000Z</published>
    <updated>2018-06-28T10:00:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>去某家面试的时候，在笔试的时候，看到了这个问题，回来研究一下。<br>JS 中有很多种对象的声明方式，一般我用到的也就是这两种，通过字面量来声明对象和通过构造函数来声明对象。</p><h2 id="用字面量来声明对象"><a href="#用字面量来声明对象" class="headerlink" title="用字面量来声明对象"></a>用字面量来声明对象</h2><p>我们可以直接在创建对象的时候添加功能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">'paji'</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  sex: <span class="string">'male'</span>,</span><br><span class="line">  speak: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'大家好'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>或者在一开始先声明一个空的对象，当然这个空对象也不是空对象，也是从 object 上继承了好多 object 的属性，只是没有自有属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;&#125;,</span><br><span class="line">person.name = <span class="string">'paji'</span>;</span><br><span class="line">person.age = <span class="number">18</span>;</span><br><span class="line">person.sex = <span class="string">'male'</span>;</span><br><span class="line">person.speak = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'大家好'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用构造函数声明对象"><a href="#用构造函数声明对象" class="headerlink" title="用构造函数声明对象"></a>用构造函数声明对象</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">'paji'</span>;</span><br><span class="line">person.age = <span class="number">18</span>;</span><br><span class="line">person.sex = <span class="string">'male'</span>;</span><br><span class="line">person.speak = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'大家好'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="字面量的优势"><a href="#字面量的优势" class="headerlink" title="字面量的优势"></a>字面量的优势</h2><ul><li>代码量更少，更易读</li><li>强调对象就是一个简单的可变的散列表，而不必一定派生自某个类</li><li>对象字面量运行速度更快，因为它们可以在解析的时候被优化：它们不需要”作用域解析(scope resolution)”；因为存在我们创建了一个同名的构造函数Object()的可能，当我们调用Object()的时候，解析器需要顺着作用域链从当前作用域开始查找，如果在当前作用域找到了名为Object()的函数就执行，如果没找到，就继续顺着作用域链往上照，直到找到全局Object()构造函数为止</li><li>Object()构造函数可以接收参数，通过这个参数可以把对象实例的创建过程委托给另一个内置构造函数，并返回另外一个对象实例，而这往往不是你想要的。</li></ul><p><b><i>尽量用对象字面量的方式来创建对象</i></b></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;去某家面试的时候，在笔试的时候，看到了这个问题，回来研究一下。&lt;br&gt;JS 中有很多种对象的声明方式，一般我用到的也就是这两种，通过字面量来声明对象和通过构造函数来声明对象。&lt;/p&gt;
&lt;h2 id=&quot;用字面量来声明对象&quot;&gt;&lt;a href=&quot;#用字面量来声明对象&quot; class
      
    
    </summary>
    
      <category term="面试锦囊" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%94%A6%E5%9B%8A/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>JS包装对象</title>
    <link href="http://yoursite.com/2018/06/19/JS%E5%8C%85%E8%A3%85%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2018/06/19/JS包装对象/</id>
    <published>2018-06-19T07:35:19.000Z</published>
    <updated>2018-06-25T02:29:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>Q1: 什么是包装对象？<br>A1: JS 的数值，布尔，字符串类型的变量，在一定条件下，也可以自动变成对象，这就是原始类型的包装对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'hello world'</span>);</span><br></pre></td></tr></table></figure><p>Q2: 包装对象和同样的原始类型的值相等么，这么做有什么目的？<br>A2: 不想等。包装对象的最大目的，首先是使得 JavaScript 的对象涵盖所有的值，其次使得原始类型的值可以方便地调用某些方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> a; <span class="comment">//'object'</span></span><br><span class="line"><span class="keyword">typeof</span> b; <span class="comment">//'object'</span></span><br><span class="line"><span class="keyword">typeof</span> c; <span class="comment">//'object'</span></span><br><span class="line"></span><br><span class="line">a === <span class="number">-1</span>; <span class="comment">//false</span></span><br><span class="line">b === <span class="literal">true</span>; <span class="comment">//false;</span></span><br><span class="line">c === <span class="string">'hello world'</span>; <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>Q3: 包装对象有什么实例方法？<br>A3: 包装对象可以使用 object 对象提供的原生的方法，其中主要的就是 valueOf()和 toString()方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a.valueOf(); <span class="comment">//-1</span></span><br><span class="line">b.valueOf(); <span class="comment">//true</span></span><br><span class="line">b.valueOf(); <span class="comment">//'hello world'</span></span><br><span class="line"></span><br><span class="line">a.toString(); <span class="comment">//'-1'</span></span><br><span class="line">b.toString(); <span class="comment">//'true'</span></span><br><span class="line">b.toString(); <span class="comment">//'hello world'</span></span><br></pre></td></tr></table></figure><p>Q4: 原始类型和实例对象怎么转换？<br>A4: 原始类型的值，可以自动当作包装对象调用，即调用各种包装对象的属性和方法。这时，JavaScript 引擎会自动将原始类型的值转为包装对象实例，在使用后立刻销毁实例。<br>自动转换生成的包装对象是只读的，无法修改。所以，字符串无法添加新属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'Hello World'</span>;</span><br><span class="line">s.x = <span class="number">123</span>;</span><br><span class="line">s.x; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>另一方面，调用结束后，包装对象实例会自动销毁。这意味着，下一次调用字符串的属性时，实际是调用一个新生成的对象，而不是上一次调用时生成的那个对象，所以取不到赋值在上一个对象的属性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Q1: 什么是包装对象？&lt;br&gt;A1: JS 的数值，布尔，字符串类型的变量，在一定条件下，也可以自动变成对象，这就是原始类型的包装对象。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt
      
    
    </summary>
    
      <category term="面试锦囊" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%94%A6%E5%9B%8A/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript基本概念（四）</title>
    <link href="http://yoursite.com/2018/06/19/Javascript%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://yoursite.com/2018/06/19/Javascript基本概念（四）/</id>
    <published>2018-06-19T06:32:32.000Z</published>
    <updated>2018-06-19T09:15:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是 JS 高程第三章的第四部分。<br>本节的主要内容是</p><ul><li>语句</li><li>函数</li></ul><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3><p><code>if (condition) statement1 else statement2</code><br>eg:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">25</span>) &#123;</span><br><span class="line">  alert(<span class="string">'Greater than 25.'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  alert(<span class="string">'Less than 0.'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  alert(<span class="string">'Between 0 and 25, inclusive.'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="do-while-语句"><a href="#do-while-语句" class="headerlink" title="do-while 语句"></a>do-while 语句</h3><p>后测试循环语句</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  statement;</span><br><span class="line">&#125; <span class="keyword">while</span> (expression);</span><br></pre></td></tr></table></figure><h3 id="while-语句"><a href="#while-语句" class="headerlink" title="while 语句"></a>while 语句</h3><p>前测试循环语句<br><code>while(expression) statement</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">  i += <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h3><p>前测试循环语句<br><code>for (initialization; expression; post-loop-expression) statement</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">  alert(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="for-in-语句"><a href="#for-in-语句" class="headerlink" title="for-in 语句"></a>for-in 语句</h3><p>精准迭代语句，可以用来枚举对象属性<br><code>for (property in expression) statement</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> propName <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</span><br><span class="line">  <span class="built_in">document</span>.write(propName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="label-语句"><a href="#label-语句" class="headerlink" title="label 语句"></a>label 语句</h3><p><code>label: statement</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start: <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">  alert(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中的 start 标签，可以在将来由 break 和 continue 语句引用，加标签的语句一般都要与 for 语句等循环语句配合使用。</p><h3 id="break-和-continue-语句"><a href="#break-和-continue-语句" class="headerlink" title="break 和 continue 语句"></a>break 和 continue 语句</h3><p>break 语句会立即跳出循环，然后执行循环后的代码<br>continue 语句会跳出循环，然后从循环顶部开始执行循环。</p><h3 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression) &#123;</span><br><span class="line">  <span class="keyword">case</span> value:</span><br><span class="line">    statement;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> value:</span><br><span class="line">    statement;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> value:</span><br><span class="line">    statement;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>ES 中采用 function 来声明一个函数，后面跟一组参数和函数体，函数会在执行完 return 语句之后停止并立即退出。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionName</span>(<span class="params">arg0, arg1,...,argN</span>) </span>&#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参数理解"><a href="#参数理解" class="headerlink" title="参数理解"></a>参数理解</h3><p>函数内部通过一个数组arguments来接收参数。arguments对象只是与数组很像，但是并不是Array的实例。<br>可以用arguments[0]来获取内部的元素。<br>ECMAScript 中的所有的参数传递的都是值，不可能通过引用传递参数</p><h3 id="没有重载"><a href="#没有重载" class="headerlink" title="没有重载"></a>没有重载</h3><p>ES中的函数没有重载</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是 JS 高程第三章的第四部分。&lt;br&gt;本节的主要内容是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;语句&lt;/li&gt;
&lt;li&gt;函数&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;语句&quot;&gt;&lt;a href=&quot;#语句&quot; class=&quot;headerlink&quot; title=&quot;语句&quot;&gt;&lt;/a&gt;语句&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="JS高程填坑笔记" scheme="http://yoursite.com/categories/JS%E9%AB%98%E7%A8%8B%E5%A1%AB%E5%9D%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 基本概念（三）</title>
    <link href="http://yoursite.com/2018/06/13/Javascript%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2018/06/13/Javascript基本概念（三）/</id>
    <published>2018-06-13T15:27:09.000Z</published>
    <updated>2018-06-19T03:25:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是JS高程第三章的第三部分。这一章内容是真的多。。我觉得重新刷高程，对我来说，也是一种不一样的进步吧。<br>本节的主要内容是</p><ul><li>操作符</li></ul><h2 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符"></a>一元操作符</h2><p>只能操作一个一个值的操作符叫做<b>一元操作符</b>。<br>1、递增递减操作符<br>  有两个版本，前置型和后置型。<br>  前置型，先操作，后执行。<br>  后置型，先执行，后操作。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">5</span>, b = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> sum = ++a + b;</span><br><span class="line"><span class="keyword">let</span> sum2 = a++ + b;</span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">//12</span></span><br><span class="line"><span class="built_in">console</span>.log(sum2) <span class="comment">//12</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//7</span></span><br></pre></td></tr></table></figure></p><p>  递增递减操作符对数值，布尔，字符串，对象都有作用！！！！！<br>  规则如下：</p><ul><li>如果字符串包含有效数字，则先转化成数值变量，然后加减1；不包含有效数字，则转化成NaN。字符串变量变成数值变量</li><li>数值变量加减1；</li><li>布尔变量，true先变成1，false变成0，然后加减1,布尔变了转换成数值变量；</li><li>对象变量，先查看valueOf()方法，如果是NaN，则调用toString()，对象转换成数值变量。</li></ul><p>2、一元加减操作符。<br>  一元+操作符，会像Number()方法一样对变量转换成数值变量<code>var a; a = +a</code>;<br>  一元-操作符，主要是变成负数。会像Number()方法一样，不过是负数。</p><h2 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h2><p>首先ES里所有的数值都是有64位来储存，但是位操作符并不是操作64位，而是先转化成32位的整数，然后操作，再将结果转换成64位的，这样，NaN和Infinity就会变成0。<br>对于有符号数，第32位是符号位，0代表正数，1代表负数，符号位决定了其他位数值的格式。剩下31位用来储存数据。<br>正数都是以二进制格式存储，负数以二进制的补码格式存储。默认情况下，ES里所有的正数都是有符号数。<br>无符号数，第32位是数值。但是无符号数只能是正数。<br>位操作符对其他变量，会先用Number()方法变成数值，然后再按位操作。<br>1、按位非（NOT）<br>  按位非是用～表示，执行按位非的结果是返回数值的反码。<br>2、按位与（AND）<br>  按位与是用&amp;表示，它有两个操作符数，运算的时候，将两个数的二进制每一位对齐，都是1得1，其他为0；<br>3、按位或（OR）<br>  按位或是用|表示，它有两个操作符数，运算的时候，将两个数的二进制每一位对齐，都是0得0，其他为1；<br>4、按位异或（XOR）<br>  按位或是用^表示，它有两个操作符数，运算的时候，将两个数的二进制每一位对齐，相同得0，不同为1；<br>5、左移<br>  左移用&lt;&lt;表示，会将数值所有位数向左移动指定的位数。后面补0；左移不会影响符号。<br>6、有符号右移<br>  有符号右移用&gt;&gt;表示，会将数值所有位数向右移动指定的位数。前面补0；保留符号位，不会影响符号。<br>7、无符号右移<br>  无符号右移用&gt;&gt;&gt;表示，会将数值所有位数向右移动指定的位数。前面补0；会影响符号。而且会把负数的补码当成二进制码来运算。</p><h2 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h2><p>布尔运算符有三个，主要用来测试值的关系<br>1、逻辑非(!)<br>这个操作符会返回一个布尔值，逻辑非运算会将操作数先转换成布尔值，然后求反。</p><ul><li>操作数是对象，返回false</li><li>操作数是空字符串，返回true</li><li>操作数是非空字符串，返回false</li><li>操作数是非0数值，返回false</li><li>操作数是0，null，NaN，undefined，返回true</li></ul><p>2、逻辑与(&amp;&amp;)<br>逻辑与操作符两边有两个操作数。都是true才为true。<br>逻辑与操作可以应用于所有变量，在有一个操作数不是布尔值的情况下，逻辑与不一定会返回布尔值。<br>规则：</p><ul><li>如果第一个操作数是对象，则返回第二个操作数</li><li>如果第二个操作数是对象，则必须第一个操作数是true才会返回该对象。</li><li>如果两个数都是对象，则返回第二个操作数</li><li>如果有一个操作数是null，NaN，undefined，则返回null，NaN，undefined。</li></ul><p>逻辑与属于短路操作，第一个操作数能决定结果，就不会对第二个操作数求值。</p><p>3、逻辑或(||)<br>逻辑或两边有两个操作数，有一个为true就是true。<br>逻辑或操作可以应用于所有变量，在有一个操作数不是布尔值的情况下，逻辑与不一定会返回布尔值。<br>规则：</p><ul><li>如果第一个操作数是对象，则返回第一个操作数</li><li>如果第一个操作数是false，则返回第二个操作数</li><li>两个操作数都是对象，则返回第一个操作数</li><li>如果两个操作数是null，NaN，undefined，则返回null，NaN，undefined。</li></ul><h2 id="乘性操作符"><a href="#乘性操作符" class="headerlink" title="乘性操作符"></a>乘性操作符</h2><p>ES有三个乘性操作符，乘法，除法和求模。<br>如果乘性操作符的某一个操作数不是数值，则将会用Number()方法，先转换成数值。<br>1、乘法(*)<br>规则：</p><ul><li>乘积超过限制，则显示Infinity或者-Infinity</li><li>有一个操作数为NaN，结果为NaN</li><li>Infinity与0相乘，结果是NaN</li><li>Infinity与非0数相乘，结果是Infinity或者-Infinity</li><li>Infinity与Infinity相乘，结果是Infinity</li></ul><p>2、除法(/)<br>规则：</p><ul><li>Infinity与Infinity相除，结果是NaN</li><li>0/0结果是NaN</li><li>其他操作数／0 结果是Infinity或者-Infinity</li></ul><p>3、求模(%)<br>规则：</p><ul><li>Infinity%操作数 结果是NaN</li><li>操作数%0，结果是NaN</li><li>Infinity%Infinity，结果是NaN</li><li>操作数%Infinity，结果是操作数</li></ul><h2 id="加性操作符"><a href="#加性操作符" class="headerlink" title="加性操作符"></a>加性操作符</h2><p>ES中有两个加性操作符，加法和减法<br>1、加法(+)<br>规则：</p><ul><li>有一个操作数是NaN，结果就是NaN</li><li>Infinity + Infinity = Infinity</li><li>-Infinity + -Infinity = -Infinity</li><li>Infinity + -Infinity = NaN</li><li>+0 + +0 = +0</li><li>-0 + -0 = -0</li><li>+0 + -0 = +0</li><li>两个操作数都是字符串，则将字符串拼接起来</li><li>只有一个操作数是字符串，另一个操作数则会转换成字符串，然后拼接起来。</li></ul><p>2、减法(-)<br>规则：</p><ul><li>Infinity - Infinity = NaN</li><li>-Infinity - -Infinity = NaN</li><li>Infinity - -Infinity = Infinity</li><li>-Infinity - Infinity = -Infinity</li></ul><h2 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h2><p>关系操作符有大于(&gt;)，小于(&lt;),小于等于(&lt;=),大于等于(&gt;=)<br>规则：</p><ul><li>都是数值，执行数值比较</li><li>都是字符串，执行字符串编码比较</li><li>一个是数值，则另一个转换成数值比较</li></ul><h2 id="相等操作符"><a href="#相等操作符" class="headerlink" title="相等操作符"></a>相等操作符</h2><p>ES中提供了两种相等操作符：<br>相等操作符：先转换再比较<br>全等操作符：不转换只比较<br>1、相等操作符(==,!=),强制转型，然后比较。<br>规则：</p><ul><li>如果有一个是布尔类型的操作数，则先转换成数值。</li><li>如果有一个是数值，一个是字符串，则将字符串转换成数值</li><li>如果有一个是对象，则用valueOf转成基本类型比较</li><li>null 和undefined 相等</li><li>如果有一个操作数是NaN，则==返回false，!=返回true</li><li>如果都是对象，则比较两个对象是不是一个对象，是否来指向同一个对象。</li></ul><p>2、全等操作符(===,!==),不转换，只比较。<br>规则：</p><ul><li>只要是完全一样就为true，其他为false。</li></ul><p>##条件操作符<br>ES中的条件操作符(?:)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable ? <span class="built_in">console</span>.log(<span class="literal">true</span>): <span class="built_in">console</span>.log(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure></p><p>##赋值操作符<br>其中有+= ，-=，*=，／=，%=，&lt;&lt;=, &gt;&gt;=, &gt;&gt;&gt;=</p><p>##逗号操作符<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span>;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是JS高程第三章的第三部分。这一章内容是真的多。。我觉得重新刷高程，对我来说，也是一种不一样的进步吧。&lt;br&gt;本节的主要内容是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作符&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;一元操作符&quot;&gt;&lt;a href=&quot;#一元操作符&quot; class=&quot;heade
      
    
    </summary>
    
      <category term="JS高程填坑笔记" scheme="http://yoursite.com/categories/JS%E9%AB%98%E7%A8%8B%E5%A1%AB%E5%9D%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>display的属性们</title>
    <link href="http://yoursite.com/2018/06/13/display%E7%9A%84%E5%B1%9E%E6%80%A7%E4%BB%AC/"/>
    <id>http://yoursite.com/2018/06/13/display的属性们/</id>
    <published>2018-06-13T03:11:58.000Z</published>
    <updated>2018-06-28T10:00:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>display： none | inline | block | list-item | inline-block | table | inline-table | table-caption | table-cell | table-row | table-row-group | table-column | table-column-group | table-footer-group | table-header-group | run-in | box | inline-box | flexbox | inline-flexbox | flex | inline-flex<br>默认值：inline</p><p>none： 隐藏对象。与visibility属性的hidden值不同，其不为被隐藏的对象保留其物理空间<br>inline： 指定对象为内联元素。<br>block： 指定对象为块元素。<br>list-item： 指定对象为列表项目。<br>inline-block： 指定对象为内联块元素。（CSS2）<br>table： 指定对象作为块元素级的表格。类同于html标签&lt;table&gt;（CSS2）<br>inline-table： 指定对象作为内联元素级的表格。类同于html标签&lt;table&gt;（CSS2）<br>table-caption： 指定对象作为表格标题。类同于html标签&lt;caption&gt;（CSS2）<br>table-cell： 指定对象作为表格单元格。类同于html标签&lt;td&gt;（CSS2）<br>table-row： 指定对象作为表格行。类同于html标签&lt;tr&gt;（CSS2）<br>table-row-group： 指定对象作为表格行组。类同于html标签&lt;tbody&gt;（CSS2）<br>table-column： 指定对象作为表格列。类同于html标签&lt;col&gt;（CSS2）<br>table-column-group： 指定对象作为表格列组显示。类同于html标签&lt;colgroup&gt;（CSS2）<br>table-header-group： 指定对象作为表格标题组。类同于html标签&lt;thead&gt;（CSS2）<br>table-footer-group： 指定对象作为表格脚注组。类同于html标签&lt;tfoot&gt;（CSS2）<br>run-in： 根据上下文决定对象是内联对象还是块级对象。（CSS3）<br>box： 将对象作为弹性伸缩盒显示。（伸缩盒最老版本）（CSS3）<br>inline-box： 将对象作为内联块级弹性伸缩盒显示。（伸缩盒最老版本）（CSS3）<br>flexbox： 将对象作为弹性伸缩盒显示。（伸缩盒过渡版本）（CSS3）<br>inline-flexbox： 将对象作为内联块级弹性伸缩盒显示。（伸缩盒过渡版本）（CSS3）<br>flex： 将对象作为弹性伸缩盒显示。（伸缩盒最新版本）（CSS3）<br>inline-flex： 将对象作为内联块级弹性伸缩盒显示。（伸缩盒最新版本）（CSS3）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;display： none | inline | block | list-item | inline-block | table | inline-table | table-caption | table-cell | table-row | table-row-gro
      
    
    </summary>
    
      <category term="面试锦囊" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%94%A6%E5%9B%8A/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>link和@import之争</title>
    <link href="http://yoursite.com/2018/06/13/link%E5%92%8C-import%E4%B9%8B%E4%BA%89/"/>
    <id>http://yoursite.com/2018/06/13/link和-import之争/</id>
    <published>2018-06-13T02:52:26.000Z</published>
    <updated>2018-06-13T03:05:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>看到知乎大神说，先问是不是，再问为什么</p><p>我页不知道为什么要写这句话，反正就是很奇怪的想法，就先记下来。<br>今天研究的link和@import，是外部引入外部引入 CSS 的两种方式。<br>两者是有区别的（是不是）。<br>我们来研究一下有哪些区别（为什么）</p><ul><li>link是XHTML(HTML)标签，除了加载CSS外，还可以定义RSS,rel等其他事务； @import是 CSS 提供的语法规则, 只有导入样式表的作用。</li><li>link引用CSS时，在页面载入时同时加载； @import需要页面网页完全载入以后加载。</li><li>link是XHTML(HTML)标签，无兼容问题； @import是在CSS2.1提出的，低版本的浏览器不支持(IE5+)。</li><li>link支持使用Javascript控制DOM去改变样式；而@import不支持。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"style.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">  @<span class="keyword">import</span> url(style.css);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看到知乎大神说，先问是不是，再问为什么&lt;/p&gt;
&lt;p&gt;我页不知道为什么要写这句话，反正就是很奇怪的想法，就先记下来。&lt;br&gt;今天研究的link和@import，是外部引入外部引入 CSS 的两种方式。&lt;br&gt;两者是有区别的（是不是）。&lt;br&gt;我们来研究一下有哪些区别（为什么
      
    
    </summary>
    
      <category term="面试锦囊" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%94%A6%E5%9B%8A/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Javascript基本概念(二）</title>
    <link href="http://yoursite.com/2018/06/11/Javascript%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2018/06/11/Javascript基本概念（二）/</id>
    <published>2018-06-11T06:20:09.000Z</published>
    <updated>2018-06-19T06:31:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>JS高程的第三章第二节，对数据类型进行一下学习</p><p>JS有五种基本数据类型：Number，String，Boolean，Undefined，Null和一种复杂类型：Object，Object本质上是由一组无序的名值对组成的（说好的万物皆对象来着）。JS不支持任何创建自定义类型的机制。</p><h2 id="typeof-操作符"><a href="#typeof-操作符" class="headerlink" title="typeof 操作符"></a>typeof 操作符</h2><p>ECMAScript是松散类型的，typeof就是负责来检测给定变量的数据类型的操作符。<br>typeof是判断参数是什么类型的实例，就一个参数<br>typeof一般只能返回如下几个结果：”number”、”string”、”boolean”、”object”、”function” 和 “undefined”。</p><h2 id="Undefined类型"><a href="#Undefined类型" class="headerlink" title="Undefined类型"></a>Undefined类型</h2><p>Undefined类型只有一个值，即特殊的undefined。只有在变量声明且未初始化的时候，变量的值为undefined。<br>建议显式的初始化undefined，这样发现值为undefined的时候，就会知道该变量未声明而不是未初始化。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">'undefined'</span>;</span><br></pre></td></tr></table></figure></p><h2 id="Null类型"><a href="#Null类型" class="headerlink" title="Null类型"></a>Null类型</h2><p>Null类型只有一个值的数据类型，即特殊的null。从逻辑角度来看，null值表示一个空对象指针，使用typeof操作符检测null值时会返回’object’。<br>如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为null而不是其他值。只要直接检查null值就可以知道相应的变量是否已经保存了一个对象的引用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj != <span class="literal">null</span>)&#123;</span><br><span class="line"><span class="comment">// 对 car 对象执行某些操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>另外：undefined值是派生自null值的，在验证相等时，它们的相等性测试要返回true。但是在全等性测试时返回false。</p><h2 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h2><p>Boolean类型是JS中使用得最多的一种类型，该类型只有两个字面值:true和false。Boolean类型的字面值true和false是区分大小写的。<br>Boolean类型的字面值只有两个，但JS中所有类型的值都有与这两个Boolean值等价的值。要将一个值转换为其对应的 Boolean值，可以调用转型函数Boolean(),可以对任何数据类型的值调用Boolean()函数，而且总会返回一个Boolean值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> message = <span class="string">'hello world'</span>;</span><br><span class="line"><span class="keyword">const</span> bool = <span class="built_in">Boolean</span>(message);</span><br></pre></td></tr></table></figure></p><table><thead><tr><th>数据类型</th><th style="text-align:center">true</th><th style="text-align:center">false </th></tr></thead><tbody><tr><td>String</td><td style="text-align:center">任何非空字符串</td><td style="text-align:center">‘’(空字符串)</td></tr><tr><td>Boolean</td><td style="text-align:center">true</td><td style="text-align:center">false</td></tr><tr><td>Number</td><td style="text-align:center">任何非0值</td><td style="text-align:center">0和NaN</td></tr><tr><td>Object</td><td style="text-align:center">任何对象</td><td style="text-align:center">null</td></tr><tr><td>undefined</td><td style="text-align:center"></td><td style="text-align:center">undefined</td></tr></tbody></table><h2 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h2><p>Number类型使用IEEE754格式来表示整数和浮点数值(浮点数值在某些语言中也被称为双精度数值)。<br>最基本的数值字面量格式是十进制整数：<code>const num = 254;</code>，最高具有53位有效数字精度<br>八进制字面值的第一位必须是零(0)，然后是八进制数字序列(0~7)<code>const num2 = 03</code>;八进制字面量在严格模式下是无效的<br>十六进制字面值的前两位必须是 0x,<code>const num2 = 0xff</code><br>算术计算时，所有以八进制和十六进制表示的数值都会被转换成十进制数值<br>在JavaScript中保存数值的方式，可以保存正零(+0)和负零(0)。正零和负零被认为相等<br>1、浮点数值<br>数值中必须包含一个小数点，并且小数点后面必须至少有一位数字.浮点数保存空间是整数的两倍，如果小数点后的值为0或者没有任何数值，那么该数值就会保存成整数<br>用e或E表示10的幂。<code>2e5</code>,浮点数的最高精度为17位。算术运算的时候，精度比整数差的多。不要测试浮点数相等。<br>2、最值：<code>Number.MIN_VALUE, Number.MAX_VALUE</code><br>3、NaN：<br>该值表示一个本来要返回Number类型的操作数未返回数值的情况。<br>设计NaN的所有操作都等于NaN，且NaN与任何值都不想等，包括NaN<br>isNaN()函数,用来判断一个值是否为数值（number）<br>isNaN也适用于对象，在判断对象的时候，会先调用对象的valueOf()方法，确定该返回值是否是数值，如果不行，会调用toString()方法，再判断是否是数值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>()</span><br></pre></td></tr></table></figure></p><p>4、数值转换<br>有3个方法可以将非数值类型的值转换成数值类型：Number() parseInt()  parseFloat()。<br>Number()方法可以将任何数值类型转化成数值类型，其他两个需要字符串类型<br>Number()转换规则：</p><ul><li>Boolean的值，true转换成1， false转化成0</li><li>null 转化成0</li><li>undefined 转化成NaN</li><li>String变量 <ul><li>是整数的转换成十进制整数，前导0将被去掉</li><li>浮点数将被转化成浮点数，前导0将被去掉</li><li>十六进制的数值将被转换成十进制相同大小的值</li><li>空字符串将被转换成0</li><li>其他的将被转换成NaN</li></ul></li><li>Object对象 会先调用对象的valueOf()方法，确定该返回值是否是数值，如果NaN，会调用toString()方法，再按照string方法判断。</li></ul><p>parseInt()转换规则<br>  转换字符串，从第一个非空格字符开始，是数字或者进制符号就继续下一个字符。否则就NaN<br>  浮点数转化成整数，空字符串转化成NaN<br>  <code>parseInt(&#39;&#39;) = NaN</code></p><p>parseFloat()转化规则<br>  从第一个字符开始判断，知道遇到非浮点数字符。<br>  第一个小数点有效，其他的则无效。<br>  16进制会被转化成0<br>  忽略前导0</p><h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><p>用于表示有0到多个16位Unicode字符组成的字符序列，即字符串。用’’或者””表示<br>1、字符字面量 即转义字符<br>2、字符串特点<br>  ES中，字符串一旦创建就不能改变，要改变就会销毁之前变量，然后生产新的变量。<br>3、转换成字符串<br>toString()方法<br>  Number，Boolean，Object，String都有这个方法，转换成相应的字符串。Null和Undefined没有这个方法。<br>  如果有toString()方法，那就调用该方法<br>  如果没有，null 转换成’null’,undefined 转换成’undefined’</p><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p>ES中的对象就是一组数据和功能的集合。对象可以通过new操作符后加名字的来创建<br><code>var o = new Object()</code><br>Object类型是所有它的实例的基础，其具有的属性，在其他所有的实例中都会有。<br>Object有的属性和方法</p><ul><li>constructor：保存用于创建当前对象的函数</li><li>hasOwnProperty(propertyName): 用于判断是否有属于自己的属性，而不是在原型中的属性</li><li>isPrototypeOf(object): 用于检查传入的对象是否是传入对象的原型</li><li>propertyIsEnumerable(propertyName)：用于检查属性能否用for-in来遍历</li><li>toLocaleString()：返回对象的字符串表示</li><li>toString(): 返回对象的字符串表示</li><li>valueOf()：返回对象的字符串，数值，布尔表示，通常和toString()结果一样。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JS高程的第三章第二节，对数据类型进行一下学习&lt;/p&gt;
&lt;p&gt;JS有五种基本数据类型：Number，String，Boolean，Undefined，Null和一种复杂类型：Object，Object本质上是由一组无序的名值对组成的（说好的万物皆对象来着）。JS不支持任何创
      
    
    </summary>
    
      <category term="JS高程填坑笔记" scheme="http://yoursite.com/categories/JS%E9%AB%98%E7%A8%8B%E5%A1%AB%E5%9D%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript基本概念（一）</title>
    <link href="http://yoursite.com/2018/06/11/javascript%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/06/11/javascript基本概念（一）/</id>
    <published>2018-06-11T04:51:06.000Z</published>
    <updated>2018-06-28T10:00:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是JS高程的第三章，内容比较多的一章，所以拆分开来，慢慢的填坑。<br>路漫漫其修远兮啊<br>本节包括三个部分</p><ul><li>JS语法</li><li>JS关键字</li><li>JS变量</li></ul><h2 id="JS语法"><a href="#JS语法" class="headerlink" title="JS语法"></a>JS语法</h2><p>1、JS中的一切(变量、函数名和操作符)都区分大小写<br>2、标识符，就是指变量、函数、属性的名字，或者函数的参数。第一个字符必须是一个字母、下划线(_)或一个美元符号($）;其他字符可以是字母、下划线、美元符号或数字<br>3、注释：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单行注释</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 这是一个多行 </span></span><br><span class="line"><span class="comment">* (块级)注释 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>4、严格模式<br>ECMAScript5引入了严格模式(strict mode)的概念。严格模式是为JavaScript定义了一种不同的解析与执行模型。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br></pre></td></tr></table></figure></p><p>它是一个编译指示(pragma)，用于告诉支持的JavaScript引擎切换到严格模式。这是为不破坏ECMAScript 3语法而特意选定的语法。<br>5、ECMAScript 中的语句以一个分号结尾;如果省略分号，则由解析器确定语句的结尾。建议在语句结尾处添加“;”</p><h2 id="关键字和保留字"><a href="#关键字和保留字" class="headerlink" title="关键字和保留字"></a>关键字和保留字</h2><p>1、关键字，可用于表示控制语句的开始或结束，或者用于执行特定操作等。按照规则，关键字也是语言保留的，不能用作标识符。<br>2、保留字，保留字在这门语言中还没有任何特定的用途，但它们有可能在将来被用作关键字。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>ECMAScript的变量是松散类型的，松散类型就是可以用来保存任何类型的数据。换句话说，每个变量仅仅是一个用于保存值的占位符而已。ECMAScript 也支持直接初始化变量，因此在定义变量的同时就可以设置变量的值<br>用var操作符定义的变量将成为定义该变量的作用域中的局部变量。也就是说，如果在函数中使用var定义一个变量，那么这个变量在函数退出后就会被销毁。<br>（块级作用域中可以使用let 和 const来声明块级变量，形成暂时性死区）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是JS高程的第三章，内容比较多的一章，所以拆分开来，慢慢的填坑。&lt;br&gt;路漫漫其修远兮啊&lt;br&gt;本节包括三个部分&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JS语法&lt;/li&gt;
&lt;li&gt;JS关键字&lt;/li&gt;
&lt;li&gt;JS变量&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;JS语法&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="JS高程填坑笔记" scheme="http://yoursite.com/categories/JS%E9%AB%98%E7%A8%8B%E5%A1%AB%E5%9D%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>在HTML中使用JS</title>
    <link href="http://yoursite.com/2018/06/10/%E5%9C%A8HTML%E4%B8%AD%E4%BD%BF%E7%94%A8JS/"/>
    <id>http://yoursite.com/2018/06/10/在HTML中使用JS/</id>
    <published>2018-06-10T14:20:34.000Z</published>
    <updated>2018-06-28T09:52:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是js高程的第二章，主要讲的内容就是怎样在HTML中使用javascript。<br>这章的内容包含四个部分：</p><ul><li>&lt;script&gt; 标签</li><li>嵌入脚本和外部脚本</li><li>文档模式的影响</li><li>禁用javascript的场景</li></ul><h2 id="lt-script-gt-标签"><a href="#lt-script-gt-标签" class="headerlink" title="&lt;script&gt; 标签"></a>&lt;script&gt; 标签</h2><p>向HTML页面中插入JavaScript的主要方法，就是使用&lt;script&gt;元素。<br>html 4.01给script标签定义了以下属性</p><ul><li>async 异步标签，表示应该立即下载脚本，但不应妨碍页面中的其他操作。该属性只对外部脚本文件有效。但是，标记为async的脚本并不保证按照script排列的先后顺序执行。异步脚本一定会在页面的load事件前执行，但可能会在DOMContentLoaded事件触发之前或之后执行。</li><li>charset:表示通过 src 属性指定的代码的字符集。由于大多数浏览器会忽略它的值，因此这个属性很少有人用。</li><li><p>defer:表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。脚本会被延迟到整个页面都解析完毕后再运行。HTML5规范要求脚本按照它们出现的先后顺序执行，因此第一个延迟脚本会先于第二个延迟脚本执行，而这两个脚本会先于DOMContentLoaded事件执行。但是在现实当中，延迟脚本并不一定会按照顺序执行，也不一定会在 DOMContentLoaded事件触发前执行，因此最好只包含一个延迟脚本。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script defer=<span class="string">"defer"</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p>src:表示包含要执行代码的外部文件。如果要通过&lt;script&gt;元素来包含外部JavaScript文件，那么src 属性就是必需的。这个属性的值是一个指向外部JavaScript文件的链接。<br>需要注意的是，带有src属性的&lt;script&gt;元素不应该在其&lt;script&gt;和&lt;script&gt;标签之间再 包含额外的JavaScript代码。如果包含了嵌入的代码，则只会下载并执行外部脚本文件，嵌入的代码会被忽略。<br>通过&lt;script&gt;元素的 src 属性还可以包含来自外部域的 JavaScript 文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"example.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>type:type 属性规定脚本的MIME类型。type属性标示 &lt;script&gt;与&lt;/script&gt;标签之间的内容。MIME类型包括两部分：media type 和 subtype。对于JavaScript，MIME 类型是 “text/javascript”。在 HTML5中，type属性不再是必需的。默认值是”text/javascript”。</p></li></ul><h2 id="嵌入脚本和外部脚本"><a href="#嵌入脚本和外部脚本" class="headerlink" title="嵌入脚本和外部脚本"></a>嵌入脚本和外部脚本</h2><p>使用&lt;script&gt;元素的方式有两种:直接在页面中嵌入JavaScript代码和包含外部 JavaScript文件。无论如何包含代码，只要不存在defer和async属性，浏览器都会按照&lt;script&gt;元素在页面中 出现的先后顺序对它们依次进行解析。</p><p>外部脚本的优势：<br> 可维护性<br> 可缓存: 浏览器能够根据具体的设置缓存链接的所有外部 JavaScript 文件<br> 适应未来</p><h2 id="文档模式的影响"><a href="#文档模式的影响" class="headerlink" title="文档模式的影响"></a>文档模式的影响</h2><p>最初的两种文档模式是:混杂模式(quirks mode)和标准模式(standards mode)。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML 4.01 严格型 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- HTML 5 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="禁用javascript的场景"><a href="#禁用javascript的场景" class="headerlink" title="禁用javascript的场景"></a>禁用javascript的场景</h2><p>关于禁用javascript的场景，主要是&lt;noscript&gt;<br>这个元素可以包含能够出现在文档&lt;body&gt;中的任何 HTML 元素——&lt;script&gt;元素除外。包含 在&lt;noscript&gt;元素中的内容只有在下列情况下才会显示出来:<br> 浏览器不支持脚本;<br> 浏览器支持脚本，但脚本被禁用。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Example HTML Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">noscript</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>本页面需要浏览器支持(启用)JavaScript。</span><br><span class="line">    <span class="tag">&lt;/<span class="name">noscript</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">defer</span>=<span class="string">"defer"</span> <span class="attr">src</span>=<span class="string">"example1.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">defer</span>=<span class="string">"defer"</span> <span class="attr">src</span>=<span class="string">"example2.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>把 JavaScript 插入到 HTML 页面中要使用&lt;script&gt;元素。使用这个元素可以把 JavaScript 嵌入到 HTML 页面中，让脚本与标记混合在一起;也可以包含外部的 JavaScript 文件。而我们需要注意的地方有:<br> 在包含外部 JavaScript 文件时，必须将 src 属性设置为指向相应文件的 URL。而这个文件既可 以是与包含它的页面位于同一个服务器上的文件，也可以是其他任何域中的文件。<br> 所有&lt;script&gt;元素都会按照它们在页面中出现的先后顺序依次被解析。在不使用 defer 和 async 属性的情况下，只有在解析完前面&lt;script&gt;元素中的代码之后，才会开始解析后面 &lt;script&gt;元素中的代码。<br> 由于浏览器会先解析完不使用 defer 属性的&lt;script&gt;元素中的代码，然后再解析后面的内容， 所以一般应该把&lt;script&gt;元素放在页面最后，即主要内容后面，&lt;／body&gt;标签前面。<br> 使用 defer 属性可以让脚本在文档完全呈现之后再执行。延迟脚本总是按照指定它们的顺序执行。<br> 使用 async 属性可以表示当前脚本不必等待其他脚本，也不必阻塞文档呈现。不能保证异步脚<br>本按照它们在页面中出现的顺序执行。 另外，使用&lt;noscript&gt;元素可以指定在不支持脚本的浏览器中显示的替代内容。但在启用了脚本的情况下，浏览器不会显示&lt;noscript&gt;元素中的任何内容。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是js高程的第二章，主要讲的内容就是怎样在HTML中使用javascript。&lt;br&gt;这章的内容包含四个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;lt;script&amp;gt; 标签&lt;/li&gt;
&lt;li&gt;嵌入脚本和外部脚本&lt;/li&gt;
&lt;li&gt;文档模式的影响&lt;/li&gt;
&lt;li&gt;禁用ja
      
    
    </summary>
    
      <category term="JS高程填坑笔记" scheme="http://yoursite.com/categories/JS%E9%AB%98%E7%A8%8B%E5%A1%AB%E5%9D%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>window.location的属性</title>
    <link href="http://yoursite.com/2018/06/10/window.location%E7%9A%84%E5%B1%9E%E6%80%A7/"/>
    <id>http://yoursite.com/2018/06/10/window.location的属性/</id>
    <published>2018-06-10T03:23:35.000Z</published>
    <updated>2018-06-28T10:00:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>关于http的相关的BOM的问题</p><p>获取当前url的协议<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> protocol = <span class="built_in">window</span>.location.protocol;</span><br></pre></td></tr></table></figure></p><p>获取当前的host和端口号<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> host = <span class="built_in">window</span>.location.host;</span><br></pre></td></tr></table></figure></p><p>获取当前完整的URL<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> host = <span class="built_in">window</span>.location.href;</span><br></pre></td></tr></table></figure></p><p>获取当前pathName<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> host = <span class="built_in">window</span>.location.pathname;</span><br></pre></td></tr></table></figure></p><p>获取当前url的查找内容<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> host = <span class="built_in">window</span>.location.search;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于http的相关的BOM的问题&lt;/p&gt;
&lt;p&gt;获取当前url的协议&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;
      
    
    </summary>
    
      <category term="bug汇总" scheme="http://yoursite.com/categories/bug%E6%B1%87%E6%80%BB/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>CSS 实用片段</title>
    <link href="http://yoursite.com/2018/05/29/CSS%E5%AE%9E%E7%94%A8%E7%89%87%E6%AE%B5/"/>
    <id>http://yoursite.com/2018/05/29/CSS实用片段/</id>
    <published>2018-05-29T10:15:44.000Z</published>
    <updated>2018-07-03T05:49:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>1、垂直对齐：垂直对齐容器中的元素.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">verticalcenter</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">translateY</span>(-50%);</span><br><span class="line">  <span class="attribute">-o-transform</span>: <span class="built_in">translateY</span>(-50%);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、垂直居中:<br>不知道父元素高度的情况</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">parentElement</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>:relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">childElement</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若父容器下只有一个元素，且父元素设置了高度，则只需要使用相对定位即可</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">parentElement</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: xxx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">childElement</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flex 布局</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">parentElement</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex; <span class="comment">/*Flex布局*/</span></span><br><span class="line">  <span class="attribute">display</span>: -webkit-flex; <span class="comment">/* Safari */</span></span><br><span class="line">  <span class="attribute">align-items</span>: center; <span class="comment">/*指定垂直居中*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>line-height 设置了行间的距离（行高），将要居中的元素的 line-heigth 值设置为和其块级父元素的 height 值一样时，其内部内容会垂直居中。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">element</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、水平居中:<br>行级元素水平居中对齐:<code>text-align:center;</code><br>块级元素水平居中对齐:<code>margin: 0 auto</code><br>对于浮动的元素居中</p><ul><li>宽度不固定的浮动元素</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"outerbox"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"innerbox"</span>&gt;</span>我是浮动的<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outerbox</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.innerbox</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>。。。未完待续</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、垂直对齐：垂直对齐容器中的元素.&lt;/p&gt;
&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="http://yoursite.com/2018/05/28/%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/05/28/链表/</id>
    <published>2018-05-28T08:20:40.000Z</published>
    <updated>2018-06-28T10:00:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>链表是由一组节点组成的集合。每一个节点都使用一个对象的引用指向它的后续借点。指向另外一个节点的引用叫做链。<br>链表元素则是靠相互之间的关系进行引用。在链表中就说这个元素是某个元素的后面一个元素。遍历链表就是跟着链表从链表的头元素（head）一直走到尾元素（但是不包含链表的头节点，头通常用来作为链表的接入点）。链表的尾元素指向一个null节点。<br><img src="https://images2015.cnblogs.com/blog/72678/201609/72678-20160917225805820-1415213828.png" alt="链表的结构"></p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>单链表<br>（见定义）</p><p>循环链表<br>循环链表的运算与单链表的运算基本一致。所不同的有以下几点：<br>1、在建立一个循环链表时，必须使其最后一个结点的指针指向表头结点，而不是象单链表那样置为NULL。此种情况还使用于在最后一个结点后插入一个新的结点。<br>2、在判断是否到表尾时，是判断该结点链域的值是否是表头结点，当链域值等于表头指针时，说明已到表尾。而非象单链表那样判断链域值是否为NULL。</p><p>双向链表<br>双向链表其实是单链表的改进。<br>当我们对单链表进行操作时，有时你要对某个结点的直接前驱进行操作时，又必须从表头开始查找。这是由单链表结点的结构所限制的。因为单链表每个结点只有一个存储直接后继结点地址的链域，那么能不能定义一个既有存储直接后继结点地址的链域，又有存储直接前驱结点地址的链域的这样一个双链域结点结构呢？这就是双向链表。<br>在双向链表中，结点除含有数据域外，还有两个链域，一个存储直接后继结点地址，一般称之为右链域；一个存储直接前驱结点地址，一般称之为左链域。</p><h2 id="链表的操作"><a href="#链表的操作" class="headerlink" title="链表的操作"></a>链表的操作</h2><p>链表的操作通常需要操作两个节点，例如，向链表中插入一个节点，需要修改它前面的节点，使其指向新加入的节点，而新加入的节点则指向前面指向的节点<br>从链表中删除一个节点也很简单，将待删除的元素的前驱节点指向待删除的后续节点，同时将待删除元素指向null来释放。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Definition for singly-linked list.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ListNode</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.val = val;</span><br><span class="line">  <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> findListNode = <span class="function">(<span class="params">listNode, target</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">while</span>(listNode) &#123;</span><br><span class="line">    <span class="keyword">if</span> (listNode.val === target) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    listNode = listNode.next ? listNode.next : <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="string">"not hava this target"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>插入<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在第target个元素后添加一个节点</span></span><br><span class="line"><span class="keyword">const</span> insertListNode = <span class="function">(<span class="params">listNode1, node, target</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> count = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span>(listNode) &#123;</span><br><span class="line">    <span class="keyword">if</span> (count === target) &#123;</span><br><span class="line">      node.next = listNode.next;</span><br><span class="line">      listNode.next = node</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    listNode = listNode.next ? listNode.next : <span class="literal">null</span></span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;链表是由一组节点组成的集合。每一个节点都使用一个对象的引用指向它的后续借点。指向另外一个节点的引用叫做链。&lt;br&gt;链表元素则是靠相互之间的关
      
    
    </summary>
    
      <category term="算法学习" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>html5语意化学习</title>
    <link href="http://yoursite.com/2018/05/28/html5%E8%AF%AD%E6%84%8F%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2018/05/28/html5语意化学习/</id>
    <published>2018-05-28T02:46:36.000Z</published>
    <updated>2018-06-28T10:00:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1>百度前端技术学院学习笔记（二）</h1><p>百度前端技术学院，第二天课程已经脱了好几天了，最近项目上线以及一些其他的事情，一只拖延着我这只拖延狗的进度。。今天终于抽出时间来整理一下这个知识点。</p><h2 id="目标简介"><a href="#目标简介" class="headerlink" title="目标简介"></a>目标简介</h2><ul><li>Date: 2018.05.28 Mon</li><li>Target: 熟悉html语意化。</li><li>Time: 1day</li></ul><h2 id="语意化探究"><a href="#语意化探究" class="headerlink" title="语意化探究"></a>语意化探究</h2><p>语意化，就是根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。那通俗一点来说，就是为了让编写让人和机器都认识的代码。</p><p>语意化的意义</p><ul><li>为了在没有样式的时候，页面也能呈现出很好地内容结构、代码结构</li><li>更好的用户体验</li><li>便于SEO</li><li>方便其他设备解析</li><li>便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。</li></ul><p>部分语意化标签</p><table><thead><tr><th style="text-align:center">标签</th><th style="text-align:center">意义</th><th style="text-align:center">用法 </th></tr></thead><tbody><tr><td style="text-align:center">header</td><td style="text-align:center">头部标签</td><td style="text-align:center">用于网页顶部，作为头部</td></tr><tr><td style="text-align:center">footer</td><td style="text-align:center">底部标签</td><td style="text-align:center">用于网页底部，内容多相关信息</td></tr><tr><td style="text-align:center">hgroup</td><td style="text-align:center">网页标签</td><td style="text-align:center">网页或者含有多个h标签的</td></tr><tr><td style="text-align:center">nav</td><td style="text-align:center">导航标签</td><td style="text-align:center">放置导航栏</td></tr><tr><td style="text-align:center">aside</td><td style="text-align:center">侧栏标签</td><td style="text-align:center">侧边栏的内容</td></tr><tr><td style="text-align:center">section</td><td style="text-align:center">区块的标签</td><td style="text-align:center">一个独立的区域</td></tr><tr><td style="text-align:center">article</td><td style="text-align:center">文章标签</td><td style="text-align:center">一片文章的区域</td></tr><tr><td style="text-align:center">h1-h6</td><td style="text-align:center">标题标签</td><td style="text-align:center">按照标题的大小选择</td></tr><tr><td style="text-align:center">p</td><td style="text-align:center">段落标签</td><td style="text-align:center">一个段落</td></tr><tr><td style="text-align:center">audio</td><td style="text-align:center">声音标签</td><td style="text-align:center">用来链接音频</td></tr><tr><td style="text-align:center">video</td><td style="text-align:center">视频标签</td><td style="text-align:center">用来链接视频</td></tr></tbody></table><h2 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h2><p>Q1: HTML是什么，HTML5是什么？<br>A1: 超级文本标记语言是标准通用标记语言下的一个应用，也是一种规范，一种标准，它通过标记符号来标记要显示的网页中的各个部分。HTML5是HTML的第五次修改，HTML5的革新之一：语义化标签一节元素标签。</p><p>Q2: HTML元素标签、属性都是什么概念？<br>A2: HTML的标签就是一个个网页的结构元素，一个网页是由一个个元素组合起来的。属性是标签的一些性质，包括ID、名称、URI、数字、长度单位、语言、媒体描述符、颜色、字符编码、日期和时间等。</p><p>Q3: 文档类型是什么概念，起什么作用？<br>A3: 文档类型有严格模式和非严格模式，应用严格模式来编写页面，更严谨。H5没有文档类型。</p><p>Q4: meta标签都用来做什么的？<br>A4: 元素可提供相关页面的元信息（meta-information），标签位于文档的头部，不包含任何内容。标签的属性定义了与文档相关联的名称/值对。</p><ul><li>meta标签共有两个属性，它们分别是http-equiv属性和name属性，不同的属性又有不同的参数值，这些不同的参数值就实现了不同的网页功能。</li><li>meta 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。</li><li>meta 标签位于文档的头部，不包含任何内容。</li><li>meta 标签的属性定义了与文档相关联的名称/值对。</li></ul><p>Q5: Web语义化是什么，是为了解决什么问题<br>A5：就是根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析<br>解决了SEO等问题</p><p>Q6: 链接是什么概念，对应什么标签？<br>A6: 是支持浏览器文档与外部资源的关系。对应link标签</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;百度前端技术学院学习笔记（二）&lt;/h1&gt;

&lt;p&gt;百度前端技术学院，第二天课程已经脱了好几天了，最近项目上线以及一些其他的事情，一只拖延着我这只拖延狗的进度。。今天终于抽出时间来整理一下这个知识点。&lt;/p&gt;
&lt;h2 id=&quot;目标简介&quot;&gt;&lt;a href=&quot;#目标简介&quot; cl
      
    
    </summary>
    
      <category term="Glory Road" scheme="http://yoursite.com/categories/Glory-Road/"/>
    
    
      <category term="html" scheme="http://yoursite.com/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>插入排序</title>
    <link href="http://yoursite.com/2018/05/25/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/05/25/插入排序/</id>
    <published>2018-05-25T08:07:55.000Z</published>
    <updated>2018-06-28T10:00:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，但将最后一个元素除外（让数组多一个空间才有插入的位置），而第二部分就只包含这一个元素（即待插入元素）。在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。<br>插入排序的基本思想是：每步将一个待排序的记录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。</p><p>直接插入排序的算法思路：<br>（1） 设置监视哨r[0]，将待插入记录的值赋值给r[0]；<br>（2） 设置开始查找的位置j；<br>（3） 在数组中进行搜索，搜索中将第j个记录后移，直至r[0].key≥r[j].key为止；<br>（4） 将r[0]插入r[j+1]的位置上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> insertionSort = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> len = arr.length;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;len; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> j = i;</span><br><span class="line">    <span class="keyword">let</span> tmp = arr[i];</span><br><span class="line">    <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; arr[j<span class="number">-1</span>] &gt; tmp) &#123;</span><br><span class="line">        arr[j] = arr[j<span class="number">-1</span>];</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，但将最后一个元素除外（让数组多一个空
      
    
    </summary>
    
      <category term="算法学习" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
