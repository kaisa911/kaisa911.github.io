{"meta":{"title":"Milestone","subtitle":null,"description":"恣情扬溢的thinking～～","author":"啪叽","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2018-05-08T07:35:01.000Z","updated":"2018-05-14T09:59:24.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"个人简介","date":"2018-05-08T07:57:25.000Z","updated":"2018-05-16T13:31:35.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"联系方式：邮箱：lbf911@126.com技术栈：项目经历："},{"title":"标签","date":"2018-05-08T07:23:04.000Z","updated":"2018-05-14T09:59:24.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"变量、作用域和内存问题","slug":"变量、作用域和内存问题","date":"2018-06-28T10:02:07.000Z","updated":"2018-07-02T03:11:51.000Z","comments":true,"path":"2018/06/28/变量、作用域和内存问题/","link":"","permalink":"http://yoursite.com/2018/06/28/变量、作用域和内存问题/","excerpt":"","text":"这是JS高程的第四章，讲的是变量，作用域，以及JS的内存问题。现在来填坑本节包括三个部分 基本类型和引用类型 执行环境 垃圾收集 基本类型和引用类型 基本类型值：简单的数据段，Undefined，Null，number，string，boolean五种基本类型，在操作的时候，可以操作保存在变量中实际的值。 引用类型的值是保存在内存中的对象。Js不允许直接访问内存的位置，也就是不允许直接操作对象的内存空间，在操作对象时，复制对象时，操作的时对象的引用，在为对象添加属性时，操作的是对象 传递参数ES中所有的参数都是按值传递的。基本类型传的值就是变量的值，引用类型传的值是引用内存的地址。 执行环境与作用域全局执行环境，是最外围的一个执行环境。每一个函数都会有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中，而在环境执行结束后，栈将其环境弹出，把控制权返回之前的执行环境。当代码在一个环境中执行时，会产生一个作用域链。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问 可以通过try-catch 和 with语句来延长作用域链 垃圾收集垃圾收集一般有两个策略：标记清楚，进入环境和弹出环境分别有标记，清除弹出环境标记的变量或者函数。引用计数，引用为0的会被清除","categories":[{"name":"JS高程填坑笔记","slug":"JS高程填坑笔记","permalink":"http://yoursite.com/categories/JS高程填坑笔记/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"对象深拷贝方法","slug":"对象深拷贝方法","date":"2018-06-25T03:34:53.000Z","updated":"2018-06-28T10:00:35.000Z","comments":true,"path":"2018/06/25/对象深拷贝方法/","link":"","permalink":"http://yoursite.com/2018/06/25/对象深拷贝方法/","excerpt":"","text":"分享大佬写的深拷贝的方法。。1、JSON.parse(JSON.stringify(obj))这个小方法可以把 obj 里的除了 RegExp 和 function 的属性拷贝下来。function 就忽略了，RegExp 转成{} 2、大佬们写的两个方法。。 12345678910111213141516171819202122232425262728293031323334353637383940const deepClone = obj =&gt; &#123; const innerIterator = (v, key, nb) =&gt; &#123; if (v instanceof Array) &#123; const result = v.map(item =&gt; &#123; if (item instanceof RegExp) &#123; return new RegExp(item); &#125; else if ( typeof item === 'function' || item === null || typeof item !== 'object' ) &#123; return item; &#125; else if (item instanceof Array) &#123; return innerIterator(item); &#125; return reduceKeys(item)(); &#125;); return key &amp;&amp; nb ? &#123; ...nb, [key]: result &#125; : result; &#125; const newObj = reduceKeys(v)(); return &#123; ...nb, [key]: newObj &#125;; &#125;; const reduceKeys = value =&gt; () =&gt; &#123; const ks = Object.keys(value); return ks.reduce((pre, current) =&gt; &#123; const v = value[current]; if (v instanceof RegExp) &#123; return &#123; ...pre, [current]: new RegExp(v) &#125;; &#125; else if ( v === null || typeof v === 'function' || typeof v !== 'object' ) &#123; return &#123; ...pre, [current]: v &#125;; &#125; return innerIterator(v, current, pre); &#125;, &#123;&#125;); &#125;; return reduceKeys(obj)();&#125;; 123456789101112131415161718192021222324252627282930313233343536373839const deepClone = data =&gt; &#123; const notIn = ['[object Function]', '[object Object]', '[object Array]']; const getType = data =&gt; &#123; return Object.prototype.toString.call(data); &#125;; const isObject = data =&gt; &#123; return getType(data) === '[object Object]'; &#125;; const isArray = data =&gt; &#123; return getType(data) === '[object Array]'; &#125;; const isFunction = data =&gt; &#123; return getType(data) === '[object Function]'; &#125;; let result; if (isObject(data)) &#123; result = &#123;&#125;; for (var p in data) &#123; if (notIn.includes(getType(data[p]))) &#123; result[p] = deepClone(data[p]); &#125; else &#123; result[p] = data[p]; &#125; &#125; &#125; else if (isArray(data)) &#123; result = []; for (var i of data) &#123; if (notIn.includes(getType(i))) &#123; result.push(deepClone(i)); &#125; else &#123; result.push(i); &#125; &#125; &#125; else if (isFunction(data)) &#123; result = data; &#125; return result;&#125;;","categories":[{"name":"Demo练习","slug":"Demo练习","permalink":"http://yoursite.com/categories/Demo练习/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"项目action封装","slug":"项目action封装","date":"2018-06-25T02:37:11.000Z","updated":"2018-06-28T10:00:35.000Z","comments":true,"path":"2018/06/25/项目action封装/","link":"","permalink":"http://yoursite.com/2018/06/25/项目action封装/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import callApi from '../../utils/callApi';import api from '../../api';/** * callApi * @param dispatch * @param formData * @param requestUrl * @param type 设置action的type * @returns &#123;function(*)&#125; */const commonCallApi = (dispatch, formData, requestUrl, type) =&gt; &#123; return callApi.post(requestUrl, formData).then(res =&gt; &#123; if (res.code === 200) &#123; const data = type ? dispatch(&#123; type, data: res.data &#125;) : res; return Promise.resolve(data); &#125; return Promise.reject(res); &#125;);&#125;;/** * 公共action * @param requestUrl * @param formData * @param type 设置action的type * @returns &#123;function(*)&#125; */const commonAction = (requestUrl, formData, type) =&gt; &#123; return dispatch =&gt; &#123; return commonCallApi(dispatch, requestUrl, formData, type); &#125;;&#125;;/** * 获取列表 * @param formData * @returns &#123;function(*)&#125; */const getList = formData =&gt; &#123; return commonAction(api.getList, formData, 'get_list');&#125;;export default &#123; getList&#125;;","categories":[{"name":"Demo练习","slug":"Demo练习","permalink":"http://yoursite.com/categories/Demo练习/"}],"tags":[{"name":"Javascript redux","slug":"Javascript-redux","permalink":"http://yoursite.com/tags/Javascript-redux/"}]},{"title":"对象字面量声明和构造函数声明的比较","slug":"对象字面量声明和构造函数声明的比较","date":"2018-06-20T15:58:01.000Z","updated":"2018-06-28T10:00:35.000Z","comments":true,"path":"2018/06/20/对象字面量声明和构造函数声明的比较/","link":"","permalink":"http://yoursite.com/2018/06/20/对象字面量声明和构造函数声明的比较/","excerpt":"","text":"去某家面试的时候，在笔试的时候，看到了这个问题，回来研究一下。JS 中有很多种对象的声明方式，一般我用到的也就是这两种，通过字面量来声明对象和通过构造函数来声明对象。 用字面量来声明对象我们可以直接在创建对象的时候添加功能 12345678let person = &#123; name: 'paji', age: 18, sex: 'male', speak: function() &#123; console.log('大家好'); &#125;&#125;; 或者在一开始先声明一个空的对象，当然这个空对象也不是空对象，也是从 object 上继承了好多 object 的属性，只是没有自有属性 1234567let person = &#123;&#125;,person.name = 'paji';person.age = 18;person.sex = 'male';person.speak = function() &#123; console.log('大家好');&#125; 用构造函数声明对象1234567var person = new Object();person.name = 'paji';person.age = 18;person.sex = 'male';person.speak = function() &#123; console.log('大家好');&#125;; 字面量的优势 代码量更少，更易读 强调对象就是一个简单的可变的散列表，而不必一定派生自某个类 对象字面量运行速度更快，因为它们可以在解析的时候被优化：它们不需要”作用域解析(scope resolution)”；因为存在我们创建了一个同名的构造函数Object()的可能，当我们调用Object()的时候，解析器需要顺着作用域链从当前作用域开始查找，如果在当前作用域找到了名为Object()的函数就执行，如果没找到，就继续顺着作用域链往上照，直到找到全局Object()构造函数为止 Object()构造函数可以接收参数，通过这个参数可以把对象实例的创建过程委托给另一个内置构造函数，并返回另外一个对象实例，而这往往不是你想要的。 尽量用对象字面量的方式来创建对象","categories":[{"name":"面试锦囊","slug":"面试锦囊","permalink":"http://yoursite.com/categories/面试锦囊/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"JS包装对象","slug":"JS包装对象","date":"2018-06-19T07:35:19.000Z","updated":"2018-06-25T02:29:50.000Z","comments":true,"path":"2018/06/19/JS包装对象/","link":"","permalink":"http://yoursite.com/2018/06/19/JS包装对象/","excerpt":"","text":"Q1: 什么是包装对象？A1: JS 的数值，布尔，字符串类型的变量，在一定条件下，也可以自动变成对象，这就是原始类型的包装对象。 123let a = new Number(-1);let b = new Boolean(true);let c = new String('hello world'); Q2: 包装对象和同样的原始类型的值相等么，这么做有什么目的？A2: 不想等。包装对象的最大目的，首先是使得 JavaScript 的对象涵盖所有的值，其次使得原始类型的值可以方便地调用某些方法。 1234567typeof a; //'object'typeof b; //'object'typeof c; //'object'a === -1; //falseb === true; //false;c === 'hello world'; //false Q3: 包装对象有什么实例方法？A3: 包装对象可以使用 object 对象提供的原生的方法，其中主要的就是 valueOf()和 toString()方法 1234567a.valueOf(); //-1b.valueOf(); //trueb.valueOf(); //'hello world'a.toString(); //'-1'b.toString(); //'true'b.toString(); //'hello world' Q4: 原始类型和实例对象怎么转换？A4: 原始类型的值，可以自动当作包装对象调用，即调用各种包装对象的属性和方法。这时，JavaScript 引擎会自动将原始类型的值转为包装对象实例，在使用后立刻销毁实例。自动转换生成的包装对象是只读的，无法修改。所以，字符串无法添加新属性。 123let s = 'Hello World';s.x = 123;s.x; // undefined 另一方面，调用结束后，包装对象实例会自动销毁。这意味着，下一次调用字符串的属性时，实际是调用一个新生成的对象，而不是上一次调用时生成的那个对象，所以取不到赋值在上一个对象的属性。","categories":[{"name":"面试锦囊","slug":"面试锦囊","permalink":"http://yoursite.com/categories/面试锦囊/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"Javascript基本概念（四）","slug":"Javascript基本概念（四）","date":"2018-06-19T06:32:32.000Z","updated":"2018-06-19T09:15:47.000Z","comments":true,"path":"2018/06/19/Javascript基本概念（四）/","link":"","permalink":"http://yoursite.com/2018/06/19/Javascript基本概念（四）/","excerpt":"","text":"这是 JS 高程第三章的第四部分。本节的主要内容是 语句 函数 语句if 语句if (condition) statement1 else statement2eg: 1234567if (i &gt; 25) &#123; alert('Greater than 25.');&#125; else if (i &lt; 0) &#123; alert('Less than 0.');&#125; else &#123; alert('Between 0 and 25, inclusive.');&#125; do-while 语句后测试循环语句 123do &#123; statement;&#125; while (expression); while 语句前测试循环语句while(expression) statement 1234var i = 0;while (i &lt; 10) &#123; i += 2;&#125; for 语句前测试循环语句for (initialization; expression; post-loop-expression) statement 1234var count = 10;for (var i = 0; i &lt; count; i++) &#123; alert(i);&#125; for-in 语句精准迭代语句，可以用来枚举对象属性for (property in expression) statement 123for (var propName in window) &#123; document.write(propName);&#125; label 语句label: statement 123start: for (var i = 0; i &lt; count; i++) &#123; alert(i);&#125; 这个例子中的 start 标签，可以在将来由 break 和 continue 语句引用，加标签的语句一般都要与 for 语句等循环语句配合使用。 break 和 continue 语句break 语句会立即跳出循环，然后执行循环后的代码continue 语句会跳出循环，然后从循环顶部开始执行循环。 switch 语句12345678910111213switch (expression) &#123; case value: statement; break; case value: statement; break; case value: statement; break; default: statement;&#125; 函数ES 中采用 function 来声明一个函数，后面跟一组参数和函数体，函数会在执行完 return 语句之后停止并立即退出。 123function functionName(arg0, arg1,...,argN) &#123; statements&#125; 参数理解函数内部通过一个数组arguments来接收参数。arguments对象只是与数组很像，但是并不是Array的实例。可以用arguments[0]来获取内部的元素。ECMAScript 中的所有的参数传递的都是值，不可能通过引用传递参数 没有重载ES中的函数没有重载","categories":[{"name":"JS高程填坑笔记","slug":"JS高程填坑笔记","permalink":"http://yoursite.com/categories/JS高程填坑笔记/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"Javascript 基本概念（三）","slug":"Javascript基本概念（三）","date":"2018-06-13T15:27:09.000Z","updated":"2018-06-19T03:25:22.000Z","comments":true,"path":"2018/06/13/Javascript基本概念（三）/","link":"","permalink":"http://yoursite.com/2018/06/13/Javascript基本概念（三）/","excerpt":"","text":"这是JS高程第三章的第三部分。这一章内容是真的多。。我觉得重新刷高程，对我来说，也是一种不一样的进步吧。本节的主要内容是 操作符 一元操作符只能操作一个一个值的操作符叫做一元操作符。1、递增递减操作符 有两个版本，前置型和后置型。 前置型，先操作，后执行。 后置型，先执行，后操作。123456let a = 5, b = 6;let sum = ++a + b;let sum2 = a++ + b;console.log(sum); //12console.log(sum2) //12console.log(a); //7 递增递减操作符对数值，布尔，字符串，对象都有作用！！！！！ 规则如下： 如果字符串包含有效数字，则先转化成数值变量，然后加减1；不包含有效数字，则转化成NaN。字符串变量变成数值变量 数值变量加减1； 布尔变量，true先变成1，false变成0，然后加减1,布尔变了转换成数值变量； 对象变量，先查看valueOf()方法，如果是NaN，则调用toString()，对象转换成数值变量。 2、一元加减操作符。 一元+操作符，会像Number()方法一样对变量转换成数值变量var a; a = +a; 一元-操作符，主要是变成负数。会像Number()方法一样，不过是负数。 位操作符首先ES里所有的数值都是有64位来储存，但是位操作符并不是操作64位，而是先转化成32位的整数，然后操作，再将结果转换成64位的，这样，NaN和Infinity就会变成0。对于有符号数，第32位是符号位，0代表正数，1代表负数，符号位决定了其他位数值的格式。剩下31位用来储存数据。正数都是以二进制格式存储，负数以二进制的补码格式存储。默认情况下，ES里所有的正数都是有符号数。无符号数，第32位是数值。但是无符号数只能是正数。位操作符对其他变量，会先用Number()方法变成数值，然后再按位操作。1、按位非（NOT） 按位非是用～表示，执行按位非的结果是返回数值的反码。2、按位与（AND） 按位与是用&amp;表示，它有两个操作符数，运算的时候，将两个数的二进制每一位对齐，都是1得1，其他为0；3、按位或（OR） 按位或是用|表示，它有两个操作符数，运算的时候，将两个数的二进制每一位对齐，都是0得0，其他为1；4、按位异或（XOR） 按位或是用^表示，它有两个操作符数，运算的时候，将两个数的二进制每一位对齐，相同得0，不同为1；5、左移 左移用&lt;&lt;表示，会将数值所有位数向左移动指定的位数。后面补0；左移不会影响符号。6、有符号右移 有符号右移用&gt;&gt;表示，会将数值所有位数向右移动指定的位数。前面补0；保留符号位，不会影响符号。7、无符号右移 无符号右移用&gt;&gt;&gt;表示，会将数值所有位数向右移动指定的位数。前面补0；会影响符号。而且会把负数的补码当成二进制码来运算。 布尔运算符布尔运算符有三个，主要用来测试值的关系1、逻辑非(!)这个操作符会返回一个布尔值，逻辑非运算会将操作数先转换成布尔值，然后求反。 操作数是对象，返回false 操作数是空字符串，返回true 操作数是非空字符串，返回false 操作数是非0数值，返回false 操作数是0，null，NaN，undefined，返回true 2、逻辑与(&amp;&amp;)逻辑与操作符两边有两个操作数。都是true才为true。逻辑与操作可以应用于所有变量，在有一个操作数不是布尔值的情况下，逻辑与不一定会返回布尔值。规则： 如果第一个操作数是对象，则返回第二个操作数 如果第二个操作数是对象，则必须第一个操作数是true才会返回该对象。 如果两个数都是对象，则返回第二个操作数 如果有一个操作数是null，NaN，undefined，则返回null，NaN，undefined。 逻辑与属于短路操作，第一个操作数能决定结果，就不会对第二个操作数求值。 3、逻辑或(||)逻辑或两边有两个操作数，有一个为true就是true。逻辑或操作可以应用于所有变量，在有一个操作数不是布尔值的情况下，逻辑与不一定会返回布尔值。规则： 如果第一个操作数是对象，则返回第一个操作数 如果第一个操作数是false，则返回第二个操作数 两个操作数都是对象，则返回第一个操作数 如果两个操作数是null，NaN，undefined，则返回null，NaN，undefined。 乘性操作符ES有三个乘性操作符，乘法，除法和求模。如果乘性操作符的某一个操作数不是数值，则将会用Number()方法，先转换成数值。1、乘法(*)规则： 乘积超过限制，则显示Infinity或者-Infinity 有一个操作数为NaN，结果为NaN Infinity与0相乘，结果是NaN Infinity与非0数相乘，结果是Infinity或者-Infinity Infinity与Infinity相乘，结果是Infinity 2、除法(/)规则： Infinity与Infinity相除，结果是NaN 0/0结果是NaN 其他操作数／0 结果是Infinity或者-Infinity 3、求模(%)规则： Infinity%操作数 结果是NaN 操作数%0，结果是NaN Infinity%Infinity，结果是NaN 操作数%Infinity，结果是操作数 加性操作符ES中有两个加性操作符，加法和减法1、加法(+)规则： 有一个操作数是NaN，结果就是NaN Infinity + Infinity = Infinity -Infinity + -Infinity = -Infinity Infinity + -Infinity = NaN +0 + +0 = +0 -0 + -0 = -0 +0 + -0 = +0 两个操作数都是字符串，则将字符串拼接起来 只有一个操作数是字符串，另一个操作数则会转换成字符串，然后拼接起来。 2、减法(-)规则： Infinity - Infinity = NaN -Infinity - -Infinity = NaN Infinity - -Infinity = Infinity -Infinity - Infinity = -Infinity 关系操作符关系操作符有大于(&gt;)，小于(&lt;),小于等于(&lt;=),大于等于(&gt;=)规则： 都是数值，执行数值比较 都是字符串，执行字符串编码比较 一个是数值，则另一个转换成数值比较 相等操作符ES中提供了两种相等操作符：相等操作符：先转换再比较全等操作符：不转换只比较1、相等操作符(==,!=),强制转型，然后比较。规则： 如果有一个是布尔类型的操作数，则先转换成数值。 如果有一个是数值，一个是字符串，则将字符串转换成数值 如果有一个是对象，则用valueOf转成基本类型比较 null 和undefined 相等 如果有一个操作数是NaN，则==返回false，!=返回true 如果都是对象，则比较两个对象是不是一个对象，是否来指向同一个对象。 2、全等操作符(===,!==),不转换，只比较。规则： 只要是完全一样就为true，其他为false。 ##条件操作符ES中的条件操作符(?:)1variable ? console.log(true): console.log(false); ##赋值操作符其中有+= ，-=，*=，／=，%=，&lt;&lt;=, &gt;&gt;=, &gt;&gt;&gt;= ##逗号操作符1var a = 1, b = 2, c = 3;","categories":[{"name":"JS高程填坑笔记","slug":"JS高程填坑笔记","permalink":"http://yoursite.com/categories/JS高程填坑笔记/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"display的属性们","slug":"display的属性们","date":"2018-06-13T03:11:58.000Z","updated":"2018-06-28T10:00:35.000Z","comments":true,"path":"2018/06/13/display的属性们/","link":"","permalink":"http://yoursite.com/2018/06/13/display的属性们/","excerpt":"","text":"display： none | inline | block | list-item | inline-block | table | inline-table | table-caption | table-cell | table-row | table-row-group | table-column | table-column-group | table-footer-group | table-header-group | run-in | box | inline-box | flexbox | inline-flexbox | flex | inline-flex默认值：inline none： 隐藏对象。与visibility属性的hidden值不同，其不为被隐藏的对象保留其物理空间inline： 指定对象为内联元素。block： 指定对象为块元素。list-item： 指定对象为列表项目。inline-block： 指定对象为内联块元素。（CSS2）table： 指定对象作为块元素级的表格。类同于html标签&lt;table&gt;（CSS2）inline-table： 指定对象作为内联元素级的表格。类同于html标签&lt;table&gt;（CSS2）table-caption： 指定对象作为表格标题。类同于html标签&lt;caption&gt;（CSS2）table-cell： 指定对象作为表格单元格。类同于html标签&lt;td&gt;（CSS2）table-row： 指定对象作为表格行。类同于html标签&lt;tr&gt;（CSS2）table-row-group： 指定对象作为表格行组。类同于html标签&lt;tbody&gt;（CSS2）table-column： 指定对象作为表格列。类同于html标签&lt;col&gt;（CSS2）table-column-group： 指定对象作为表格列组显示。类同于html标签&lt;colgroup&gt;（CSS2）table-header-group： 指定对象作为表格标题组。类同于html标签&lt;thead&gt;（CSS2）table-footer-group： 指定对象作为表格脚注组。类同于html标签&lt;tfoot&gt;（CSS2）run-in： 根据上下文决定对象是内联对象还是块级对象。（CSS3）box： 将对象作为弹性伸缩盒显示。（伸缩盒最老版本）（CSS3）inline-box： 将对象作为内联块级弹性伸缩盒显示。（伸缩盒最老版本）（CSS3）flexbox： 将对象作为弹性伸缩盒显示。（伸缩盒过渡版本）（CSS3）inline-flexbox： 将对象作为内联块级弹性伸缩盒显示。（伸缩盒过渡版本）（CSS3）flex： 将对象作为弹性伸缩盒显示。（伸缩盒最新版本）（CSS3）inline-flex： 将对象作为内联块级弹性伸缩盒显示。（伸缩盒最新版本）（CSS3）","categories":[{"name":"面试锦囊","slug":"面试锦囊","permalink":"http://yoursite.com/categories/面试锦囊/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"link和@import之争","slug":"link和-import之争","date":"2018-06-13T02:52:26.000Z","updated":"2018-06-13T03:05:25.000Z","comments":true,"path":"2018/06/13/link和-import之争/","link":"","permalink":"http://yoursite.com/2018/06/13/link和-import之争/","excerpt":"","text":"看到知乎大神说，先问是不是，再问为什么 我页不知道为什么要写这句话，反正就是很奇怪的想法，就先记下来。今天研究的link和@import，是外部引入外部引入 CSS 的两种方式。两者是有区别的（是不是）。我们来研究一下有哪些区别（为什么） link是XHTML(HTML)标签，除了加载CSS外，还可以定义RSS,rel等其他事务； @import是 CSS 提供的语法规则, 只有导入样式表的作用。 link引用CSS时，在页面载入时同时加载； @import需要页面网页完全载入以后加载。 link是XHTML(HTML)标签，无兼容问题； @import是在CSS2.1提出的，低版本的浏览器不支持(IE5+)。 link支持使用Javascript控制DOM去改变样式；而@import不支持。 1234&lt;link href=\"style.css\" rel=\"stylesheet\" type=\"text/css\"&gt; &lt;style&gt; @import url(style.css);&lt;/style&gt;","categories":[{"name":"面试锦囊","slug":"面试锦囊","permalink":"http://yoursite.com/categories/面试锦囊/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"Javascript基本概念(二）","slug":"Javascript基本概念（二）","date":"2018-06-11T06:20:09.000Z","updated":"2018-06-19T06:31:19.000Z","comments":true,"path":"2018/06/11/Javascript基本概念（二）/","link":"","permalink":"http://yoursite.com/2018/06/11/Javascript基本概念（二）/","excerpt":"","text":"JS高程的第三章第二节，对数据类型进行一下学习 JS有五种基本数据类型：Number，String，Boolean，Undefined，Null和一种复杂类型：Object，Object本质上是由一组无序的名值对组成的（说好的万物皆对象来着）。JS不支持任何创建自定义类型的机制。 typeof 操作符ECMAScript是松散类型的，typeof就是负责来检测给定变量的数据类型的操作符。typeof是判断参数是什么类型的实例，就一个参数typeof一般只能返回如下几个结果：”number”、”string”、”boolean”、”object”、”function” 和 “undefined”。 Undefined类型Undefined类型只有一个值，即特殊的undefined。只有在变量声明且未初始化的时候，变量的值为undefined。建议显式的初始化undefined，这样发现值为undefined的时候，就会知道该变量未声明而不是未初始化。1let message = 'undefined'; Null类型Null类型只有一个值的数据类型，即特殊的null。从逻辑角度来看，null值表示一个空对象指针，使用typeof操作符检测null值时会返回’object’。如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为null而不是其他值。只要直接检查null值就可以知道相应的变量是否已经保存了一个对象的引用123if (obj != null)&#123;// 对 car 对象执行某些操作&#125; 另外：undefined值是派生自null值的，在验证相等时，它们的相等性测试要返回true。但是在全等性测试时返回false。 Boolean类型Boolean类型是JS中使用得最多的一种类型，该类型只有两个字面值:true和false。Boolean类型的字面值true和false是区分大小写的。Boolean类型的字面值只有两个，但JS中所有类型的值都有与这两个Boolean值等价的值。要将一个值转换为其对应的 Boolean值，可以调用转型函数Boolean(),可以对任何数据类型的值调用Boolean()函数，而且总会返回一个Boolean值12const message = 'hello world';const bool = Boolean(message); 数据类型 true false String 任何非空字符串 ‘’(空字符串) Boolean true false Number 任何非0值 0和NaN Object 任何对象 null undefined undefined Number类型Number类型使用IEEE754格式来表示整数和浮点数值(浮点数值在某些语言中也被称为双精度数值)。最基本的数值字面量格式是十进制整数：const num = 254;，最高具有53位有效数字精度八进制字面值的第一位必须是零(0)，然后是八进制数字序列(0~7)const num2 = 03;八进制字面量在严格模式下是无效的十六进制字面值的前两位必须是 0x,const num2 = 0xff算术计算时，所有以八进制和十六进制表示的数值都会被转换成十进制数值在JavaScript中保存数值的方式，可以保存正零(+0)和负零(0)。正零和负零被认为相等1、浮点数值数值中必须包含一个小数点，并且小数点后面必须至少有一位数字.浮点数保存空间是整数的两倍，如果小数点后的值为0或者没有任何数值，那么该数值就会保存成整数用e或E表示10的幂。2e5,浮点数的最高精度为17位。算术运算的时候，精度比整数差的多。不要测试浮点数相等。2、最值：Number.MIN_VALUE, Number.MAX_VALUE3、NaN：该值表示一个本来要返回Number类型的操作数未返回数值的情况。设计NaN的所有操作都等于NaN，且NaN与任何值都不想等，包括NaNisNaN()函数,用来判断一个值是否为数值（number）isNaN也适用于对象，在判断对象的时候，会先调用对象的valueOf()方法，确定该返回值是否是数值，如果不行，会调用toString()方法，再判断是否是数值。1isNaN() 4、数值转换有3个方法可以将非数值类型的值转换成数值类型：Number() parseInt() parseFloat()。Number()方法可以将任何数值类型转化成数值类型，其他两个需要字符串类型Number()转换规则： Boolean的值，true转换成1， false转化成0 null 转化成0 undefined 转化成NaN String变量 是整数的转换成十进制整数，前导0将被去掉 浮点数将被转化成浮点数，前导0将被去掉 十六进制的数值将被转换成十进制相同大小的值 空字符串将被转换成0 其他的将被转换成NaN Object对象 会先调用对象的valueOf()方法，确定该返回值是否是数值，如果NaN，会调用toString()方法，再按照string方法判断。 parseInt()转换规则 转换字符串，从第一个非空格字符开始，是数字或者进制符号就继续下一个字符。否则就NaN 浮点数转化成整数，空字符串转化成NaN parseInt(&#39;&#39;) = NaN parseFloat()转化规则 从第一个字符开始判断，知道遇到非浮点数字符。 第一个小数点有效，其他的则无效。 16进制会被转化成0 忽略前导0 String类型用于表示有0到多个16位Unicode字符组成的字符序列，即字符串。用’’或者””表示1、字符字面量 即转义字符2、字符串特点 ES中，字符串一旦创建就不能改变，要改变就会销毁之前变量，然后生产新的变量。3、转换成字符串toString()方法 Number，Boolean，Object，String都有这个方法，转换成相应的字符串。Null和Undefined没有这个方法。 如果有toString()方法，那就调用该方法 如果没有，null 转换成’null’,undefined 转换成’undefined’ ObjectES中的对象就是一组数据和功能的集合。对象可以通过new操作符后加名字的来创建var o = new Object()Object类型是所有它的实例的基础，其具有的属性，在其他所有的实例中都会有。Object有的属性和方法 constructor：保存用于创建当前对象的函数 hasOwnProperty(propertyName): 用于判断是否有属于自己的属性，而不是在原型中的属性 isPrototypeOf(object): 用于检查传入的对象是否是传入对象的原型 propertyIsEnumerable(propertyName)：用于检查属性能否用for-in来遍历 toLocaleString()：返回对象的字符串表示 toString(): 返回对象的字符串表示 valueOf()：返回对象的字符串，数值，布尔表示，通常和toString()结果一样。","categories":[{"name":"JS高程填坑笔记","slug":"JS高程填坑笔记","permalink":"http://yoursite.com/categories/JS高程填坑笔记/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"Javascript基本概念（一）","slug":"javascript基本概念（一）","date":"2018-06-11T04:51:06.000Z","updated":"2018-06-28T10:00:35.000Z","comments":true,"path":"2018/06/11/javascript基本概念（一）/","link":"","permalink":"http://yoursite.com/2018/06/11/javascript基本概念（一）/","excerpt":"","text":"这是JS高程的第三章，内容比较多的一章，所以拆分开来，慢慢的填坑。路漫漫其修远兮啊本节包括三个部分 JS语法 JS关键字 JS变量 JS语法1、JS中的一切(变量、函数名和操作符)都区分大小写2、标识符，就是指变量、函数、属性的名字，或者函数的参数。第一个字符必须是一个字母、下划线(_)或一个美元符号($）;其他字符可以是字母、下划线、美元符号或数字3、注释：12345// 单行注释/** 这是一个多行 * (块级)注释 */ 4、严格模式ECMAScript5引入了严格模式(strict mode)的概念。严格模式是为JavaScript定义了一种不同的解析与执行模型。1\"use strict\"; 它是一个编译指示(pragma)，用于告诉支持的JavaScript引擎切换到严格模式。这是为不破坏ECMAScript 3语法而特意选定的语法。5、ECMAScript 中的语句以一个分号结尾;如果省略分号，则由解析器确定语句的结尾。建议在语句结尾处添加“;” 关键字和保留字1、关键字，可用于表示控制语句的开始或结束，或者用于执行特定操作等。按照规则，关键字也是语言保留的，不能用作标识符。2、保留字，保留字在这门语言中还没有任何特定的用途，但它们有可能在将来被用作关键字。 变量ECMAScript的变量是松散类型的，松散类型就是可以用来保存任何类型的数据。换句话说，每个变量仅仅是一个用于保存值的占位符而已。ECMAScript 也支持直接初始化变量，因此在定义变量的同时就可以设置变量的值用var操作符定义的变量将成为定义该变量的作用域中的局部变量。也就是说，如果在函数中使用var定义一个变量，那么这个变量在函数退出后就会被销毁。（块级作用域中可以使用let 和 const来声明块级变量，形成暂时性死区）","categories":[{"name":"JS高程填坑笔记","slug":"JS高程填坑笔记","permalink":"http://yoursite.com/categories/JS高程填坑笔记/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"在HTML中使用JS","slug":"在HTML中使用JS","date":"2018-06-10T14:20:34.000Z","updated":"2018-06-28T09:52:58.000Z","comments":true,"path":"2018/06/10/在HTML中使用JS/","link":"","permalink":"http://yoursite.com/2018/06/10/在HTML中使用JS/","excerpt":"","text":"这是js高程的第二章，主要讲的内容就是怎样在HTML中使用javascript。这章的内容包含四个部分： &lt;script&gt; 标签 嵌入脚本和外部脚本 文档模式的影响 禁用javascript的场景 &lt;script&gt; 标签向HTML页面中插入JavaScript的主要方法，就是使用&lt;script&gt;元素。html 4.01给script标签定义了以下属性 async 异步标签，表示应该立即下载脚本，但不应妨碍页面中的其他操作。该属性只对外部脚本文件有效。但是，标记为async的脚本并不保证按照script排列的先后顺序执行。异步脚本一定会在页面的load事件前执行，但可能会在DOMContentLoaded事件触发之前或之后执行。 charset:表示通过 src 属性指定的代码的字符集。由于大多数浏览器会忽略它的值，因此这个属性很少有人用。 defer:表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。脚本会被延迟到整个页面都解析完毕后再运行。HTML5规范要求脚本按照它们出现的先后顺序执行，因此第一个延迟脚本会先于第二个延迟脚本执行，而这两个脚本会先于DOMContentLoaded事件执行。但是在现实当中，延迟脚本并不一定会按照顺序执行，也不一定会在 DOMContentLoaded事件触发前执行，因此最好只包含一个延迟脚本。 1&lt;script defer=\"defer\"&gt; src:表示包含要执行代码的外部文件。如果要通过&lt;script&gt;元素来包含外部JavaScript文件，那么src 属性就是必需的。这个属性的值是一个指向外部JavaScript文件的链接。需要注意的是，带有src属性的&lt;script&gt;元素不应该在其&lt;script&gt;和&lt;script&gt;标签之间再 包含额外的JavaScript代码。如果包含了嵌入的代码，则只会下载并执行外部脚本文件，嵌入的代码会被忽略。通过&lt;script&gt;元素的 src 属性还可以包含来自外部域的 JavaScript 文件。 1&lt;script src=\"example.js\"&gt;&lt;/script&gt; type:type 属性规定脚本的MIME类型。type属性标示 &lt;script&gt;与&lt;/script&gt;标签之间的内容。MIME类型包括两部分：media type 和 subtype。对于JavaScript，MIME 类型是 “text/javascript”。在 HTML5中，type属性不再是必需的。默认值是”text/javascript”。 嵌入脚本和外部脚本使用&lt;script&gt;元素的方式有两种:直接在页面中嵌入JavaScript代码和包含外部 JavaScript文件。无论如何包含代码，只要不存在defer和async属性，浏览器都会按照&lt;script&gt;元素在页面中 出现的先后顺序对它们依次进行解析。 外部脚本的优势： 可维护性 可缓存: 浏览器能够根据具体的设置缓存链接的所有外部 JavaScript 文件 适应未来 文档模式的影响最初的两种文档模式是:混杂模式(quirks mode)和标准模式(standards mode)。1234&lt;!-- HTML 4.01 严格型 --&gt;&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\"&gt;&lt;!-- HTML 5 --&gt;&lt;!DOCTYPE html&gt; 禁用javascript的场景关于禁用javascript的场景，主要是&lt;noscript&gt;这个元素可以包含能够出现在文档&lt;body&gt;中的任何 HTML 元素——&lt;script&gt;元素除外。包含 在&lt;noscript&gt;元素中的内容只有在下列情况下才会显示出来: 浏览器不支持脚本; 浏览器支持脚本，但脚本被禁用。123456789101112&lt;html&gt; &lt;head&gt; &lt;title&gt;Example HTML Page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;noscript&gt; &lt;p&gt;本页面需要浏览器支持(启用)JavaScript。 &lt;/noscript&gt; &lt;script type=\"text/javascript\" defer=\"defer\" src=\"example1.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" defer=\"defer\" src=\"example2.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 总结把 JavaScript 插入到 HTML 页面中要使用&lt;script&gt;元素。使用这个元素可以把 JavaScript 嵌入到 HTML 页面中，让脚本与标记混合在一起;也可以包含外部的 JavaScript 文件。而我们需要注意的地方有: 在包含外部 JavaScript 文件时，必须将 src 属性设置为指向相应文件的 URL。而这个文件既可 以是与包含它的页面位于同一个服务器上的文件，也可以是其他任何域中的文件。 所有&lt;script&gt;元素都会按照它们在页面中出现的先后顺序依次被解析。在不使用 defer 和 async 属性的情况下，只有在解析完前面&lt;script&gt;元素中的代码之后，才会开始解析后面 &lt;script&gt;元素中的代码。 由于浏览器会先解析完不使用 defer 属性的&lt;script&gt;元素中的代码，然后再解析后面的内容， 所以一般应该把&lt;script&gt;元素放在页面最后，即主要内容后面，&lt;／body&gt;标签前面。 使用 defer 属性可以让脚本在文档完全呈现之后再执行。延迟脚本总是按照指定它们的顺序执行。 使用 async 属性可以表示当前脚本不必等待其他脚本，也不必阻塞文档呈现。不能保证异步脚本按照它们在页面中出现的顺序执行。 另外，使用&lt;noscript&gt;元素可以指定在不支持脚本的浏览器中显示的替代内容。但在启用了脚本的情况下，浏览器不会显示&lt;noscript&gt;元素中的任何内容。","categories":[{"name":"JS高程填坑笔记","slug":"JS高程填坑笔记","permalink":"http://yoursite.com/categories/JS高程填坑笔记/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"window.location的属性","slug":"window.location的属性","date":"2018-06-10T03:23:35.000Z","updated":"2018-06-28T10:00:35.000Z","comments":true,"path":"2018/06/10/window.location的属性/","link":"","permalink":"http://yoursite.com/2018/06/10/window.location的属性/","excerpt":"","text":"关于http的相关的BOM的问题 获取当前url的协议1const protocol = window.location.protocol; 获取当前的host和端口号1const host = window.location.host; 获取当前完整的URL1const host = window.location.href; 获取当前pathName1const host = window.location.pathname; 获取当前url的查找内容1const host = window.location.search;","categories":[{"name":"bug汇总","slug":"bug汇总","permalink":"http://yoursite.com/categories/bug汇总/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"CSS占坑","slug":"CSS占坑","date":"2018-05-29T10:15:44.000Z","updated":"2018-05-29T10:19:28.000Z","comments":true,"path":"2018/05/29/CSS占坑/","link":"","permalink":"http://yoursite.com/2018/05/29/CSS占坑/","excerpt":"","text":"占个坑就留着回家写吧～哈哈哈","categories":[{"name":"Glory Road","slug":"Glory-Road","permalink":"http://yoursite.com/categories/Glory-Road/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"链表","slug":"链表","date":"2018-05-28T08:20:40.000Z","updated":"2018-06-28T10:00:35.000Z","comments":true,"path":"2018/05/28/链表/","link":"","permalink":"http://yoursite.com/2018/05/28/链表/","excerpt":"","text":"定义链表是由一组节点组成的集合。每一个节点都使用一个对象的引用指向它的后续借点。指向另外一个节点的引用叫做链。链表元素则是靠相互之间的关系进行引用。在链表中就说这个元素是某个元素的后面一个元素。遍历链表就是跟着链表从链表的头元素（head）一直走到尾元素（但是不包含链表的头节点，头通常用来作为链表的接入点）。链表的尾元素指向一个null节点。 分类单链表（见定义） 循环链表循环链表的运算与单链表的运算基本一致。所不同的有以下几点：1、在建立一个循环链表时，必须使其最后一个结点的指针指向表头结点，而不是象单链表那样置为NULL。此种情况还使用于在最后一个结点后插入一个新的结点。2、在判断是否到表尾时，是判断该结点链域的值是否是表头结点，当链域值等于表头指针时，说明已到表尾。而非象单链表那样判断链域值是否为NULL。 双向链表双向链表其实是单链表的改进。当我们对单链表进行操作时，有时你要对某个结点的直接前驱进行操作时，又必须从表头开始查找。这是由单链表结点的结构所限制的。因为单链表每个结点只有一个存储直接后继结点地址的链域，那么能不能定义一个既有存储直接后继结点地址的链域，又有存储直接前驱结点地址的链域的这样一个双链域结点结构呢？这就是双向链表。在双向链表中，结点除含有数据域外，还有两个链域，一个存储直接后继结点地址，一般称之为右链域；一个存储直接前驱结点地址，一般称之为左链域。 链表的操作链表的操作通常需要操作两个节点，例如，向链表中插入一个节点，需要修改它前面的节点，使其指向新加入的节点，而新加入的节点则指向前面指向的节点从链表中删除一个节点也很简单，将待删除的元素的前驱节点指向待删除的后续节点，同时将待删除元素指向null来释放。 代码实现12345//Definition for singly-linked list.function ListNode(val) &#123; this.val = val; this.next = null;&#125; 查找：12345678910const findListNode = (listNode, target) =&gt; &#123; while(listNode) &#123; if (listNode.val === target) &#123; return true; &#125;; listNode = listNode.next ? listNode.next : null &#125; return \"not hava this target\";&#125; 插入12345678910111213//在第target个元素后添加一个节点const insertListNode = (listNode1, node, target) =&gt; &#123; const count = 0 while(listNode) &#123; if (count === target) &#123; node.next = listNode.next; listNode.next = node return 0; &#125;; listNode = listNode.next ? listNode.next : null count++; &#125;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/算法学习/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"html5语意化学习","slug":"html5语意化学习","date":"2018-05-28T02:46:36.000Z","updated":"2018-06-28T10:00:35.000Z","comments":true,"path":"2018/05/28/html5语意化学习/","link":"","permalink":"http://yoursite.com/2018/05/28/html5语意化学习/","excerpt":"","text":"百度前端技术学院学习笔记（二） 百度前端技术学院，第二天课程已经脱了好几天了，最近项目上线以及一些其他的事情，一只拖延着我这只拖延狗的进度。。今天终于抽出时间来整理一下这个知识点。 目标简介 Date: 2018.05.28 Mon Target: 熟悉html语意化。 Time: 1day 语意化探究语意化，就是根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。那通俗一点来说，就是为了让编写让人和机器都认识的代码。 语意化的意义 为了在没有样式的时候，页面也能呈现出很好地内容结构、代码结构 更好的用户体验 便于SEO 方便其他设备解析 便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。 部分语意化标签 标签 意义 用法 header 头部标签 用于网页顶部，作为头部 footer 底部标签 用于网页底部，内容多相关信息 hgroup 网页标签 网页或者含有多个h标签的 nav 导航标签 放置导航栏 aside 侧栏标签 侧边栏的内容 section 区块的标签 一个独立的区域 article 文章标签 一片文章的区域 h1-h6 标题标签 按照标题的大小选择 p 段落标签 一个段落 audio 声音标签 用来链接音频 video 视频标签 用来链接视频 相关问题Q1: HTML是什么，HTML5是什么？A1: 超级文本标记语言是标准通用标记语言下的一个应用，也是一种规范，一种标准，它通过标记符号来标记要显示的网页中的各个部分。HTML5是HTML的第五次修改，HTML5的革新之一：语义化标签一节元素标签。 Q2: HTML元素标签、属性都是什么概念？A2: HTML的标签就是一个个网页的结构元素，一个网页是由一个个元素组合起来的。属性是标签的一些性质，包括ID、名称、URI、数字、长度单位、语言、媒体描述符、颜色、字符编码、日期和时间等。 Q3: 文档类型是什么概念，起什么作用？A3: 文档类型有严格模式和非严格模式，应用严格模式来编写页面，更严谨。H5没有文档类型。 Q4: meta标签都用来做什么的？A4: 元素可提供相关页面的元信息（meta-information），标签位于文档的头部，不包含任何内容。标签的属性定义了与文档相关联的名称/值对。 meta标签共有两个属性，它们分别是http-equiv属性和name属性，不同的属性又有不同的参数值，这些不同的参数值就实现了不同的网页功能。 meta 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。 meta 标签位于文档的头部，不包含任何内容。 meta 标签的属性定义了与文档相关联的名称/值对。 Q5: Web语义化是什么，是为了解决什么问题A5：就是根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析解决了SEO等问题 Q6: 链接是什么概念，对应什么标签？A6: 是支持浏览器文档与外部资源的关系。对应link标签","categories":[{"name":"Glory Road","slug":"Glory-Road","permalink":"http://yoursite.com/categories/Glory-Road/"}],"tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]},{"title":"插入排序","slug":"插入排序","date":"2018-05-25T08:07:55.000Z","updated":"2018-06-28T10:00:35.000Z","comments":true,"path":"2018/05/25/插入排序/","link":"","permalink":"http://yoursite.com/2018/05/25/插入排序/","excerpt":"","text":"插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，但将最后一个元素除外（让数组多一个空间才有插入的位置），而第二部分就只包含这一个元素（即待插入元素）。在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。插入排序的基本思想是：每步将一个待排序的记录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。 直接插入排序的算法思路：（1） 设置监视哨r[0]，将待插入记录的值赋值给r[0]；（2） 设置开始查找的位置j；（3） 在数组中进行搜索，搜索中将第j个记录后移，直至r[0].key≥r[j].key为止；（4） 将r[0]插入r[j+1]的位置上。 1234567891011121314const insertionSort = (arr) =&gt; &#123; let len = arr.length; for(let i=1; i&lt;len; i++) &#123; let j = i; let tmp = arr[i]; while(j &gt; 0 &amp;&amp; arr[j-1] &gt; tmp) &#123; arr[j] = arr[j-1]; j--; &#125; arr[j] = tmp; &#125; return arr;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/算法学习/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"正则填坑","slug":"正则填坑","date":"2018-05-25T05:58:47.000Z","updated":"2018-06-28T09:52:14.000Z","comments":true,"path":"2018/05/25/正则填坑/","link":"","permalink":"http://yoursite.com/2018/05/25/正则填坑/","excerpt":"","text":"正则表达式 简介正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为”元字符”）。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。 应用通过使用正则表达式，可以：1、测试字符串内的模式。例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。替换文本。2、可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。基于模式匹配从字符串中提取子字符串。3、可以查找文档内或输入域内特定的文本。 语法正则表达式包含好多种字符，普通字符，非打印字符，特殊字符，限定符，定位符 元字符 字符 描述 \\ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\\n’ 匹配一个换行符。序列 ‘\\‘ 匹配 “\\” 而 “(“ 则匹配 “(“。 ^ 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\\n’ 或 ‘\\r’ 之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\\n’ 或 ‘\\r’ 之前的位置。 * 匹配前面的子表达式零次或多次。例如，zo 能匹配 “z” 以及 “zoo”。 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 ? 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。 . 匹配除换行符（\\n、\\r）之外的任何单个字符。要匹配包括 ‘\\n’ 在内的任何字符，请使用像”(.\\n)”的模式。 [xyz] 字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’、’l’、’i’、’n’。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。 [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。 \\b 匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。 \\B 匹配非单词边界。’er\\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。 \\cx 匹配由 x 指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。 \\d 匹配一个数字字符。等价于 [0-9]。 \\D 匹配一个非数字字符。等价于 [^0-9]。 \\f 匹配一个换页符。等价于 \\x0c 和 \\cL。 \\n 匹配一个换行符。等价于 \\x0a 和 \\cJ。 \\r 匹配一个回车符。等价于 \\x0d 和 \\cM。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。 \\S 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。 \\t 匹配一个制表符。等价于 \\x09 和 \\cI。 \\v 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。 \\w 匹配字母、数字、下划线。等价于’[A-Za-z0-9_]’。 \\W 匹配非字母、数字、下划线。等价于 ‘[^A-Za-z0-9_]’。 \\xn 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，’\\x41’ 匹配 “A”。’\\x041’ 则等价于 ‘\\x04’ &amp; “1”。正则表达式中可以使用 ASCII 编码。 \\num 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，’(.)\\1’ 匹配两个连续的相同字符。 \\n 标识一个八进制转义值或一个向后引用。如果 \\n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。 \\nm 标识一个八进制转义值或一个向后引用。如果 \\nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \\nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \\nm 将匹配八进制转义值 nm。 \\nml 如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。 \\un 匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \\u00A9 匹配版权符号 (?)。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"放飞的thinking～","slug":"放飞的thinking～","date":"2018-05-24T08:53:09.000Z","updated":"2018-06-28T10:00:35.000Z","comments":true,"path":"2018/05/24/放飞的thinking～/","link":"","permalink":"http://yoursite.com/2018/05/24/放飞的thinking～/","excerpt":"","text":"百度前端技术学院学习笔记（一） 目标简介 Date: 2018.05.24 Thr Flag: 真男人就坚持66天。 Target: 了解前端。 Time: 1h 课程内容1、什么是前端？ 前端这个概念，我觉得应该这么来理解，前：表示与用户直接有关的部分，比如页面的展示，与用户的交互等，端：是终端的部分，包括pc，移动端以及其他的一些可以与用于交互的终端。 从百度百科上看到了前端的解释： 前端即网站前台部分，运行在PC端，移动端等浏览器上展现给用户浏览的网页。随着互联网技术的发展，HTML5，CSS3，前端框架的应用，跨平台响应式网页设计能够适应各种屏幕分辨率，完美的动效设计，给用户带来极高的用户体验。 感觉差不多吧… 2、什么是html？ html：超文本标记语言，标准通用标记语言下的一个应用。 我理解的是，用来构建页面的骨架的语言。 html提供了语义化的标签，以及相关的属性，根据标签和属性以及内容构建页面的骨架。 3、什么是CSS？ CSS：层叠样式表(英文全称：Cascading Style Sheets)是一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的计算机语言。CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。 CSS，可以理解成骨架的衣服，好的页面有了骨架还不行，还得需要漂亮的衣服。html写好了骨架，通过写CSS来写样式，让页面变得更好看。 4、什么是Javascript？ JavaScript一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加动态功能。 js是一种脚本语言，可以给页面添加交互，以及相关的逻辑，还有和后台通过接口交互数据等。 课程疑问1、现在背景下的大前端该如何发展？2、框架的不断推出，框架的学习和个人技能的发展的均衡？3、因为node的存在，前端工程师往全栈工程师的发展是否成为必要？ 总结学习前端有一年的时间了，半路出家，从机械转到了前端。从开始写外包，囫囵吞枣，会用就行，到工作之后，发现自己欠缺的东西还有好多好多。开始逐渐的弥补自己的知识。虽然起步比较晚，但是还是很喜欢js这个不断进步的语言～希望能够通过自己的努力，成为一个真正的FE developer！","categories":[{"name":"Glory Road","slug":"Glory-Road","permalink":"http://yoursite.com/categories/Glory-Road/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"},{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]},{"title":"koa2源码学习--application.js","slug":"koa2源码学习--application.js","date":"2018-05-24T06:00:14.000Z","updated":"2018-05-25T05:58:14.000Z","comments":true,"path":"2018/05/24/koa2源码学习--application.js/","link":"","permalink":"http://yoursite.com/2018/05/24/koa2源码学习--application.js/","excerpt":"","text":"一直很想研究下koa2，虽然还是小白一枚，但终于决定入坑koa2。之前只知道koa2采用了ES2015和ES2016的一些东西，还知道洋葱头的中间件的运行机制。还是先研究一下源码，学习一下大神写代码的畅快感。 把代码拉下来之后，发现lib里只有四个源码文件：application.js, context.js, request.js, response.js。 application.js 是koa的入口文件,是一个构造函数，它暴露整个应用的class, 这个class继承自node自带的events，并且把 context、request 和 response 属性指向了原型链指向其他三个文件导出对象的实例。 application暴露了一些公用的api, 比如listen，use, callback等。 下面来研究一些application.js的源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256'use strict';/** * 依赖的模块 */const isGeneratorFunction = require('is-generator-function'); //判断函数是否为generator函数const debug = require('debug')('koa:application'); //调试模式const onFinished = require('on-finished'); //HTTP请求关闭，完成或错误时执行回调。const response = require('./response'); //reponse.jsconst compose = require('koa-compose'); //koa中间件组合工具const isJSON = require('koa-is-json'); //检查body应该是一个json格式const context = require('./context'); //上下文context.jsconst request = require('./request'); //request.jsconst statuses = require('statuses'); ////http状态工具status(403) // =&gt; 'Forbidden'，可以通过code转换成msg，也可以通过msg转换成codeconst Cookies = require('cookies'); //提供一个读写cookie的APIconst accepts = require('accepts'); //一个比较高级的API用来http处理请求中的接受类型，const Emitter = require('events'); //node的events模块？const assert = require('assert'); //通过状态码进行断言？const Stream = require('stream'); //流文件？const http = require('http'); // node的http模块？const only = require('only'); //返回白名单中的值。其实就是根据一个列表获取一个对象中的部分属性返回一个objconst convert = require('koa-convert'); //提供function *的语法的转换器const deprecate = require('depd')('koa'); //提示？/** * 暴露一个application的类 * 继承自 `Emitter.prototype`. */module.exports = class Application extends Emitter &#123; /** * 初始化一个新的 `Application`. * * @api public */ constructor() &#123; super(); //定义下面的属性 this.proxy = false; //代理 this.middleware = []; //中间件的队列 this.subdomainOffset = 2; //对于要忽略的 .subdomains 偏移[2] this.env = process.env.NODE_ENV || 'development'; //env默认是 NODE_ENV 或 \"development\" this.context = Object.create(context); //创建一个新context对象，使用context对象来提供新创建的对象的__proto__。 this.request = Object.create(request);//创建一个新request对象 this.response = Object.create(response);//创建一个新response对象 &#125; /** * Shorthand for: * * http.createServer(app.callback()).listen(...) * * @param &#123;Mixed&#125; ... * @return &#123;Server&#125; * @api public */ //listen(),调用node的createServer方法，返回一个服务器。参数为端口号， listen(...args) &#123; debug('listen'); const server = http.createServer(this.callback());// return server.listen(...args); &#125; /** * Return JSON representation. * We only bother showing settings. * * @return &#123;Object&#125; * @api public */ //toJSON 方法，通过only方法，把key放到obj里 返回一个object对象 toJSON() &#123; return only(this, [ 'subdomainOffset', 'proxy', 'env' ]); &#125; /** * Inspect implementation. * * @return &#123;Object&#125; * @api public */ //检查,返回一个object对象 inspect() &#123; return this.toJSON(); &#125; /** * 把给定的中间件函数fn，推入到middleware队列中 * * 以前写法的中间件将会被转换 * * @param &#123;Function&#125; fn * @return &#123;Application&#125; self * @api public */ use(fn) &#123; if (typeof fn !== 'function') throw new TypeError('middleware must be a function!'); if (isGeneratorFunction(fn)) &#123; deprecate('Support for generators will be removed in v3. ' + 'See the documentation for examples of how to convert old middleware ' + 'https://github.com/koajs/koa/blob/master/docs/migration.md'); fn = convert(fn); &#125; debug('use %s', fn._name || fn.name || '-'); this.middleware.push(fn); return this; &#125; /** * Return a request handler callback * for node's native http server. * * @return &#123;Function&#125; * @api public */ //返回适用于 http.createServer() 方法的回调函数来处理请求。 //启动server和接收请求 callback() &#123; const fn = compose(this.middleware);//启动server时执行，初始化中间件 if (!this.listenerCount('error')) this.on('error', this.onerror); //接收请求时执行处理请求的函数 const handleRequest = (req, res) =&gt; &#123; const ctx = this.createContext(req, res);//创建一个最终可用的context return this.handleRequest(ctx, fn); &#125;; return handleRequest; &#125; /** * callback里的一个处理请求的方法， * * @api private */ handleRequest(ctx, fnMiddleware) &#123; const res = ctx.res; res.statusCode = 404; const onerror = err =&gt; ctx.onerror(err); const handleResponse = () =&gt; respond(ctx); onFinished(res, onerror); return fnMiddleware(ctx).then(handleResponse).catch(onerror); &#125; /** * Initialize a new context. * * @api private */ createContext(req, res) &#123; const context = Object.create(this.context); const request = context.request = Object.create(this.request); const response = context.response = Object.create(this.response); context.app = request.app = response.app = this; context.req = request.req = response.req = req; context.res = request.res = response.res = res; request.ctx = response.ctx = context; request.response = response; response.request = request; context.originalUrl = request.originalUrl = req.url; context.cookies = new Cookies(req, res, &#123; keys: this.keys, secure: request.secure &#125;); request.ip = request.ips[0] || req.socket.remoteAddress || ''; context.accept = request.accept = accepts(req); context.state = &#123;&#125;; return context; &#125; /** * Default error handler. * * @param &#123;Error&#125; err * @api private */ onerror(err) &#123; assert(err instanceof Error, `non-error thrown: $&#123;err&#125;`); if (404 == err.status || err.expose) return; if (this.silent) return; const msg = err.stack || err.toString(); console.error(); console.error(msg.replace(/^/gm, ' ')); console.error(); &#125;&#125;;/** * Response helper. */function respond(ctx) &#123; // allow bypassing koa if (false === ctx.respond) return; const res = ctx.res; if (!ctx.writable) return; let body = ctx.body; const code = ctx.status; // ignore body if (statuses.empty[code]) &#123; // strip headers ctx.body = null; return res.end(); &#125; if ('HEAD' == ctx.method) &#123; if (!res.headersSent &amp;&amp; isJSON(body)) &#123; ctx.length = Buffer.byteLength(JSON.stringify(body)); &#125; return res.end(); &#125; // status body if (null == body) &#123; body = ctx.message || String(code); if (!res.headersSent) &#123; ctx.type = 'text'; ctx.length = Buffer.byteLength(body); &#125; return res.end(body); &#125; // responses if (Buffer.isBuffer(body)) return res.end(body); if ('string' == typeof body) return res.end(body); if (body instanceof Stream) return body.pipe(res); // body: json body = JSON.stringify(body); if (!res.headersSent) &#123; ctx.length = Buffer.byteLength(body); &#125; res.end(body);&#125;","categories":[{"name":"koa2源码学习","slug":"koa2源码学习","permalink":"http://yoursite.com/categories/koa2源码学习/"}],"tags":[{"name":"Koa","slug":"Koa","permalink":"http://yoursite.com/tags/Koa/"},{"name":"Node","slug":"Node","permalink":"http://yoursite.com/tags/Node/"}]},{"title":"react生命周期理解","slug":"react生命周期理解","date":"2018-05-22T06:13:57.000Z","updated":"2018-05-24T08:29:23.000Z","comments":true,"path":"2018/05/22/react生命周期理解/","link":"","permalink":"http://yoursite.com/2018/05/22/react生命周期理解/","excerpt":"","text":"react组建的生命周期 React组件的生命周期有两种情况，初次渲染和状态更新导致再次渲染。React 生命周期分为三种状态 1. 挂载 2.更新 3.销毁 组件加载组件的初次挂载，有以下几个步骤，分别是1、构造函数，指定This，初始状态，绑定函数（constructor）2、组件安装（componentWillMount）3、将组建或者虚拟DOM元素渲染到真实的DOM上（render）4、组件生成，DOM查找等(componentDidMount) 组件更新组件的更新，有三种情况：1.父组件的props发生更新2.调用this.forceUpdate更新（重复componentWillUpdate方法之后的操作）3.调用this.setState方法更新组件state,触发组件更新 状态更新步骤：1、构造函数，指定This，初始状态，绑定函数（constructor）2、组件安装（componentWillMount）3、将组建或者虚拟DOM元素渲染到真实的DOM上（render）4、组件生成，DOM查找等(componentDidMount)5、组建更新状态(componentWillUpdate)6、将组建或者虚拟DOM元素渲染到真实的DOM上（render）7、组建更新完成(componentDidUpdate) 调用this.forceUpdate更新当组件调用forceUpdata方法更新时，会进入componentWillUpdate方法。直接跳过shouldComponentUpdtavoid之后执行render函数更新DOMReactElement执行完render函数之后执行componentDidUpdata,除了首次render之后调用componentDidMount，其它render结束之后都是调用componentDidUpdate。 父组建更新props步骤：1、父组件构造函数，指定This，初始状态，绑定函数（constructor）2、父组件安装（componentWillMount）3、父组件或者虚拟DOM元素渲染到真实的DOM上（render）4、子组件或者虚拟DOM元素渲染到真实的DOM上（render）5、父组件生成，DOM查找等(componentDidMount)6、父组建更新状态(componentWillUpdate)7、父组件或者虚拟DOM元素渲染到真实的DOM上（render）8、子组件接收父组件props(componentWillReceiveProps)9、子组件判断是否更新(shouldComponentUpdate)10、子组建更新状态(componentWillUpdate)11、子组件或者虚拟DOM元素渲染到真实的DOM上（render）12、子组件更新完成(componentDidUpdate)12、父组件更新完成(componentDidUpdate) 组件销毁单页应用中，切换页面原组件需要销毁释放资源，如果原组件中有定时器等不能销毁时，需要在componentWillUnmount中清理资源占用，手动销毁定时器。 总结","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"},{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"堆排序","slug":"堆排序","date":"2018-05-21T07:05:00.000Z","updated":"2018-06-28T10:00:35.000Z","comments":true,"path":"2018/05/21/堆排序/","link":"","permalink":"http://yoursite.com/2018/05/21/堆排序/","excerpt":"","text":"堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] &gt;= A[i]。在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶。 具体算法描述如下： 1、将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；2、将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn), 且满足R[1,2…n-1]&lt;=R[n]；3、由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。 时间复杂度：最好：O(nlog2n)，最坏：O(nlog2n)，平均：O(nlog2n)。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/*方法说明：堆排序@param array 待排序数组*/ const heapSort = (arr) =&gt; &#123; if (Object.prototype.toString.call(array).slice(8, -1) === 'Array') &#123; //建堆 let heapSize = array.length, temp; for (let i = Math.floor(heapSize / 2); i &gt;= 0; i--) &#123; heapify(array, i, heapSize); &#125; //堆排序 for (let j = heapSize - 1; j &gt;= 1; j--) &#123; temp = array[0]; array[0] = array[j]; array[j] = temp; heapify(array, 0, --heapSize); &#125; &#125; else &#123; return 'array is not an Array!'; &#125;&#125;/*方法说明：维护堆的性质@param arr 数组@param x 数组下标@param len 堆大小*/const heapify = (arr, x, len) =&gt; &#123; if (Object.prototype.toString.call(arr).slice(8, -1) === 'Array' &amp;&amp; typeof x === 'number')&#123; let l = 2 * x, r = 2 * x + 1, largest = x, temp; if (l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) &#123; largest = l; &#125; if (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) &#123; largest = r; &#125; if (largest != x) &#123; temp = arr[x]; arr[x] = arr[largest]; arr[largest] = temp; heapify(arr, largest, len); &#125; &#125; else &#123; return 'arr is not an Array or x is not a number!'; &#125;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/算法学习/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"归并排序","slug":"归并排序","date":"2018-05-19T06:45:11.000Z","updated":"2018-06-28T09:52:38.000Z","comments":true,"path":"2018/05/19/归并排序/","link":"","permalink":"http://yoursite.com/2018/05/19/归并排序/","excerpt":"","text":"归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。 把长度为n的输入序列分成两个长度为n/2的子序列；对这两个子序列分别采用归并排序；将两个排序好的子序列合并成一个最终的排序序列。 归并操作的工作原理如下：第一步：申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列第二步：设定两个指针，最初位置分别为两个已经排序序列的起始位置第三步：比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置重复步骤3直到某一指针超出序列尾将另一序列剩下的所有元素直接复制到合并序列尾 最佳情况：T(n) = O(n)最差情况：T(n) = O(nlogn)平均情况：T(n) = O(nlogn) 123456789101112131415161718const mergeSort = (arr) =&gt; &#123; let len = arr.lenght; if (len &lt; 2) &#123; return arr; &#125; let m = (len &gt;&gt; 1), //通过位运算符，将len取为一半。 left = array.slice(0, m), right = array.slice(m); //拆分为两个子数组 return merge(mergeSort(left), mergeSort(right));//子数组继续递归拆分,然后再合并&#125;const merge = (left, right) =&gt; &#123; //合并两个子数组 let res = []; while (left.length &amp;&amp; right.length) &#123; let item = left[0] &lt;= right[0] ? left.shift() : right.shift();//注意:判断的条件是小于或等于,如果只是小于,那么排序将不稳定. result.push(item); &#125; return result.concat(left.length ? left : right);&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/算法学习/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"选择排序","slug":"选择排序","date":"2018-05-19T06:27:21.000Z","updated":"2018-06-28T10:00:35.000Z","comments":true,"path":"2018/05/19/选择排序/","link":"","permalink":"http://yoursite.com/2018/05/19/选择排序/","excerpt":"","text":"选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法。 简单选择排序的基本思想：第1趟，在待排序记录r[1]~r[n]中选出最小的记录，将它与r[1]交换；第2趟，在待排序记录r[2]~r[n]中选出最小的记录，将它与r[2]交换；以此类推，第i趟在待排序记录r[i]~r[n]中选出最小的记录，将它与r[i]交换，使有序序列不断增长直到全部排序完毕。 最佳情况：T(n) = O(n^2)最差情况：T(n) = O(n^2)平均情况：T(n) = O(n^2) 1234567891011const selectSort = (arr) =&gt; &#123; let len = arr.length, min; for (let i = 0; i &lt; len - 1; i++) &#123; min = i; for (let j = i + 1; j &lt; len; j++)&#123; arr[j] &lt; arr[min] &amp;&amp; (min = j); &#125; min != i &amp;&amp; swap(i,min,arr); &#125; return arr&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/算法学习/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"快速排序","slug":"快速排序","date":"2018-05-19T06:01:19.000Z","updated":"2018-06-28T10:00:35.000Z","comments":true,"path":"2018/05/19/快速排序/","link":"","permalink":"http://yoursite.com/2018/05/19/快速排序/","excerpt":"","text":"快速排序（Quicksort）是对冒泡排序的一种改进。快速排序的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 一趟快速排序的算法是：（1）在数据集之中，选择一个元素作为”基准”（pivot）。（2）所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。（3）对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。 最佳情况：T(n) = O(nlogn)最差情况：T(n) = O(n2)平均情况：T(n) = O(nlogn) 12345678910111213141516const quickSort = (arr) =&gt; &#123; if (arr.length &lt;= 1) &#123; return arr; &#125; let pivotIndex = arr.length &gt;&gt; 1; console.log(pivotIndex); let pivot = arr.splice(pivotIndex, 1)[0]; let left = []; let right = []; for (let i = 0; i &lt; arr.length; i++)&#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; return quickSort(left).concat([pivot], quickSort(right));&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/算法学习/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"冒泡排序","slug":"冒泡排序","date":"2018-05-19T05:35:51.000Z","updated":"2018-06-28T10:00:35.000Z","comments":true,"path":"2018/05/19/冒泡排序/","link":"","permalink":"http://yoursite.com/2018/05/19/冒泡排序/","excerpt":"","text":"冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。 冒泡排序算法的运作如下：（从后往前）比较相邻的元素。如果第一个比第二个大，就交换他们两个。对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。针对所有的元素重复以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 时间复杂度：冒泡排序最好的时间复杂度为O(n)。冒泡排序的最坏时间复杂度为O(n^2)。冒泡排序总的平均时间复杂度为O(n^2)。 12345678910111213const bubbleSort = (arr) =&gt; &#123; let len = arr.length; for (let i = 0; i &lt; len - 1; i++) &#123; for (let j = 0; j &lt; len - 1 - j; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; let temp = arr[j+1]; arr[j+1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; return arr;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/算法学习/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"ajax实现","slug":"ajax实现","date":"2018-05-16T03:18:33.000Z","updated":"2018-06-28T10:00:35.000Z","comments":true,"path":"2018/05/16/ajax实现/","link":"","permalink":"http://yoursite.com/2018/05/16/ajax实现/","excerpt":"","text":"Q1: 何谓ajax，它有何优点？A1:AJAX = 异步 JavaScript 和 XML。AJAX 是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据 交换，AJAX 可以使网页实现异步更新 Q2:ajax 如何实现？A2:步骤：(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象. (2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息. (3)设置响应HTTP请求状态变化的函数. (4)发送HTTP请求. (5)获取异步调用返回的数据. (6)使用JavaScript和DOM实现局部刷新. 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;html&gt; &lt;head&gt; &lt;title&gt;AJAX实例&lt;/title&gt; &lt;script language=\"javascript\" type=\"text/javascript\"&gt; var xmlHttpRequest; //定义一个变量用于存放XMLHttpRequest对象 //定义一个用于创建XMLHttpRequest对象的函数 function createXMLHttpRequest()&#123; if(window.ActiveXObject)&#123; //IE浏览器的创建方式 xmlHttpRequest = new ActiveXObject(\"Microsoft.XMLHTTP\"); &#125;else if(windew.XMLHttpRequest)&#123; //Netscape浏览器中的创建方式 xmlHttpRequest = new XMLHttpRequest(); &#125; &#125; //响应HTTP请求状态变化的函数 function httpStateChange()&#123; //判断异步调用是否完成 if(xmlHttpRequest.readyState == 4)&#123; //判断异步调用是否成功,如果成功开始局部更新数据 if(xmlHttpRequest.status == 200||xmlHttpRequest.status == 0)&#123; //查找节点 var node = document.getElementById(\"myDIv\"); //更新数据 node.firstChild.nodeValue = xmlHttpRequest .responseText; &#125;else&#123; //如果异步调用未成功,弹出警告框,并显示出错信息 alert(\"异步调用出错/n返回的HTTP状态码为:\"+xmlHttpRequest.status + \"/n返回的HTTP状态信息为:\" + xmlHttpRequest.statusText); &#125; &#125; &#125; //异步调用服务器段数据 function getData(name,value)&#123; //创建XMLHttpRequest对象 createXMLHttpRequest(); if(xmlHttpRequest!=null)&#123; //创建HTTP请求 xmlHttpRequest.open(\"get\",\"ajax.text\",true) //设置HTTP请求状态变化的函数 xmlHttpRequest.onreadystatechange = httpStateChange; //发送请求 xmlHttpRequest.send(null); &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"myDiv\"&gt;原数据&lt;/div&gt; &lt;input type = \"button\" value = \"更新数据\" onclick = \"getData()\"&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"Demo练习","slug":"Demo练习","permalink":"http://yoursite.com/categories/Demo练习/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"跨域问题探究","slug":"跨域问题探究","date":"2018-05-15T06:34:50.000Z","updated":"2018-06-28T10:00:35.000Z","comments":true,"path":"2018/05/15/跨域问题探究/","link":"","permalink":"http://yoursite.com/2018/05/15/跨域问题探究/","excerpt":"","text":"Q1: 什么是跨域？A1: 一个域上加载的脚本获取或操作另一个域上的文档属性，是指a页面想获取b页面资源，如果a、b页面的协议、域名、端口、子域名不同，或是a页面为ip地址，b页面为域名地址，所进行的访问行动都是跨域的。而浏览器为了安全问题一般都限制了跨域访问，也就是不允许跨域请求资源。 Q2: 怎么算跨域？A2: Uri 说明 是否跨域 http://www.cnblogs.com/a.js http://www.a.com/b.js 不同域名 是 http://www.a.com/lab/a.js http://www.a.com/script/b.js 同域名下不同文件 否 http://www.a.com:8000/a.js http://www.a.com/b.js 同域名下不同端口 是 http://www.a.com/a.js s https://www.a.com/b.js 同域名 不同协议 是 http://www.a.com/a.js http://70.32.92.74/b.jss 域名和域名对应ip 是 http://www.a.com/a.js http://script.a.com/b.js 主域名相同 子域名不同 是（cookie不可访问） http://www.a.com/a.js http://a.com/b.js 同一域名，不同二级域名（同上） 是 Q3: 什么是浏览器的同源策略？A3: 计算机的本地与Web是不同的层面，Web世界（通常称为Internet域）运行在浏览器上，而被限制了直接进行本地数据（通常称为本地域）的读写。同源策略是众多安全策略的一个，是Web层面上的策略，同源策略规定：不同域的客户端脚本在没明确授权的情况下，不能读写对方的资源。 Q4: 怎么解决跨域？A4: 有那么几种方法可以来解决跨域：1、Jsonp 需要目标服务器配合一个callback函数，但是注意JSONP只支持GET请求，不支持POST请求。 123456789101112131415&lt;script type=\"text/javascript\" src=\"jquery.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $.ajax(&#123; url: api.testURI, dataType:'jsonp', data:'', jsonp:'callback', success:function(result) &#123; for(var i in result) &#123; alert(i+\":\"+result[i]);//循环输出a:1,b:2,etc. &#125; &#125;, timeout:3000 &#125;); &lt;/script&gt; 2、通过修改document.domain来跨子域将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域。主域相同的使用document.domain 3、使用window.name来进行跨域 12345window.name = data; //接着，子窗口跳回一个与主窗口同域的网址。 location = 'http://parent.url.com/xxx.html'; //然后，主窗口就可以读取子窗口的window.name了 var data = document.getElementById('iframe').contentWindow.name; 4、通过CORS解决AJAX跨域 12345678910111213141516171819function test() &#123; $.ajax(&#123; url: api.testURI, type: \"get\", async: false, data:&#123; \"id\":1 &#125;, dataType:\"json\", withCredentials:true, success: function(data)&#123; alert(data); alert(data.code); &#125;, error: function()&#123; alert('fail'); &#125; &#125;)&#125; 5.服务器设置Access-Control-Allow-Origin实现跨域 123456app.all(\"*\", function(req, res, next) &#123; const host = req.headers.origin; res.header('Access-Control-Allow-Origin', host) //res.header('Access-Control-Allow-Origin', *) next();&#125;);","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[]},{"title":"webpack 配置理解","slug":"webpack-配置理解","date":"2018-05-15T05:48:01.000Z","updated":"2018-06-28T10:00:35.000Z","comments":true,"path":"2018/05/15/webpack-配置理解/","link":"","permalink":"http://yoursite.com/2018/05/15/webpack-配置理解/","excerpt":"","text":"webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 webpack 4 虽然已经不需要引入一个配置文件。但是，webpack在实际的应用中还是会配置很多东西。下面就是对webpack的配置分析：从webpack文档中找出路配置，进行了分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355const path = require('path');module.exports = &#123; mode: \"production\", // \"production\" | \"development\" | \"none\" // webpack有三种模式：生产模式，开发模式，none；选择模式告诉webpack相应地使用其内置优化。 entry: \"./app/entry\", // string | object | array // webpack的入口文件，这里应用程序开始执行 // webpack 开始打包 output: &#123; // webpack 如何输出结果的相关选项 path: path.resolve(__dirname, \"dist\"), // string // 所有输出文件的目标路径 // 必须是绝对路径（使用 Node.js 的 path 模块） filename: \"bundle.js\", // string // 「入口分块(entry chunk)」的文件名模板（出口分块？） publicPath: \"/assets/\", // string // 输出解析文件的目录，url 相对于 HTML 页面 library: \"MyLibrary\", // string, // 导出库(exported library)的名称 libraryTarget: \"umd\", // 通用模块定义 // 导出库(exported library)的类型 /* 高级输出配置 */ pathinfo: true, // boolean // 在生成代码时，引入相关的模块、导出、请求等有帮助的路径信息。 chunkFilename: \"[id].js\", chunkFilename: \"[chunkhash].js\", // 长效缓存(/guides/caching) // 「附加分块(additional chunk)」的文件名模板 jsonpFunction: \"myWebpackJsonp\", // string // 用于加载分块的 JSONP 函数名 sourceMapFilename: \"[file].map\", // string sourceMapFilename: \"sourcemaps/[file].map\", // string // 「source map 位置」的文件名模板 devtoolModuleFilenameTemplate: \"webpack:///[resource-path]\", // string // 「devtool 中模块」的文件名模板 devtoolFallbackModuleFilenameTemplate: \"webpack:///[resource-path]?[hash]\", // string // 「devtool 中模块」的文件名模板（用于冲突） umdNamedDefine: true, // boolean // 在 UMD 库中使用命名的 AMD 模块 crossOriginLoading: \"use-credentials\", // 枚举 crossOriginLoading: \"anonymous\", crossOriginLoading: false, // 指定运行时如何发出跨域请求问题 /* 专家级输出配置（自行承担风险） */ devtoolLineToLine: &#123; test: /\\.jsx$/ &#125;, // 为这些模块使用 1:1 映射 SourceMaps（快速） hotUpdateMainFilename: \"[hash].hot-update.json\", // string // 「HMR 清单」的文件名模板 hotUpdateChunkFilename: \"[id].[hash].hot-update.js\", // string // 「HMR 分块」的文件名模板 sourcePrefix: \"\\t\", // string // 包内前置式模块资源具有更好可读性 &#125;, module: &#123; // 关于模块配置 rules: [ // 模块规则（配置 loader、解析器等选项） &#123; test: /\\.jsx?$/, include: [ path.resolve(__dirname, \"app\") ], exclude: [ path.resolve(__dirname, \"app/demo-files\") ], // 这里是匹配条件，每个选项都接收一个正则表达式或字符串 // test 和 include 具有相同的作用，都是必须匹配选项 // exclude 是必不匹配选项（优先于 test 和 include） // 最佳实践： // - 只在 test 和 文件名匹配 中使用正则表达式 // - 在 include 和 exclude 中使用绝对路径数组 // - 尽量避免 exclude，更倾向于使用 include issuer: &#123; test, include, exclude &#125;, // issuer 条件（导入源） enforce: \"pre\", enforce: \"post\", // 标识应用这些规则，即使规则覆盖（高级选项） loader: \"babel-loader\", // 应该应用的 loader，它相对上下文解析 // 为了更清晰，`-loader` 后缀在 webpack 2 中不再是可选的 // 查看 webpack 1 升级指南。 options: &#123; presets: [\"es2015\"] &#125;, // loader 的可选项 &#125;, &#123; test: /\\.html$/, test: \"\\.html$\" use: [ // 应用多个 loader 和选项 \"htmllint-loader\", &#123; loader: \"html-loader\", options: &#123; /* ... */ &#125; &#125; ] &#125;, &#123; oneOf: [ /* rules */ ] &#125;, // 只使用这些嵌套规则之一 &#123; rules: [ /* rules */ ] &#125;, // 使用所有这些嵌套规则（合并可用条件） &#123; resource: &#123; and: [ /* 条件 */ ] &#125; &#125;, // 仅当所有条件都匹配时才匹配 &#123; resource: &#123; or: [ /* 条件 */ ] &#125; &#125;, &#123; resource: [ /* 条件 */ ] &#125;, // 任意条件匹配时匹配（默认为数组） &#123; resource: &#123; not: /* 条件 */ &#125; &#125; // 条件不匹配时匹配 ], /* 高级模块配置（点击展示） */ noParse: [ /special-library\\.js$/ ], // 不解析这里的模块 unknownContextRequest: \".\", unknownContextRecursive: true, unknownContextRegExp: /^\\.\\/.*$/, unknownContextCritical: true, exprContextRequest: \".\", exprContextRegExp: /^\\.\\/.*$/, exprContextRecursive: true, exprContextCritical: true, wrappedContextRegExp: /.*/, wrappedContextRecursive: true, wrappedContextCritical: false, // 指定动态请求的默认行为 &#125;, resolve: &#123; // 解析模块请求的选项 // （不适用于对 loader 解析） modules: [ \"node_modules\", path.resolve(__dirname, \"app\") ], // 用于查找模块的目录 extensions: [\".js\", \".json\", \".jsx\", \".css\"], // 使用的扩展名 alias: &#123; // 模块别名列表 \"module\": \"new-module\", // 起别名：\"module\" -&gt; \"new-module\" 和 \"module/path/file\" -&gt; \"new-module/path/file\" \"only-module$\": \"new-module\", // 起别名 \"only-module\" -&gt; \"new-module\"，但不匹配 \"only-module/path/file\" -&gt; \"new-module/path/file\" \"module\": path.resolve(__dirname, \"app/third/module.js\"), // 起别名 \"module\" -&gt; \"./app/third/module.js\" 和 \"module/file\" 会导致错误 // 模块别名相对于当前上下文导入 &#125;, /* 可供选择的别名语法（点击展示） */ alias: [ &#123; name: \"module\", // 旧的请求 alias: \"new-module\", // 新的请求 onlyModule: true // 如果为 true，只有 \"module\" 是别名 // 如果为 false，\"module/inner/path\" 也是别名 &#125; ], /* 高级解析选项（点击展示） */ symlinks: true, // 遵循符号链接(symlinks)到新位置 descriptionFiles: [\"package.json\"], // 从 package 描述中读取的文件 mainFields: [\"main\"], // 从描述文件中读取的属性 // 当请求文件夹时 aliasFields: [\"browser\"], // 从描述文件中读取的属性 // 以对此 package 的请求起别名 enforceExtension: false, // 如果为 true，请求必不包括扩展名 // 如果为 false，请求可以包括扩展名 moduleExtensions: [\"-module\"], enforceModuleExtension: false, // 类似 extensions/enforceExtension，但是用模块名替换文件 unsafeCache: true, unsafeCache: &#123;&#125;, // 为解析的请求启用缓存 // 这是不安全，因为文件夹结构可能会改动 // 但是性能改善是很大的 cachePredicate: (path, request) =&gt; true, // 用于选择缓存请求的谓词函数 plugins: [ // ... ] // 应用于解析器的附加插件 &#125;, performance: &#123; hints: \"warning\", // or \"error\" or false maxAssetSize: 200000, // 整数类型（以字节为单位） maxEntrypointSize: 400000, // 整数类型（以字节为单位） assetFilter: function(assetFilename) &#123; // 提供资源文件名的断言函数 return assetFilename.endsWith('.css') || assetFilename.endsWith('.js'); &#125; &#125;, devtool: \"source-map\", // // devtool: \"inline-source-map\", // 嵌入到源文件中 // devtool: \"eval-source-map\", // 将 SourceMap 嵌入到每个模块中 // devtool: \"hidden-source-map\", // SourceMap 不在源文件中引用 // devtool: \"cheap-source-map\", // 没有模块映射(module mappings)的 SourceMap 低级变体(cheap-variant) // devtool: \"cheap-module-source-map\", // 有模块映射(module mappings)的 SourceMap 低级变体 // devtool: \"eval\", // 没有模块映射，而是命名模块。以牺牲细节达到最快。 // 通过在浏览器调试工具(browser devtools)中添加元信息(meta info)增强调试 // 牺牲了构建速度的 `source-map' 是最详细的。 context: __dirname, // string（绝对路径！） // webpack 的主目录 // entry 和 module.rules.loader 选项 // 相对于此目录解析 target: \"web\", // 默认 // 包(bundle)应该运行的环境 // 更改 块加载行为(chunk loading behavior) 和 可用模块(available module) externals: [\"react\", /^@angular\\//], // 不要遵循/打包这些模块，而是在运行时从环境中请求他们 stats: \"errors-only\", // 精确控制要显示的 bundle 信息 devServer: &#123; proxy: &#123; // 代理URL到后端开发服务器 '/api': 'http://localhost:3000' auth: false //授权 changeOrigin: true //跨域 &#125;, contentBase: path.join(__dirname, 'public'), // boolean | string | array, 静态文件位置 compress: true, // 启用gzip压缩 historyApiFallback: true, // 提供重定向响应 404 -- 如果使用 hot: true, // 热加载 https: false, // 是否是https noInfo: true, // 只有错误并警告热重新加载 // ... &#125;, plugins: [ // ... ], // 附加插件列表 /* 高级配置（点击展示） */ resolveLoader: &#123; /* 等同于 resolve */ &#125; // 独立解析选项的 loader parallelism: 1, // number // 限制并行处理模块的数量 profile: true, // boolean // 捕获时机信息 bail: true, //boolean // 在第一个错误出错时抛出，而不是无视错误。 cache: false, // boolean // 禁用/启用缓存 watch: true, // boolean // 启用观察 watchOptions: &#123; aggregateTimeout: 1000, // in ms // 将多个更改聚合到单个重构建(rebuild) poll: true, poll: 500, // 间隔单位 ms // 启用轮询观察模式 // 必须用在不通知更改的文件系统中 // 即 nfs shares（译者注：Network FileSystem，最大的功能就是可以透過網路，讓不同的機器、不同的作業系統、可以彼此分享個別的檔案 ( share file )） &#125;, node: &#123; // 在非node环境下填充或模拟运行node环境 console: false, // boolean | \"mock\" global: true, // boolean | \"mock\" process: true, // boolean __filename: \"mock\", // boolean | \"mock\" __dirname: \"mock\", // boolean | \"mock\" Buffer: true, // boolean | \"mock\" setImmediate: true // boolean | \"mock\" | \"empty\" &#125;, recordsPath: path.resolve(__dirname, \"build/records.json\"), recordsInputPath: path.resolve(__dirname, \"build/records.json\"), recordsOutputPath: path.resolve(__dirname, \"build/records.json\"), // TODO&#125; Webpack 的工作流从 context 文件夹开始（框架内没有配置，那就默认为 ‘’）查找 entry 对应的文件(找到文件之后) 读取文件内容. 每当遇到 import (ES6) 或者 require() (Node) 依赖项时, 它会解析这些代码, 并且打包到最终构建里. 接着它会不断递归搜索实际需要的依赖项, 直到它到达了“树”的底部递归完所有依赖之后, Webpack 会将所有东西打包到 output.path 对应的目录, 并将 output.filename 的值作为最终的资源名 ([name] 表示使用 entry 项的 key)","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"在页面中获取图片的尺寸","slug":"在页面中获取图片的尺寸","date":"2018-05-14T10:13:46.000Z","updated":"2018-06-28T10:00:35.000Z","comments":true,"path":"2018/05/14/在页面中获取图片的尺寸/","link":"","permalink":"http://yoursite.com/2018/05/14/在页面中获取图片的尺寸/","excerpt":"","text":"在js中写了获取图片的高度，却发现高度都是0.这是因为js运行的时候，图片还没有加载好所以在获取图片高度的时候，要用window.onload在图片都加载好了之后获取就可以了。 1234window.onload = function () &#123; var imgHeight = $(\".bgImg\").height() console.log(imgHeight);&#125;","categories":[{"name":"bug汇总","slug":"bug汇总","permalink":"http://yoursite.com/categories/bug汇总/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"jquery监控浏览器大小变化","slug":"jquery监控浏览器大小变化","date":"2018-05-14T10:10:06.000Z","updated":"2018-05-14T10:13:13.000Z","comments":true,"path":"2018/05/14/jquery监控浏览器大小变化/","link":"","permalink":"http://yoursite.com/2018/05/14/jquery监控浏览器大小变化/","excerpt":"","text":"12345678910111213141516171819202122232425var screenWidth = window.screen.width;$(window).resize(function () &#123;//当浏览器大小变化时 if($(window).width()!== screenWidth)&#123; //history.go(0) &#125;&#125;);//监控浏览器旋转function orientationChange() &#123; switch (window.orientation) &#123; case 0: //history.go(0) break; case -90: //history.go(0) break; case 90: // history.go(0) break; case 180: //history.go(0) break; &#125;&#125;window.addEventListener('orientationchange', orientationChange);","categories":[{"name":"Demo练习","slug":"Demo练习","permalink":"http://yoursite.com/categories/Demo练习/"}],"tags":[{"name":"Jquery","slug":"Jquery","permalink":"http://yoursite.com/tags/Jquery/"}]},{"title":"设置overflow：hidden导致相邻行内元素向下偏移的问题","slug":"设置overflow：hidden导致相邻行内元素向下偏移的问题","date":"2018-05-14T07:18:34.000Z","updated":"2018-06-28T10:00:35.000Z","comments":true,"path":"2018/05/14/设置overflow：hidden导致相邻行内元素向下偏移的问题/","link":"","permalink":"http://yoursite.com/2018/05/14/设置overflow：hidden导致相邻行内元素向下偏移的问题/","excerpt":"","text":"123456&lt;!-- html --&gt;&lt;div&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt;&lt;/div&gt; 1234567/* CSS */div span&#123; display:inline-block;&#125;div span:nth(0)&#123; overflow:hidden;&#125; 这样设置之后，后面的两个span会向下偏移一定距离实际上就是inline-block元素的默认baseline和其下外边沿的距离。常用的解决方法是为上述inline-block元素添加vertical-align: bottom。","categories":[{"name":"bug汇总","slug":"bug汇总","permalink":"http://yoursite.com/categories/bug汇总/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]},{"title":"如何去掉两个span间的间距","slug":"如何去掉两个span间的间距","date":"2018-05-14T07:13:21.000Z","updated":"2018-06-28T10:00:35.000Z","comments":true,"path":"2018/05/14/如何去掉两个span间的间距/","link":"","permalink":"http://yoursite.com/2018/05/14/如何去掉两个span间的间距/","excerpt":"","text":"12345&lt;!-- html --&gt;&lt;div&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;&lt;/div&gt; 1234567/* CSS */div&#123; font-size：10px；&#125;span&#123; display:inline-block;&#125; 设置成块级元素的span，会因为父元素设置字体的大小，导致两个span外的空格会占有空隙。所以将父元素的font-size：0；然后再单独设置span的字体大小就可以解决这个问题。","categories":[{"name":"bug汇总","slug":"bug汇总","permalink":"http://yoursite.com/categories/bug汇总/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]},{"title":"jquery对追加事件的绑定","slug":"jquery对追加事件的绑定","date":"2018-05-14T07:01:10.000Z","updated":"2018-05-14T09:59:24.000Z","comments":true,"path":"2018/05/14/jquery对追加事件的绑定/","link":"","permalink":"http://yoursite.com/2018/05/14/jquery对追加事件的绑定/","excerpt":"","text":"写项目的时候又用到了jquery，突然发现，对于用jquery追加的元素，on方法绑定不能用。 发现：on要原始存在才绑定上，否则要用delegate来动态绑定1$(document).delegate('selecter','click', function () &#123; alert(this.innerHTML) &#125;);","categories":[{"name":"bug汇总","slug":"bug汇总","permalink":"http://yoursite.com/categories/bug汇总/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"},{"name":"Jquery","slug":"Jquery","permalink":"http://yoursite.com/tags/Jquery/"}]},{"title":"CSS中position属性总结笔记","slug":"CSS中position属性总结笔记","date":"2018-05-14T06:55:43.000Z","updated":"2018-06-28T10:00:35.000Z","comments":true,"path":"2018/05/14/CSS中position属性总结笔记/","link":"","permalink":"http://yoursite.com/2018/05/14/CSS中position属性总结笔记/","excerpt":"","text":"写了好多的position，一直在用它们字面的意思，最近项目写到的position的问题，竟然又出问题了。。总结一下： 1. positon:static; 静态定位（默认的 ） 这个是默认的，写不写都会是这个定位，所有的标准文档流里面的元素都是静态定位。 2. positon:relative; 相对定位 相对定位不会使有该属性的元素脱离标准文档流 相对定位会在页面原始的位置占据位置，而元素的位置会根据原始的位置进行偏移。 相对定位的作用一般是用来给子元素的绝对定位提供参考的。 3. position:absolute; 绝对定位 绝对定位会使有该属性的元素脱离标准文档流 特点： 如果这个元素没有父元素，top、left、right、bottom就相对于浏览器窗口来定位 如果绝对定位的元素有父元素，且父元素没有相对定位，top、left、right、bottom相对于浏览窗口来定位 如果绝对定位的元素有父元素，且父元素有定位（非static），top、left、right、bottom以父元素为基础偏移 绝对定位之后的元素在页面上不会占据位置 4. position:fixed; 固定定位 固定定位会使有该属性的元素脱离标准文档流 位置不变，适用于广告或者飘窗 总结：写页面时，用到最多是绝对定位与相对定位一起使用，较多的是子元素使用绝对定位，父元素使用相对定位","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"变量的作用域和变量提升","slug":"变量的作用域和变量提升","date":"2018-05-14T06:52:10.000Z","updated":"2018-06-28T09:53:02.000Z","comments":true,"path":"2018/05/14/变量的作用域和变量提升/","link":"","permalink":"http://yoursite.com/2018/05/14/变量的作用域和变量提升/","excerpt":"","text":"某家面试的时候面试题，面试官小姐姐给出了一道题：123456789var a = 100;function test()&#123; console.log(a); a = 10; console.log(a); console.log(this.a); var a;&#125;test(); 问我这三个会打印出来的值是什么？ 研究一下这个变量的作用域和变量提升： 一、作用域： 一个变量的作用域（scope）是程序源代码中定义这个变量的区域。全局变量拥有全局作用域，在javaScript代码中任何地方都有定义的。然而在函数内声明的变量只是在函数内部有定义，他们是局部变量，作用域也只是在局部。 在函数体内，局部变量的优先级要高于全局变量。如果在函数体内重新声明一个与局部变量重名的变量，局部变量就会覆盖全局变量的值。来看个例子： 123456789101112var num=\"100\";function scope()&#123; var num=\"10\"; function innerScope()&#123; var num = \"1\"; console.log(scope);//输出：1 &#125; innerScope(); console.log(num);//输出：10&#125;scope();console.log(num);//输出：100 这个例子会打印三个数，分别是1，10，100；局部变量的作用域仅仅在函数内部，出了函数体之后，局部变量就会被销毁。在innerScope()函数中，虽然又声明了一个num，但是innerScope()中的num是局部变量，只是与全局变量的名字相同，并不是全局变量，所以，虽然在该函数中把num赋值为1，但这仅仅是一个与全局变量名称相同的一个变量而已，并没有改变全局变量的值。 再来看一个例子: 123456789101112var num=\"100\";function scope()&#123; var num=\"10\"; function innerScope()&#123; num = \"1\"; console.log(scope);//输出：1 &#125; innerScope(); console.log(num);//输出：1&#125;scope();console.log(num);//输出：100 上面这部分代码中，在innerScope()函数中，我们并没有用var来声明num，所以，在这里的num的作用域就被提升了，即我们将scope中的num的值重置了，所以在输出的时候输出的结果为嵌套作用域内的局部变量。 二、变量提升 在Javascript中，函数及变量的声明都将被提升到函数的最顶部。在js中，变量的声明会被解析器悄悄的提升到方法体的最顶部，但是需要注意的是，提升的仅仅是变量的声明，变量的赋值并不会被提升，我们需要注意的是，函数的声明与变量的声明是不一样的。函数的函数体也会被一起提升。函数表达式和变量表达式只是其声明被提升，函数声明是函数的声明和实现都被提升。 所以上面那个题就很好理解了。我们再来看一下这个题：123456789var a = 100;function test()&#123; console.log(a); a = 10; console.log(a); console.log(this.a); var a;&#125;test(); 因为变量提升，a提升到最前面，声明未赋值，所以第一个就会打印undefined； 第二个在a声明之后，而且a赋值为10，所以第二个打印出来10； 第三个，因为test()是在window下调用的；this指的是test()调用的作用域，所以第三个打印100； 看一个函数提升的例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;script language=\"javascript\" type=\"text/javascript\"&gt; //在全局对象中声明两个全局函数,反模式 function foo() &#123; alert(\"global foo\"); &#125; function bar() &#123; alert(\"global bar\"); &#125; //定义全局变量 var v = \"global var\"; function hoistMe() &#123; alert(typeof foo); //function alert(typeof bar); //undefined alert(v); //undefined //为什么bar函数和变量v是未定义而不是全局变量中定义的相应的函数变量呢？ //因为函数里面定义了同名的函数和变量，无论在函数的任何位置定义这些函数和 //和变量，它们都将被提升到函数的最顶部。 foo(); //local foo bar(); //报错，TypeError \"bar is not a function\" //函数声明，变量foo以及其实现被提升到hoistMe函数顶部 function foo() &#123; alert(\"local foo\"); &#125; //函数表达式,仅变量bar被提升到函数顶部，实现没有被提升 var bar = function() &#123; alert(\"local bar\"); &#125;; //定义局部变量 var v = \"local\"; &#125; (function() &#123; hoistMe(); &#125;)(); //函数表达式和变量表达式只是其声明被提升，函数声明是函数的声明和实现都被提升。 /**由于函数提升的效果，hoistMe方法相当于 function hoistMe() &#123; //函数声明，变量foo以及其实现被提升到hoistMe函数顶部 function foo() &#123; alert(\"local foo\"); &#125; //函数表达式,仅变量bar被提升到函数顶部，实现没有被提升(同变量提升) var bar = undefined; //变量声明被提升 var v = undefined; alert(typeof foo); //function alert(typeof bar); //undefined alert(v); //undefined foo(); //local foo bar(); //报错，缺少对象 bar = function() &#123; alert(\"local bar\"); &#125;; v = \"local\"; &#125; */ &lt;/script&gt;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"2018 书单","slug":"2018-书单","date":"2018-05-14T06:44:03.000Z","updated":"2018-06-28T10:00:35.000Z","comments":true,"path":"2018/05/14/2018-书单/","link":"","permalink":"http://yoursite.com/2018/05/14/2018-书单/","excerpt":"","text":"☐ 《原则》瑞·达利欧 著 中信出版社✔ 《爆裂》伊藤穰一 杰夫·豪 著 中信出版社☐ 《基因传》悉达多•穆克吉 著 中信出版社☐ 《未来简史》尤瓦尔·赫拉利 著 中信出版社☐ 《人类简史》尤瓦尔·赫拉利 著 中信出版社✔ 《你的第一本哲学书》托马斯·内格尔 著 中信出版社☐ 《自私的基因》理查德·道金斯 著 中信出版社☐ 《不会被机器替代的人》杰夫·科尔文 著 中信出版社☐ 《好好说话》马薇薇、黄执中、周玄毅等 著 中信出版社☐ 《跃迁》古典 著 中信出版社☐ 《智能时代》吴军 著 中信出版社☐ 《细节：如何轻松影响他人》史蒂夫·马丁 诺瓦·戈尔茨坦 等 著 中信出版社☐ 《向前一步》谢丽尔·桑德伯✔ 《人人都是产品经理》☐ 《穷爸爸富爸爸》☐ 《中国经济2018》","categories":[{"name":"浮生小记","slug":"浮生小记","permalink":"http://yoursite.com/categories/浮生小记/"}],"tags":[]},{"title":"redux-devtools学习理解","slug":"redux-devtools学习理解","date":"2018-05-11T08:52:11.000Z","updated":"2018-05-14T09:59:24.000Z","comments":true,"path":"2018/05/11/redux-devtools学习理解/","link":"","permalink":"http://yoursite.com/2018/05/11/redux-devtools学习理解/","excerpt":"","text":"redux-devtoolsA live-editing time travel environment for Redux.redux-devtools是一个有趣而又高效的redux开发工具，通过redux-devtools，我们可以清晰的看到当前 store 仓库中的 state 是怎么样的，在可视化工具的左边，我们还可以看到触发的action的变化。这样，使得我们开发过程中很方便地进行调试。 安装123npm install --save-dev redux-devtoolsnpm install --save-dev redux-devtools-log-monitornpm install --save-dev redux-devtools-dock-monitor 使用 通过createDevTools来创建DevTools组件 1234567891011121314151617import React from 'react'//从redux-devtools中引入createDevToolslet DevTools;if (process.env.NODE_ENV === 'development') &#123; const &#123;createDevTools&#125; = require('redux-devtools'); const LogMonitor = require('redux-devtools-log-monitor').default; const DockMonitor = require('redux-devtools-dock-monitor').default; DevTools = createDevTools( &lt;DockMonitor toggleVisibilityKey=\"ctrl-h\" changePositionKey=\"ctrl-w\" defaultIsVisible=&#123;false&#125; defaultPosition=\"right\"&gt; &lt;LogMonitor theme=\"tomorrow\" preserveScrollTop=&#123;false&#125;/&gt; &lt;/DockMonitor&gt; );&#125; 采用DevTools.instrument()通过redux的compose来扩展store 1234567891011121314151617181920212223export function configureStore(history, reducers, initialState) &#123; // Installs hooks that always keep react-router and redux store in sync const middleware = [thunk, routerMiddleware(history)]; if (process.env.NODE_ENV === 'development') &#123; //开发环境 const &#123;createLogger&#125; = require('redux-logger'); middleware.push(createLogger()); &#125; let devTools = []; if (DevTools &amp;&amp; typeof document !== 'undefined') &#123; devTools = [DevTools.instrument()] &#125; const store = createStore( reducers, initialState, compose( applyMiddleware(...middleware), ...devTools )); return store;&#125; 用createDevTools()创建的DevTools组件有个特殊的静态方法instrument(),它返回一个store的增强器,在开发中你需要在compose中使用。注意：DevTools.instrument()要放在applyMiddleware后，因为你的applyMiddleware可以存在异步行为，为了确保所有的actions显示在store中，所以要放在后面 Render &lt;DevTools /&gt; 1234567891011const store = configureStore();render( &lt;Provider store=&#123;store&#125;&gt; &lt;div&gt; &lt;Router /&gt; &lt;DevTools /&gt; &lt;/div&gt; &lt;/Provider&gt; document.getElementById('app'));","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[{"name":"redux","slug":"redux","permalink":"http://yoursite.com/tags/redux/"}]},{"title":"redux源码学习--applyMiddleware","slug":"redux源码学习-applyMiddleware","date":"2018-05-11T08:03:07.000Z","updated":"2018-06-28T10:00:35.000Z","comments":true,"path":"2018/05/11/redux源码学习-applyMiddleware/","link":"","permalink":"http://yoursite.com/2018/05/11/redux源码学习-applyMiddleware/","excerpt":"","text":"applyMiddleware理解 中间件的本质是作为enhancer而存在的。它是通过createStore方法传递到redux的内部中的,中间件模块是一个高阶函数下面是redux中间件的基本格式：1const reduxMiddleware = (&#123;dispatch, getState&#125;[简化的store]) =&gt; (next[上一个中间件的dispatch方法]) =&gt; (action[实际派发的action对象]) =&gt; &#123;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950export default function applyMiddleware(...middlewares) &#123; // middlewares就是我们传递给applyMiddlewarez函数的一系列中间件函数 return (createStore) =&gt; (...args) =&gt; &#123; // createStore就是redux用于创建store的方法,args === [reducers, preloadedState]。下面这句话就是在中间件的内部，使用我们传递的参数创建一个store对象 // 注：这一块没有传递enhancer,所以返回的就是我们经常使用的store对象 const store = createStore(...args) // 获取store对象的dispatch方法 let dispatch = () =&gt; &#123; throw new Error( `Dispatching while constructing your middleware is not allowed. ` + `Other middleware would not be applied to this dispatch.` ) &#125; // 传递给中间件的第一层的函数的参数， const middlewareAPI = &#123; getState: store.getState, // 重写了dispatch方法，其实就是store.dispatch(...args) dispatch: (...args) =&gt; dispatch(...args) &#125; /** * 着重给大家详细的解释一下这一块 * 假设我们给applyMiddleware函数传递的中间件是 * applyMiddleware( * f1 =&gt; g1 =&gt; h1(...arg) =&gt; &#123;&#125;, * f2 =&gt; g2 =&gt; h2(...arg) =&gt; &#123;&#125; * ) * 运行下面的这行代码之后，chain中保存的内容是 * chain = [g1 =&gt; h1(...arg) =&gt; &#123;&#125;, g2 =&gt; h2(...arg) =&gt; &#123;&#125;] */ const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)) /** * 当我们把chain传入到 compose中后，根据我们对compose的分析， * compose(...chain)(store.dispatch)的结果就是: * g1(h2(...arg)) =&gt; h1(...arg) * * 也就是说，按照上面的这个形式，下面的dispatch和h1函数是一样的，所以，h1的参数，就是我们需要派发的action，当我们调用dispatch的时候，其实就相当于调用h1(action)，而在h1的内部，这个action是由g1的参数 * 也就是h2进行派发的，所以这个时候action就传递到了h2的内部，而h2的参数是由g2的参数，也就是实际传入的store.dispatch进行派发的，就这样层层传入，层层输出，就形成了我们强大的中间件机制。 */ dispatch = compose(...chain)(store.dispatch) // 返回的也是一个store对象 return &#123; ...store, // 这个dispatch其实就是，各个中间件的最底层(第三层)的哪个函数组成的圆环函数构成的 dispatch &#125; &#125;&#125;","categories":[{"name":"redux源码学习","slug":"redux源码学习","permalink":"http://yoursite.com/categories/redux源码学习/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"},{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"redux","slug":"redux","permalink":"http://yoursite.com/tags/redux/"}]},{"title":"redux源码学习--bindActionCreators","slug":"redux源码学习-bindActionCreators","date":"2018-05-11T07:24:40.000Z","updated":"2018-06-28T10:00:35.000Z","comments":true,"path":"2018/05/11/redux源码学习-bindActionCreators/","link":"","permalink":"http://yoursite.com/2018/05/11/redux源码学习-bindActionCreators/","excerpt":"","text":"bindActionCreators 以前这样触发一个action，即dispatch(actionCreator(args))，现在变成这样触发一个action: boundActionCreator(args)。目的很单纯，简化某个action的调用。 Redux中的bindActionCreators，是通过dispatch将action包裹起来，这样可以通过bindActionCreators创建的方法，直接调用dispatch(action)(隐式调用）。一般情况下，我们可以通过Provider将store通过React的connext属性向下传递，bindActionCreators的唯一用处就是需要传递action creater到子组件，并且改子组件并没有接收到父组件上传递的store和dispatch。 实现上面那个效果，仅需一行代码，也就是源码文件中的第一个函数：1234567// 返回一个函数fn：函数目的是将actionCreator绑定到dispatch上，不用麻烦调用dispatch(actionCreator(args))了// 返回一个函数fn，该函数fn用dispatch来调用，其参数是actionCreator执行结果，function bindActionCreator(actionCreator, dispatch) &#123; return function() &#123; return dispatch(actionCreator.apply(this, arguments)) &#125;&#125; 参数理解actionCreators: actionCreators是一个对象，它的值是actions creator函数。也可以传递一个函数。dispatch: 等同于store中的store.dispatch，用于组合action 返回值boundActionCreators: 返回一个boundActionCreators对象 1234567891011121314151617181920212223242526272829export default function bindActionCreators(actionCreators, dispatch) &#123; //如果actionCreators是一个函数，则说明只有一个actionCreator，那直接调用bindActionCreator就行了 if (typeof actionCreators === 'function') &#123; return bindActionCreator(actionCreators, dispatch) &#125; //如果是actionCreator是对象，或者是null的话，报错喽 if (typeof actionCreators !== 'object' || actionCreators === null) &#123; throw new Error( `bindActionCreators expected an object or a function, instead received $&#123;actionCreators === null ? 'null' : typeof actionCreators&#125;. ` + `Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?` ) &#125; //保持actionCreators里面原来的key，只是把key对应的value都转成了boundActionCreator const keys = Object.keys(actionCreators) const boundActionCreators = &#123;&#125; for (let i = 0; i &lt; keys.length; i++) &#123; const key = keys[i] const actionCreator = actionCreators[key] //只对value是函数的key进行转换，其他的都过滤掉了 if (typeof actionCreator === 'function') &#123; boundActionCreators[key] = bindActionCreator(actionCreator, dispatch) &#125; &#125; //返回绑定之后的对象 return boundActionCreators&#125; 总结 bindActionCreators函数把actionCreators这个对象里面包含的每一个actionCreator按照原来的key的方式全部都封装了一遍。","categories":[{"name":"redux源码学习","slug":"redux源码学习","permalink":"http://yoursite.com/categories/redux源码学习/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"},{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"redux","slug":"redux","permalink":"http://yoursite.com/tags/redux/"}]},{"title":"redux源码学习--combineReducers","slug":"redux源码学习—combineReducers","date":"2018-05-11T06:16:47.000Z","updated":"2018-06-28T10:00:35.000Z","comments":true,"path":"2018/05/11/redux源码学习—combineReducers/","link":"","permalink":"http://yoursite.com/2018/05/11/redux源码学习—combineReducers/","excerpt":"","text":"combineReducers 理解 combineReducers.js文件对外暴露了一个函数combineReducers，combineReducer函数是redux的一个辅助性的函数，用于拆分createStore里面的第一个参数：reducer函数。combineReducer函数的返回值是一个函数，该函数是组合之后的一个标准的reducer函数。combineReducers将多个值不同的reducer对象转换为单个reducer。它将调用每个子reducer，并将它们的结果收集到单个状态对象中，该对象的键对应于传递的reducer函数的键。 参数理解{reducers}：一个对象，它的值对应于需要被组合成一个的不同的reducer函数。获得它的一种简便方法是使用ES6import * as reducers语法。对于任何的actions，reducer可能永远不会返回undefined。相反，如果传递给它们的state是undefined，则返回初始state，以及任何未识别action的当前state。1234let reducers = &#123; usersId: function getUsersIdReducer()&#123;&#125;, userName: function getUserNameReducer()&#123;&#125;&#125; 参数处理 从传入的参数里面提取出合法的reducers（reducers的每一个key对应的value值是函数，才是合法的子reducer），赋值给新的局部变量：finalReducers 12345678910111213141516const reducerKeys = Object.keys(reducers)//定义一个局部变量 finalReducersconst finalReducers = &#123;&#125;for (let i = 0; i &lt; reducerKeys.length; i++) &#123; const key = reducerKeys[i] if (process.env.NODE_ENV !== 'production') &#123; if (typeof reducers[key] === 'undefined') &#123; warning(`No reducer provided for key \"$&#123;key&#125;\"`) &#125; &#125; //过滤出reducers对应的value值是function的key，将其放入finalReducers对象 if (typeof reducers[key] === 'function') &#123; finalReducers[key] = reducers[key] &#125;&#125; 校验finalReducers, 判断其每一个子reducer是否能返回正常的子state 1234567891011121314//取出过滤出来的有效的keys列表const finalReducerKeys = Object.keys(finalReducers)let unexpectedKeyCacheif (process.env.NODE_ENV !== 'production') &#123; unexpectedKeyCache = &#123;&#125;&#125;let shapeAssertionErrortry &#123; assertReducerShape(finalReducers)&#125; catch (e) &#123; shapeAssertionError = e&#125; 调用assertReducerShape函数： 123456789101112131415161718192021222324252627282930313233343536//确认reducer是否是合法的reducer，即返回的state是不是undefined，如果是undefined，则是非法reducerfunction assertReducerShape(reducers) &#123; Object.keys(reducers).forEach(key =&gt; &#123; const reducer = reducers[key] const initialState = reducer(undefined, &#123;type: ActionTypes.INIT&#125;) //如果初始state是undefined，则抛出错误 if (typeof initialState === 'undefined') &#123; throw new Error( `Reducer \"$&#123;key&#125;\" returned undefined during initialization. ` + `If the state passed to the reducer is undefined, you must ` + `explicitly return the initial state. The initial state may ` + `not be undefined. If you don't want to set a value for this reducer, ` + `you can use null instead of undefined.` ) &#125; //如果reducer是undefined，抛出错误 if ( typeof reducer(undefined, &#123; type: ActionTypes.PROBE_UNKNOWN_ACTION() &#125;) === 'undefined' ) &#123; throw new Error( `Reducer \"$&#123;key&#125;\" returned undefined when probed with a random type. ` + `Don't try to handle $&#123; ActionTypes.INIT &#125; or other actions in \"redux/*\" ` + `namespace. They are considered private. Instead, you must return the ` + `current state for any unknown actions, unless it is undefined, ` + `in which case you must return the initial state, regardless of the ` + `action type. The initial state may not be undefined, but can be null.` ) &#125; &#125;)&#125; 返回值combineReducers函数返回一个combination函数，combination是一个标准的reducer函数，有初始化的state参数，和一个携带了actionType和数据的action对象。12345678910111213141516171819202122232425262728293031323334353637383940return function combination(state = &#123;&#125;, action) &#123; //如果有非法的reducer，就直接报错 if (shapeAssertionError) &#123; throw shapeAssertionError &#125; if (process.env.NODE_ENV !== 'production') &#123; const warningMessage = getUnexpectedStateShapeWarningMessage( state, finalReducers, action, unexpectedKeyCache ) if (warningMessage) &#123; warning(warningMessage) &#125; &#125; let hasChanged = false //定义新的nextState const nextState = &#123;&#125; // 1，遍历reducers对象中的有效key， // 2，执行该key对应的value函数，即子reducer函数，并得到对应的state对象，即子state // 3，将新的子state挂到新的nextState对象上，key不变 for (let i = 0; i &lt; finalReducerKeys.length; i++) &#123; const key = finalReducerKeys[i] const reducer = finalReducers[key] const previousStateForKey = state[key] const nextStateForKey = reducer(previousStateForKey, action) if (typeof nextStateForKey === 'undefined') &#123; const errorMessage = getUndefinedStateErrorMessage(key, action) throw new Error(errorMessage) &#125; nextState[key] = nextStateForKey //如果hasChanged为true，那就是true了 后面的判断是，只要有一次nextStateForKey!== previousStateForKey不同，就说明整个state不同 hasChanged = hasChanged || nextStateForKey !== previousStateForKey &#125; //如果state发生变化了，直接返回新的nextState，否则，还是返回旧的state return hasChanged ? nextState : state&#125; 总结 combineReducers 辅助函数的作用是，把一个由多个不同 reducer 函数作为 value 的 object，合并成一个最终的 reducer 函数，然后就可以对这个 reducer 调用 createStore。 合并后的 reducer 可以调用各个子 reducer，并把它们的结果合并成一个 state 对象。state 对象的结构由传入的多个 reducer 的 key 决定。 每个传入 combineReducers 的 reducer 都需满足以下规则： 所有未匹配到的 action，必须把它接收到的第一个参数也就是那个 state 原封不动返回。 永远不能返回 undefined。当过早 return 时非常容易犯这个错误，为了避免错误扩散，遇到这种情况时 combineReducers 会抛异常。 如果传入的 state 就是 undefined，一定要返回对应 reducer 的初始 state。根据上一条规则，初始 state 禁止使用 undefined。使用 ES6 的默认参数值语法来设置初始 state 很容易，但你也可以手动检查第一个参数是否为 undefined。","categories":[{"name":"redux源码学习","slug":"redux源码学习","permalink":"http://yoursite.com/categories/redux源码学习/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"},{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"redux","slug":"redux","permalink":"http://yoursite.com/tags/redux/"}]},{"title":"redux源码学习--compose","slug":"redux源码学习-compose","date":"2018-05-11T05:48:56.000Z","updated":"2018-06-28T10:00:35.000Z","comments":true,"path":"2018/05/11/redux源码学习-compose/","link":"","permalink":"http://yoursite.com/2018/05/11/redux源码学习-compose/","excerpt":"","text":"composecompose 是一个从右向左编写单参数组成的函数。最右边的函数可以接受多个参数，因为它提供了签名由此产生的复合函数。 参数理解{...funcs}需要合成的多个函数。每个函数都接收一个函数作为参数，然后返回一个函数。 返回值(Function) 从右到左把接收到的函数合成后的最终函数。 代码理解1234567891011export default function compose(...funcs) &#123; if (funcs.length === 0) &#123; return arg =&gt; arg &#125; if (funcs.length === 1) &#123; return funcs[0] &#125; //对参数进行一个累加，就是依次以右边的参数作为左边方法的参数累加到最左边 return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))&#125; 总结compose 主要用于 applyMiddleware / createStore enhancer.compose 做的只是让你不使用深度右括号的情况下来写深度嵌套的函数compose的运行结果是一个函数，调用这个函数所传递的参数将会作为compose最后一个参数的参数，从而由内向外，逐步调用。","categories":[{"name":"redux源码学习","slug":"redux源码学习","permalink":"http://yoursite.com/categories/redux源码学习/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"},{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"redux","slug":"redux","permalink":"http://yoursite.com/tags/redux/"}]},{"title":"immutable.js 学习","slug":"immutable-js-学习","date":"2018-05-11T05:37:21.000Z","updated":"2018-06-28T10:00:35.000Z","comments":true,"path":"2018/05/11/immutable-js-学习/","link":"","permalink":"http://yoursite.com/2018/05/11/immutable-js-学习/","excerpt":"","text":"JavaScript 中的对象一般是可变的，因为Javascript为了节省内存，都是使用引用赋值，生成一个新对象如果简单的引用了原始对象，那对新对象作出的改变，也将影响到原始对象。平时简单的应用还不会特别明显，但是如果在复杂的应用中，对象的改变就会引起比较复杂的问题。往往都会使用deepCopy来解决这个问题，但是deepCopy往往会对整个对象的树进行拷贝，也会造成 CPU 和内存的浪费。一、什么是immutable data？Immutable Data 就是被创建之后不能给改变数据。Immutable 实现的原理是 Persistent Data Structure（持久化数据结构），新数据通过旧的数据创建，需要使旧数据依旧可用而且不能被改变。Immutable的这种实现原理，也避免了deepCopy复制所有节点带来的性能损耗。Immutable的实现原理见下图： 二、Immutable 优点 Immutable 降低了 Mutable 带来的复杂度 节省内存 Undo/Redo，Copy/Paste，甚至时间旅行这些功能做起来小菜一碟 并发安全 拥抱函数式编程 三、Immutable 缺点： 需要学习新的 API 增加了资源文件大小 容易与原生对象混淆 四、Immutable的数据类型Immutable 的几种数据类型1.List: 有序索引集，类似JavaScript中的Array。2.Map: 无序索引集，类似JavaScript中的Object。3.OrderedMap: 有序的Map，根据数据的set()进行排序。4.Set: 没有重复值的集合。5.OrderedSet: 有序的Set，根据数据的add进行排序。6.Stack: 有序集合，支持使用unshift（）和shift（）添加和删除。7.Range(): 返回一个Seq.Indexed类型的集合，这个方法有三个参数，start表示开始值，默认值为0，end表示结束值，默认为无穷大，step代表每次增大的数值，默认为1.如果start = end,则返回空集合。8.Repeat(): 返回一个vSeq.Indexe类型的集合，这个方法有两个参数，value代表需要重复的值，times代表要重复的次数，默认为无穷大。9.Record: 一个用于生成Record实例的类。类似于JavaScript的Object，但是只接收特定字符串为key，具有默认值。10.Seq: 序列，但是可能不能由具体的数据结构支持。11.Collection: 是构建所有数据结构的基类，不可以直接构建。 用的最多就是List和Map，所以在这里主要介绍这两种数据类型的API。 五、常用的API1.fromJS() 将一个js数据转换为Immutable类型的数据。用法：fromJS(value, converter)简介：value是要转变的数据，converter是要做的操作。第二个参数可不填，默认情况会将数组准换为List类型，将对象转换为Map类型，其余不做操作。 1234const obj = Immutable.fromJS(&#123;a:'123',b:'234'&#125;,function (key, value, path) &#123; console.log(key, value, path) return isIndexed(value) ? value.toList() : value.toOrderedMap())&#125;) 2.toJS()作用：将一个Immutable数据转换为JS类型的数据。用法：value.toJS() 3.is()对两个对象进行比较。用法：is(map1,map2)简介：和js中对象的比较不同，在js中比较两个对象比较的是地址，但是在Immutable中比较的是这个对象hashCode和valueOf，只要两个对象的hashCode相等，值就是相同的，避免了深度遍历，提高了性能。 123456import &#123; Map, is &#125; from 'immutable'const map1 = Map(&#123; a: 1, b: 1, c: 1 &#125;)const map2 = Map(&#123; a: 1, b: 1, c: 1 &#125;)map1 === map2 //falseObject.is(map1, map2) // falseis(map1, map2) // true 4.List 和 Map创建List() 和 Map() 作用：用来创建一个新的List/Map对象 用法: 12345678910//ListList(): List&lt;any&gt;List&lt;T&gt;(): List&lt;T&gt;//MapMap(): Map&lt;any&gt;Map&lt;T&gt;(): Map&lt;T&gt;List.of() 和 Map.of() 作用：创建一个新的包含value的List/Map对象用法：123List.of&lt;T&gt;(...values: Array&lt;T&gt;): List&lt;T&gt;Map.of&lt;T&gt;(...values: Object&lt;T&gt;): Map&lt;T&gt; 判断 1List.isList() 和 Map.isMap() 作用：判断一个数据结构是不是List/Map类型用法：123List.isList(maybeList: any): booleanMap.isMap(maybeMap: any): boolean 长度size 作用：获取List/Map的长度 数据读取get() 、 getIn() 作用：获取数据结构中的数据 has() 、 hasIn() 作用:判断是否存在某一个key 用法：1234Immutable.fromJS([1,2,3,&#123;a:4,b:5&#125;]).has('0'); //trueImmutable.fromJS([1,2,3,&#123;a:4,b:5&#125;]).has('0'); //trueImmutable.fromJS([1,2,3,&#123;a:4,b:5&#125;]).hasIn([3,'b']) //trueincludes() 作用：判断是否存在某一个value 用法： 123456Immutable.fromJS([1,2,3,&#123;a:4,b:5&#125;]).includes(2); //trueImmutable.fromJS([1,2,3,&#123;a:4,b:5&#125;]).includes('2'); //false 不包含字符2Immutable.fromJS([1,2,3,&#123;a:4,b:5&#125;]).includes(5); //false Immutable.fromJS([1,2,3,&#123;a:4,b:5&#125;]).includes(&#123;a:4,b:5&#125;) //falseImmutable.fromJS([1,2,3,&#123;a:4,b:5&#125;]).includes(Immutable.fromJS(&#123;a:4,b:5&#125;)) //truefirst() 、 last() 作用：用来获取第一个元素或者最后一个元素，若没有则返回undefined代码： 12345Immutable.fromJS([1,2,3,&#123;a:4,b:5&#125;]).first()//1Immutable.fromJS([1,2,3,&#123;a:4,b:5&#125;]).last()//&#123;a:4,b:5&#125;Immutable.fromJS(&#123;a:1,b:2,c:&#123;d:3,e:4&#125;&#125;).first() //1Immutable.fromJS(&#123;a:1,b:2,c:&#123;d:3,e:4&#125;&#125;).first() //&#123;d:3,e:4&#125; 数据修改注：这里对于数据的修改，是对原数据进行操作后的值赋值给一个新的数据，并不会对原数据进行修改，因为Immutable是不可变的数据类型。 设置 set() 作用：设置第一层key、index的值 用法： 123set(index: number, value: T): List&lt;T&gt;set(key: K, value: V): thisList在使用的时候，将index为number值设置为value。Map在使用的时候，将key的值设置为value。 在List中使用时，若传入的number为负数，则将index为size+index的值设置为value，例，若传入-1，则将size-1的值设为value。若传入的number的值超过了List的长度，则将List自动补全为传入的number的值，将number设置为value，其余用undefined补全。注：跟js中不同，List中不存在空位，[,,,],List中若没有值，则为undefined。 代码实现：12345678910111213141516171819202122232425//////Listconst originalList = List([ 0 ]);// List [ 0 ]originalList.set(1, 1);// List [ 0, 1 ]originalList.set(0, 'overwritten');// List [ \"overwritten\" ]originalList.set(2, 2);// List [ 0, undefined, 2 ]List().set(50000, 'value').size;// 50001//////Mapconst &#123; Map &#125; = require('immutable')const originalMap = Map()const newerMap = originalMap.set('key', 'value')const newestMap = newerMap.set('key', 'newer value')originalMap// Map &#123;&#125;newerMap// Map &#123; \"key\": \"value\" &#125;newestMap// Map &#123; \"key\": \"newer value\" &#125; setIn()作用：设置深层结构中某属性的值用法：12setIn(keyPath: Iterable&lt;any&gt;, value: any): this用法与set()一样，只是第一个参数是一个数组，代表要设置的属性所在的位置 删除 delete 作用：用来删除第一层结构中的属性 用法：123delete(index: number): List&lt;T&gt; //Listdelete(key: K): this //MapdeleteIn() 用来删除深层数据，用法参考setIndeleteAll() (Map独有，List没有)作用：用来删除Map中的多个key用法：1deleteAll(keys: Iterable&lt;K&gt;): this 代码示例：123const names = Map(&#123; a: \"Aaron\", b: \"Barry\", c: \"Connor\" &#125;)names.deleteAll([ 'a', 'c' ])// Map &#123; \"b\": \"Barry\" &#125; 更新 update()作用：对对象中的某个属性进行更新，可对原数据进行相关操作用法：12update(index: number, updater: (value: T) =&gt; T): this //Listupdate(key: K, updater: (value: V) =&gt; V): this //Map 代码示例：12345678////Listconst list = List([ 'a', 'b', 'c' ])const result = list.update(2, val =&gt; val.toUpperCase())///Mapconst aMap = Map(&#123; key: 'value' &#125;)const newMap = aMap.update('key', value =&gt; value + value)updateIn() 用法参考setIn 清除 clear() 作用：清除所有数据 用法：clear(): this 代码示例：12Map(&#123; key: 'value' &#125;).clear() //MapList([ 1, 2, 3, 4 ]).clear() // List List中的各种删除与插入List对应的数据结构是js中的数组，所以数组的一些方法在Immutable中也是通用的，比如push，pop,shift，unshift，insert。 push()：在List末尾插入一个元素pop(): 在List末尾删除一个元素unshift: 在List首部插入一个元素shift: 在List首部删除一个元素insert：在List的index处插入元素代码实现：123456789101112List([ 0, 1, 2, 3, 4 ]).insert(6, 5) //List [ 0, 1, 2, 3, 4, 5 ]List([ 1, 2, 3, 4 ]).push(5)// List [ 1, 2, 3, 4, 5 ]List([ 1, 2, 3, 4 ]).pop()// List[ 1, 2, 3 ]List([ 2, 3, 4]).unshift(1);// List [ 1, 2, 3, 4 ]List([ 0, 1, 2, 3, 4 ]).shift();// List [ 1, 2, 3, 4 ]List中还有一个特有的方法用法设置List的长度，setSize()List([]).setSize(2).toJS() //[undefined,undefined] 关于mergemerge 作用：浅合并，新数据与旧数据对比，旧数据中不存在的属性直接添加，就数据中已存在的属性用新数据中的覆盖 mergrWith 作用：自定义浅合并，可自行设置某些属性的值 mergeIn 作用：对深层数据进行浅合并 mergeDeep 作用：深合并，新旧数据中同时存在的的属性为新旧数据合并之后的数据 mergeDeepIn 作用：对深层数据进行深合并 mergrDeepWith 作用:自定义深合并，可自行设置某些属性的值这里用一段示例彻底搞懂merge，此示例为Map结构，List与Map原理相同123456789101112131415const Map1 = Immutable.fromJS(&#123;a:111,b:222,c:&#123;d:333,e:444&#125;&#125;);const Map2 = Immutable.fromJS(&#123;a:111,b:222,c:&#123;e:444,f:555&#125;&#125;);const Map3 = Map1.merge(Map2); //Map &#123;a:111,b:222,c:&#123;e:444,f:555&#125;&#125;const Map4 = Map1.mergeDeep(Map2); //Map &#123;a:111,b:222,c:&#123;d:333,e:444,f:555&#125;&#125;const Map5 = Map1.mergeWith((oldData,newData,key)=&gt;&#123; if(key === 'a')&#123; return 666; &#125;else&#123; return newData &#125; &#125;,Map2); //Map &#123;a:666,b:222,c:&#123;e:444,f:555&#125;&#125; 序列算法concat()作用：对象的拼接，用法与js数组中的concat()相同，返回一个新的对象。用法：1const List = list1.concat(list2) map()作用：遍历整个对象，对Map/List元素进行操作，返回一个新的对象。用法：12Map(&#123;a:1,b:2&#125;).map(val=&gt;10*val)//Map&#123;a:10,b:20&#125; Map特有的mapKey()作用：遍历整个对象，对Map元素的key进行操作，返回一个新的对象。用法：12Map(&#123;a:1,b:2&#125;).mapKey(val=&gt;val+'l')//Map&#123;al:10,bl:20&#125; Map特有的mapEntries() 作用：遍历整个对象，对Map元素的key和value同时进行操作，返回一个新的对象。Map的map()也可实现此功能。用法：1234Map(&#123;a:1,b:2&#125;).map((key,val)=&gt;&#123; return [key+'l',val*10]&#125;)//Map&#123;al:10,bl:20&#125; 过滤 filter作用：返回一个新的对象，包括所有满足过滤条件的元素用法：1234Map(&#123;a:1,b:2&#125;).filter((key,val)=&gt;&#123; return val == 2&#125;)//Map&#123;b:2&#125; 还有一个filterNot()方法，与此方法正好相反。反转 reverse作用：将数据的结构进行反转代码示例：1234Immutable.fromJS([1, 2, 3, 4, 5]).reverse();// List [5,4,3,2,1]Immutable.fromJS(&#123;a:1,b:&#123;c:2,d:3&#125;,e:4&#125;).recerse();//Map &#123;e:4,b:&#123;c:2,d:3&#125;,a:1&#125; 排序 sort &amp; sortBy作用：对数据结构进行排序代码示例：1234567891011121314151617181920212223242526272829303132///ListImmutable.fromJS([4,3,5,2,6,1]).sort()// List [1,2,3,4,5,6]Immutable.fromJS([4,3,5,2,6,1]).sort((a,b)=&gt;&#123; if (a &lt; b) &#123; return -1; &#125; if (a &gt; b) &#123; return 1; &#125; if (a === b) &#123; return 0; &#125;&#125;)// List [1,2,3,4,5,6]Immutable.fromJS([&#123;a:3&#125;,&#123;a:2&#125;,&#123;a:4&#125;,&#123;a:1&#125;]).sortBy((val,index,obj)=&gt;&#123; return val.get('a')&#125;,(a,b)=&gt;&#123; if (a &lt; b) &#123; return -1; &#125; if (a &gt; b) &#123; return 1; &#125; if (a === b) &#123; return 0; &#125;&#125;)//List [ &#123;a:3&#125;, &#123;a:2&#125;, &#123;a:4&#125;, &#123;a:1&#125; ]//MapImmutable.fromJS( &#123;b:1, a: 3, c: 2, d:5&#125; ).sort()//Map &#123;b: 1, c: 2, a: 3, d: 5&#125;Immutable.fromJS( &#123;b:1, a: 3, c: 2, d:5&#125; ).sort((a,b)=&gt;&#123; if (a &lt; b) &#123; return -1; &#125; if (a &gt; b) &#123; return 1; &#125; if (a === b) &#123; return 0; &#125;&#125;)//Map &#123;b: 1, c: 2, a: 3, d: 5&#125;Immutable.fromJS( &#123;b:1, a: 3, c: 2, d:5&#125; ).sortBy((value, key, obj)=&gt; &#123; return value&#125;)//Map &#123;b: 1, c: 2, a: 3, d: 5&#125; 分组 groupBy作用：对数据进行分组12345678910111213const listOfMaps = List([ Map(&#123; v: 0 &#125;), Map(&#123; v: 1 &#125;), Map(&#123; v: 1 &#125;), Map(&#123; v: 0 &#125;), Map(&#123; v: 2 &#125;)])const groupsOfMaps = listOfMaps.groupBy(x =&gt; x.get('v'))// Map &#123;// 0: List [ Map&#123; \"v\": 0 &#125;, Map &#123; \"v\": 0 &#125; ],// 1: List [ Map&#123; \"v\": 1 &#125;, Map &#123; \"v\": 1 &#125; ],// 2: List [ Map&#123; \"v\": 2 &#125; ],// &#125; 查找数据indexOf() 、 lastIndexOf Map不存在此方法作用：和js数组中的方法相同，查找第一个或者最后一个value的index值，找不到则返回-1用法：12Immutable.fromJS([1,2,3,4]).indexof(3) //2Immutable.fromJS([1,2,3,4]).lastIndexof(3) //2 findIndex() 、 findLastIndex() Map不存在此方法作用：查找满足要求的元素的index值用法：123456Immutable.fromJS([1,2,3,4]).findIndex((value,index,array)=&gt;&#123; return value%2 === 0;&#125;) // 1Immutable.fromJS([1,2,3,4]).findLastIndex((value,index,array)=&gt;&#123; return index%2 === 0;&#125;) // 3 find() 、 findLast()作用：查找满足条件的元素的value值用法：1234567Immutable.fromJS([1,2,3,4]).find((value,index,array)=&gt;&#123; return value%2 === 0;&#125;) // 2Immutable.fromJS([1,2,3,4]).findLast((value,index,array)=&gt;&#123; return value%2 === 0;&#125;) // 4 findKey() 、 findLastKey()作用：查找满足条件的元素的key值用法：1234567Immutable.fromJS([1,2,3,4]).findKey((value,index,array)=&gt;&#123; return value%2 === 0;&#125;) // 1Immutable.fromJS([1,2,3,4]).findLastKey((value,index,array)=&gt;&#123; return value%2 === 0;&#125;) // 3 findEntry() 、 findLastEntry()作用：查找满足条件的元素的键值对 key:value用法：1234567Immutable.fromJS([1,2,3,4]).findEntry((value,index,array)=&gt;&#123; return value%2 === 0;&#125;) // [1,2]Immutable.fromJS([1,2,3,4]).findLastEntry((value,index,array)=&gt;&#123; return value%2 === 0;&#125;) // [3,4] keyOf() lastKeyOf()作用：查找某一个value对应的key值用法：12Immutable.fromJS([1,2,3,4]).keyOf(2) //1Immutable.fromJS([1,2,3,4]).lastKeyOf(2) //1 max() 、 maxBy()作用：查找最大值用法:12345Immutable.fromJS([1, 2, 3, 4]).max() //4Immutable.fromJS([&#123;a;1&#125;,&#123;a:2&#125;,&#123;a: 3&#125;,&#123;a:4&#125;]).maxBy((value,index,array)=&gt;&#123; return value.get('a')&#125;) //&#123;a:4&#125; min() 、 minBy() 作用：查找最小值用法:12345Immutable.fromJS([1, 2, 3, 4]).min() //1Immutable.fromJS([&#123;a;1&#125;,&#123;a:2&#125;,&#123;a: 3&#125;,&#123;a:4&#125;]).minBy((value,index,array)=&gt;&#123; return value.get('a')&#125;) //&#123;a:1&#125; 创建子集slice() 作用： 和原生js中数组的slice数组一样，包含两个参数，start和end，start代表开始截取的位置，end代表结束的位置，不包括第end的元素。若不包括end，则返回整个对象，若end为负数，则返回（start，length-end）对应的数据。若start只有一个并且为负数，则返回最后的end个元素。 用法： 1234Immutable.fromJS([1, 2, 3, 4]).slice(0); //[1,2,3,4]Immutable.fromJS([1, 2, 3, 4]).slice(0,2); //[1,2]Immutable.fromJS([1, 2, 3, 4]).slice(-2); //[3,4]Immutable.fromJS([1, 2, 3, 4]).slice(0,-2); //[1,2] rest()作用：返回除第一个元素之外的所有元素用法:1Immutable.fromJS([1, 2, 3, 4]).rest()//[2,3,4] butLast()作用：返回除最后一个元素之外的所有元素用法:1Immutable.fromJS([1, 2, 3, 4]).rest()//[1,2,3] skip()作用：有一个参数n, 返回截掉前n个元素之后剩下的所有元素用法:1Immutable.fromJS([1, 2, 3, 4]).skip(1)//[2,3,4] skipLast() 作用：有一个参数n, 返回截掉最后n个元素之后剩下的所有元素 用法: 1Immutable.fromJS([1, 2, 3, 4]).skip(1)//[1,2,3] skipWhile() 作用：返回从第一次返回false之后的所有元素 123Immutable.fromJS([1, 2, 3, 4]).skipWhile(list.skipWhile((value,index,list)=&gt;&#123; return value &gt; 2;&#125;))// [1,2,3,4] skipUntil() 作用：返回从第一次返回true之后的所有元素 123Immutable.fromJS([1, 2, 3, 4]).skipUntil(list.skipWhile((value,index,list)=&gt;&#123; return value &gt; 2;&#125;))// [3,4] take() 作用：有一个参数n, 返回前n个元素 用法:Immutable.fromJS([1, 2, 3, 4]).take(2)//[1,2] takeLast() 作用：有一个参数n, 返回最后n个元素 用法:1Immutable.fromJS([1, 2, 3, 4]).takeLast(2)//[3,4] takeWhile() 作用：返回从第一次返回false之前的所有元素 123Immutable.fromJS([1, 2, 3, 4]).skipWhile(list.takeWhile((value,index,list)=&gt;&#123; return value &gt; 2;&#125;))// [] takeUntil() 作用：返回从第一次返回true之前的所有元素 123Immutable.fromJS([1, 2, 3, 4]).skipUntil(list.takeUntil((value,index,list)=&gt;&#123; return value &gt; 2;&#125;))// [1,2] 处理数据reduce() 作用：和js中数组中的reduce相同,按索引升序的顺序处理元素 用法： 12345Immutable.fromJS([1,2,3,4]).reduce((pre,next,index,arr)=&gt;&#123; console.log(pre+next) return pre+next; &#125;)// 3 6 10 reduceRight() 作用：和js中数组中的reduce相同,按索引降序的顺序处理元素 用法： 12345Immutable.fromJS([1,2,3,4]).reduceRight((pre,next,index,arr)=&gt;&#123; console.log(pre+next) return pre+next; &#125;)// 7 9 10 every() 作用：判断整个对象总中所有的元素是不是都满足某一个条件，都满足返回true，反之返回false。 代码： 123Immutable.fromJS([1,2,3,4]).every((value,index,arr)=&gt;&#123; return value &gt; 2&#125;) // false some() 作用：判断整个对象总中所有的元素是不是存在满足某一个条件的元素，若存在返回true，反之返回false。 代码： 123Immutable.fromJS([1,2,3,4]).some((value,index,arr)=&gt;&#123; return value &gt; 2&#125;) // true join() 作用：同js中数组的join方法。把准换为字符串 用法：Immutable.fromJS([1,2,3,4]).join(‘,’) //1,2,3,4 isEmpty() 作用：判断是否为空 用法: 12Immutable.fromJS([]).isEmpty(); // trueImmutable.fromJS(&#123;&#125;).isEmpty(); // true count() 作用：返回元素个数，可自定义条件，返回满足条件的个数 用法： 12345678910const list = Immutable.fromJS([1,2,3,4]);const map = Immutable.fromJS(&#123;a:1,b:2,c:3,d:4&#125;);list.count((value,index,list)=&gt;&#123; return value &gt; 2;&#125;) //2map.count((value,index,list)=&gt;&#123; return value &gt; 2;&#125;) //2 countBy() 作用：与count不同的是，countBy返回一个对象 用法： 12345678const list = Immutable.fromJS([1,2,3,4]);const map = Immutable.fromJS(&#123;a:1,b:2,c:3,d:4&#125;);list.countBy((value,index,list)=&gt;&#123; return value &gt; 2;&#125; //&#123;false: 2, true: 2&#125;map.countBy((value,index,list)=&gt;&#123; return value &gt; 2;&#125; //&#123;false: 2, true: 2&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"},{"name":"immutable","slug":"immutable","permalink":"http://yoursite.com/tags/immutable/"},{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"redux 源码学习——createStore","slug":"redux-源码学习—createStore","date":"2018-05-11T02:07:29.000Z","updated":"2018-06-28T10:00:35.000Z","comments":true,"path":"2018/05/11/redux-源码学习—createStore/","link":"","permalink":"http://yoursite.com/2018/05/11/redux-源码学习—createStore/","excerpt":"","text":"createStore 理解 创建一个保存state树的Redux store，store，可以让你阅读state，发送actions，并订阅更改。改变store数据的唯一方法是调用dispatch（）方法。应用中只能有一个store，指定state树的不同部分如何响应actions，可以通过使用combineReducers方法来组合多个reducer，将其转换为单个reducer。 返回值createStore.js是redux的核心文件，对外暴露了一个createStore函数，函数执行后返回一个对象，这个对象包括四个方法，分别是dispatch, subscribe, getState, replaceReducer。这些方法都redux中store的关键方法，后面将慢慢的展开理解。12345678910export default function createStore(reducer, preloadedState, enhancer) &#123; //other codes return &#123; dispatch, subscribe, getState, replaceReducer, [$$observable]: observable &#125;&#125; createStore 的参数理解createStore有三个参数：reducer, preloadedState, enhancer。 reducer：reducer是一个函数，通过给定当前state树和要处理的actions，返回下一个state树。 preloadedState：初始state，初始状态。您可以选择指定它从应用程序的服务器中来融合state，或者还原先前序列化的用户会话。如果使用combineReducers来生成根reducer函数，则必须是一个与“combineReducers”键相同的对象。 enhancer：store增强器。您可以选择指定它通过第三方功能增强store，如中间件，时间旅行，持久化等。Redux附带的唯一store增强器是applyMiddleware（）方法。这个参数特别有意思，如果该enhancer参数存在的话，会将当前的createStore函数作为参数传入enhancer函数，并且，enhancer执行之后得到一个新函数，该新函数其实就是一个加强版的createStore函数，新的函数会把之前的reducer和preloadeState作为参数传入并执行。这个enhancer参数为redux中间件提供了入口。 参数检查及异常处理12345678910111213141516171819//如果没有传preloadedState参数，但是enhancer参数传了，把两者交换一下if (typeof preloadedState === 'function' &amp;&amp; typeof enhancer === 'undefined') &#123; enhancer = preloadedState preloadedState = undefined &#125;//如果enhancer传了，但是不是函数，就抛出错误，否则执行enhancer函数，//并继续执行enhancer函数返回的加强版的createStore函数，//参数reducer以及preloadeState和原createStore函数保持一致if (typeof enhancer !== 'undefined') &#123; if (typeof enhancer !== 'function') &#123; throw new Error('Expected the enhancer to be a function.') &#125; return enhancer(createStore)(reducer, preloadedState) &#125;//如果reducer不是函数，则抛出错误if (typeof reducer !== 'function') &#123; throw new Error('Expected the reducer to be a function.')&#125; 定义局部变量12345let currentReducer = reducer //保存了当前的reducer函数，该reducer函数可以被动态替换掉let currentState = preloadedState //保存了当前的state数据let currentListeners = [] //保存了当前注册的函数列表let nextListeners = currentListenerslet isDispatching = false //是否正在dispatch一个action 定义返回store的方法1234567//确保nextListeners和currentListeners不是同一个引用function ensureCanMutateNextListeners() &#123; if (nextListeners === currentListeners) &#123; //如果是同一个引用，则浅拷贝currentListeners到nextListeners nextListeners = currentListeners.slice() &#125;&#125; 1234//getState函数，返回局部变量currentState，以获取当前状态function getState() &#123; return currentState&#125; 123456789101112131415161718192021222324252627//注册一个函数，将注册函数放入局部变量nextListeners数组里面//注册函数的返回值是一个注销函数，注销函数执行可以将刚刚添加进nextListeners的listener函数又删除掉。这里很有意思，外部必须在调用subscribe执行现场保存好unsubscribe函数，否则将无法注销一个函数function subscribe(listener) &#123; //如果listener不是函数，直接报错 if (typeof listener !== 'function') &#123; throw new Error('Expected listener to be a function.') &#125; let isSubscribed = true //确保nextListeners不是currentListeners，以保证修改的是nextListeners，而不是currentListeners ensureCanMutateNextListeners() //将监听函数放入监听函数列表尾部 nextListeners.push(listener) //返回一个函数，该函数可以从监听函数列表中删除刚刚注册的监听函数 return function unsubscribe() &#123; if (!isSubscribed) &#123; return &#125; isSubscribed = false ensureCanMutateNextListeners() const index = nextListeners.indexOf(listener) nextListeners.splice(index, 1) &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142//触发action的函数：每次触发一个action，currentListeners中的所有函数都要执行一遍function dispatch(action) &#123; //如果action不是普通的对象，直接报错 if (!isPlainObject(action)) &#123; throw new Error( 'Actions must be plain objects. ' + 'Use custom middleware for async actions.' ) &#125; //如果action没有type属性，直接报错：说明action对象必须要包含type字段 if (typeof action.type === 'undefined') &#123; throw new Error( 'Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?' ) &#125; //如果当前正在触发另外一个action，直接报错 if (isDispatching) &#123; throw new Error('Reducers may not dispatch actions.') &#125; try &#123; //先将标志位置为true isDispatching = true //执行传入的reducer函数，该函数返回一个新的state对象，并赋值给currentState变量 currentState = currentReducer(currentState, action) &#125; finally &#123; //reducer函数执行完成后，将isDispatching恢复成false，方便下次action的触发 isDispatching = false &#125; //每一次触发一个action，所有的监听函数都要全部重新执行一遍， //并且把上次得到的新的监听函数列表赋值成为当前的监听函数列表。这是一个懒操作，并不是在subscribe的时候就操作了，而是在dispatch的时候才操作 const listeners = currentListeners = nextListeners for (let i = 0; i &lt; listeners.length; i++) &#123; const listener = listeners[i] listener() &#125; //该dispatch函数的返回值是原来的action return action&#125; 12345678910111213//替换reducer函数：这个函数允许运行时动态替换最开始调用createStore函数时传入的reducer，并且替换掉reducer之后，重新dispatch一个action，得到全新的currentState对象function replaceReducer(nextReducer) &#123; //如果nextReducer不是函数，直接报错 if (typeof nextReducer !== 'function') &#123; throw new Error('Expected the nextReducer to be a function.') &#125; //把新的reducer赋值给当前的currentReducer变量，得到一个全新的currentReducer currentReducer = nextReducer // 触发一个初始action： // 1.这样就可以完成一次监听函数列表的全部调用 // 2.可以得到一个全新的currentState； dispatch(&#123;type: ActionTypes.INIT&#125;)&#125; 1234567891011121314151617181920212223242526272829303132function observable() &#123; const outerSubscribe = subscribe return &#123; /** * The minimal observable subscription method. * @param &#123;Object&#125; observer Any object that can be used as an observer. * The observer object should have a `next` method. * @returns &#123;subscription&#125; An object with an `unsubscribe` method that can * be used to unsubscribe the observable from the store, and prevent further * emission of values from the observable. */ subscribe(observer) &#123; if (typeof observer !== 'object') &#123; throw new TypeError('Expected the observer to be an object.') &#125; function observeState() &#123; if (observer.next) &#123; observer.next(getState()) &#125; &#125; observeState() const unsubscribe = outerSubscribe(observeState) return &#123;unsubscribe&#125; &#125;, [$$observable]() &#123; return this &#125; &#125;&#125; 初始化:初始化很简单，一句代码，直接调用一次dispatch，就会执行所有的注册函数，并且执行reducer函数，生成初始化的state12//马上内部调用一次初始化的操作，根据传入的reducer函数，preloadedState生成一个全新的currentState和全新的reducerdispatch(&#123;type: ActionTypes.INIT&#125;) 总结 createStore函数定义了几个局部变量用于记录状态，主要包括currentState记录数据状态，currentListeners记录注册函数列表，currentReducer记录当前的reducer函数。 定义了几个函数用于修改上面的几个局部变量：主要包括getState函数用于获取currentState；replaceReducer用于替换currentReducer；subscribe用于修改currentListeners列表；dispatch用于触发currentReducer执行，生成新的currentState，并且，执行currentListeners列表中的每一个函数。","categories":[{"name":"redux源码学习","slug":"redux源码学习","permalink":"http://yoursite.com/categories/redux源码学习/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"},{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"redux","slug":"redux","permalink":"http://yoursite.com/tags/redux/"}]},{"title":"瀑布流布局","slug":"瀑布流布局","date":"2018-05-09T09:17:52.000Z","updated":"2018-06-28T10:00:35.000Z","comments":true,"path":"2018/05/09/瀑布流布局/","link":"","permalink":"http://yoursite.com/2018/05/09/瀑布流布局/","excerpt":"","text":"瀑布流布局 在知乎看到大佬说，学习前端的第一阶段要会一些js基本的特效，学习一下，做几个Demo来看看 好像有那么两种方法：1、通过css来搞定瀑布流2、通过js来控制 CSS方法解决瀑布流因为css3有了一个新的属性:column我们在图片或者需要瀑布流的模块的父元素设置column属性就可以达到这种瀑布流的效果。12345678#main&#123; /*定位*/ /*position: relative;*/ /*多栏布局 设置栏宽度*/ -webkit-column-width:202px; -moz-column-width:202px; column-width:202px;&#125; JS方法来解决瀑布流布局首先先把html写出来：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;瀑布流布局&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"main\"&gt; &lt;div class=\"wrap\"&gt; &lt;div class=\"img\"&gt; &lt;img src=\"http://img4.imgtn.bdimg.com/it/u=3673652172,785167112&amp;fm=27&amp;gp=0.jpg\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"wrap\"&gt; &lt;div class=\"img\"&gt; &lt;img src=\"http://img1.imgtn.bdimg.com/it/u=2752884811,3342547378&amp;fm=27&amp;gp=0.jpg\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"wrap\"&gt; &lt;div class=\"img\"&gt; &lt;img src=\"http://img5.imgtn.bdimg.com/it/u=2573504723,2456120500&amp;fm=27&amp;gp=0.jpg\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"wrap\"&gt; &lt;div class=\"img\"&gt; &lt;img src=\"http://img0.imgtn.bdimg.com/it/u=3214770734,3861052448&amp;fm=27&amp;gp=0.jpg\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"wrap\"&gt; &lt;div class=\"img\"&gt; &lt;img src=\"http://img4.imgtn.bdimg.com/it/u=3407532446,2830180038&amp;fm=27&amp;gp=0.jpg\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"wrap\"&gt; &lt;div class=\"img\"&gt; &lt;img src=\"http://img0.imgtn.bdimg.com/it/u=30302420,912099376&amp;fm=27&amp;gp=0.jpg\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"wrap\"&gt; &lt;div class=\"img\"&gt; &lt;img src=\"http://img5.imgtn.bdimg.com/it/u=2347360460,2805552283&amp;fm=27&amp;gp=0.jpg\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 在html里写了很多的图片（这里没有写出来，也可以从后台拉取数据）然后对图片做一些样式的调整：1234567891011121314151617181920212223&lt;style&gt; * &#123; padding: 0px; margin: 0px; &#125; #main &#123; position: relative; &#125; .wrap &#123; padding: 15px 0px 0px 15px; float: left; &#125; .img &#123; padding: 10px; border-radius: 5px; border: 1px solid #ccc; box-shadow: 0 0 5px #ccc; &#125; .img img &#123; width: 240px; height: auto; &#125; &lt;/style&gt; 对图片做一些操作，宽度确定，高度auto;然后开始用js对这些图片做一些处理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;script&gt; window.onload = function () &#123; waterFull('main', 'wrap'); &#125; function waterFull(parent, children) &#123; var oParent = document.getElementById(parent); var oWraps = getByClass(oParent, children); //计算整个页面显示的列数 var oWrapWeight = oWraps[0].offsetWidth; var cols = Math.floor(document.documentElement.clientWidth / oWrapWeight); //设置main的宽度，并且居中 oParent.style.cssText = 'width:' + oWrapWeight * cols + 'px; margin: 0 auto'; //找出高度最小的图片，将下一个图片放在下面 //定义一个数组，存放每一列的高度，初始化存的是第一行的所有列的高度 var arrHeight = []; for (var i = 0; i &lt; oWraps.length; i++) &#123; if (i &lt; cols) &#123; arrHeight.push(oWraps[i].offsetHeight); &#125;else &#123; var minHeight = Math.min.apply(null, arrHeight); var minIndex = getMinhIndex(arrHeight, minHeight); oWraps[i].style.position = 'absolute'; oWraps[i].style.top = minHeight + 'px'; oWraps[i].style.left = minIndex * oWrapWeight + 'px'; arrHeight[minIndex] += oWraps[i].offsetHeight; &#125; &#125; &#125; function getByClass(parent, className) &#123; var boxArr = new Array();//用来获取所有class为box的元素 oElement = parent.getElementsByTagName('*'); for (var i = 0; i &lt; oElement.length; i++) &#123; if (oElement[i].className == className) &#123; boxArr.push(oElement[i]); &#125; &#125;; return boxArr; &#125; //获取当前最小值得下标 function getMinhIndex(array, min) &#123; for (var i in array) &#123; if (array[i] == min) return i; &#125; &#125; &lt;/script&gt; 搞定～","categories":[{"name":"Demo练习","slug":"Demo练习","permalink":"http://yoursite.com/categories/Demo练习/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"},{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]},{"title":"react 16.0 新特性学习","slug":"react-16-0-新特性学习","date":"2018-05-09T02:23:39.000Z","updated":"2018-05-14T09:59:24.000Z","comments":true,"path":"2018/05/09/react-16-0-新特性学习/","link":"","permalink":"http://yoursite.com/2018/05/09/react-16-0-新特性学习/","excerpt":"","text":"1、Fragment新版本的render可以返回数组、字符串、react组件、数字、boolean值v15.x必须要一个标签来包裹Before v161234567return ( &lt;div&gt; &lt;label htmlFor=\"name\"&gt;名字：&lt;/label&gt; &lt;input id=\"name\" type=\"text\" placeholder=\"请输入名字\"/&gt; &lt;button&gt;搜索&lt;/button&gt; &lt;/div&gt; ); When v16.0.01234567return ( [ &lt;label htmlFor=\"name\"&gt;名字：&lt;/label&gt;, &lt;input id=\"name\" type=\"text\" placeholder=\"请输入名字\"/&gt;, &lt;button&gt;搜索&lt;/button&gt; ]); Now v16.2.01234567return ( &lt;React.Fragment&gt; &lt;label htmlFor=\"name\"&gt;名字：&lt;/label&gt; &lt;input id=\"name\" type=\"text\" placeholder=\"请输入名字\"/&gt; &lt;button&gt;搜索&lt;/button&gt; &lt;/React.Fragment&gt;); 片段(fragments) 可以让你将子元素列表添加到一个分组中，并且不会在DOM中增加额外节点。key 是唯一可以传递给 Fragment 的属性1234567891011return ( &lt;dl&gt; &#123;props.items.map(item =&gt; ( // 没有`key`，将会触发一个key警告 &lt;React.Fragment key=&#123;item.id&#125;&gt; &lt;dt&gt;&#123;item.term&#125;&lt;/dt&gt; &lt;dd&gt;&#123;item.description&#125;&lt;/dd&gt; &lt;/React.Fragment&gt; ))&#125; &lt;/dl&gt; ); 简明写法&lt;&gt;&lt;/&gt;，但是还没有被更多的工具支持，它不支持 键(keys) 或 属性(attributes)。Further babel v7.0.0+ , babel-plugin-transform-react-jsx-source or babel-preset-react 1234567return ( &lt;&gt; &lt;label htmlFor=\"name\"&gt;名字：&lt;/label&gt; &lt;input id=\"name\" type=\"text\" placeholder=\"请输入名字\"/&gt; &lt;button&gt;搜索&lt;/button&gt; &lt;/&gt;); DOM Fragment 12345678910const select = document.getElementById('select')const values = [1, 2, 3]const fragment = document.createDocumentFragment()values.map(item =&gt; &#123; const option = document.createElement('option') option.value = item option.innerHTML = `小明$&#123;item&#125;号` fragment.appendChild(option)&#125;)select.appendChild(fragment) 2、PortalsPortals是reactjs16提供的官方解决方案，使得组件可以脱离父组件层级挂载在DOM树的任何位置。普通情况下，组件的render函数返回的元素会被挂载在它的父级组件上。然而，有些元素需要被挂载在更高层级的位置。最典型的应用场景：当父组件具有overflow: hidden或者z-index的样式设置时，组件有可能被其他元素遮挡，就可以考虑使用Portal使组件的挂载脱离父组件。组件的挂载点虽然可以脱离父组件，但组件的事件通过冒泡机制仍可以传给父组件。1234&lt;body&gt; &lt;div id=\"bd\"&gt;&lt;/div&gt; &lt;div id=\"modal\"&gt;&lt;/div&gt;&lt;/body&gt; 123456789101112render( &lt;App&gt; &lt;SearchBox&gt; &lt;Modal&gt; &lt;div&gt;模态框&lt;/div&gt; &lt;/Modal&gt; &lt;/SearchBox&gt; &lt;/App&gt;, document.getElementById('bd'), () =&gt; &#123; console.log(arguments)&#125;) 1234567891011121314class App extends Component&#123; constructor(options) &#123; super(options) this.handleClick = this.handleClick.bind(this) &#125; handleClick() &#123; alert('react component tree propagation!') &#125; render() &#123; return &lt;div className=\"app\" onClick=&#123;this.handleClick&#125;&gt; &#123;this.props.children&#125; &lt;/div&gt; &#125;&#125; 12345678class Modal extends Component &#123; constructor(options) &#123; super(options) &#125; render() &#123; return createPortal(this.props.children, document.getElementById('modal')) &#125; &#125; 12345678910&lt;div id=\"bd\"&gt; &lt;div class=\"app\"&gt; &lt;label for=\"name\"&gt;名字：&lt;/label&gt; &lt;input type=\"text\" id=\"name\" placeholder=\"请输入名字\"&gt; &lt;button&gt;搜索&lt;/button&gt; &lt;/div&gt;&lt;/div&gt;&lt;div id=\"modal\"&gt; &lt;div&gt;模态框&lt;/div&gt;&lt;/div&gt; 1234567891011121314&lt;App&gt; &lt;div className=&quot;app&quot; onClick=bound handleClick()&gt; &lt;SearchBox&gt; &lt;labelhtmlFor=&quot;name&quot;&gt;名字：&lt;/label&gt; &lt;inputid=&quot;name&quot;type=&quot;text&quot;placeholder=&quot;请输入名字&quot;&gt;&lt;/input&gt; &lt;button&gt;搜索&lt;/button&gt; &lt;Modal&gt; &lt;ReactPortal target=HTMLDivElement&#123;…&#125;&gt; &lt;div&gt;模态框&lt;/div&gt; &lt;/ReactPortal&gt; &lt;/Modal&gt; &lt;/SearchBox&gt; &lt;/div&gt;&lt;/App&gt; Before portals 123456789101112131415161718ReactDom.render(reactChild, container, callback)ReactDom.unmountComponentAtNode(container)ReactDom.unstable_renderSubtreeIntoContainer( context, reactChild, domNode, callback)ReactDom.unmountComponentAtNode(container)render: ReactMount._renderSubtreeIntoContainer(null, reactChild, container, callback )unstable_renderSubtreeIntoContainer: ReactMount._renderSubtreeIntoContainer(context, reactChild, container, callback) 3、Error Boundaries之前react在渲染过程中或者是生命周期内出现了致命的错误，react会从根组件上把所有的组件都卸载下来，以防止展现错误的数据，但这不是最好的用户体验。React 16修复了这一点，引入了Error Boundary的概念，中文译为“错误边界”，当某个组件发生错误时，我们可以通过Error Boundary捕获到错误并对错误做优雅处理。（注：它并不能捕获runtime所有的错误，比如组件回调事件里的错误，可以把它想象成传统的try-catch语句） 123456789101112131415161718192021class ErrorBoundary extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; hasError: false &#125;; &#125;// 新增了componentDidCatch这个生命周期函数，它可以捕获自身及子树上的错误并对错误做优雅处理，包括上报错误日志、展示出错提示，而不是卸载整个组件树。 componentDidCatch(error, info) &#123; // 错误代理组件的展示与否 this.setState(&#123; hasError: true &#125;); // 在这里我们可以对错误进行记录 logErrorToMyService(error, info); &#125; render() &#123; if (this.state.hasError) &#123; // 在这里我们可以书写自己想要展示的ui组件 return &lt;h1&gt;Something went wrong.&lt;/h1&gt;; &#125; return this.props.children; &#125;&#125; 上面的组件是当页面中有错误时我们想要展示的效果，具体用法如下:12345678910render()&#123; return ( &lt;div&gt; &lt;ErrorBoundary&gt; // 外层组件我们定义的错误组件 &lt;Profile user=&#123;this.state.user&#125; /&gt; // 内层组件是我们将要监视的自定义组件 &lt;/ErrorBoundary&gt; &lt;button onClick=&#123;this.onClick&#125;&gt;Update&lt;/button&gt; &lt;/div&gt; )&#125; 这个组件能够不仅仅能够监听到本组件的错误，连同它下面的子组件的错误也可以监听到 ###不能捕获的错误 事件处理 异步回调 服务端渲染 error boundary组件自身抛出的错误（只能由父级捕获）###react遇到未捕获的错误会怎么办对 React16 来说，一个未捕获的错误会导致整个应用不能被挂载 4、setState传入null时不会再触发更新之前的setState不管传入什么只要调用了这么方法就会渲染123456789selectCity(e)&#123; const newValue = e.target.value; this.setState((state)=&gt;&#123; if(state.city===newValue)&#123; return null; &#125; return &#123;city:newValue&#125; &#125;)) 5、v16.0支持自定义的dom属性之前的版本对于自定义属性react会在属性前加上data-**来进行处理，现在对于部分属性去除了这种写法，拥抱了原生dom，这样可以减少react的代码，提升了性能 6、其他更好的服务器端渲染：React 16的SSR被完全重写，新的实现非常快，接近3倍性能于React 15，现在提供一种流模式streaming，可以更快地把渲染的字节发送到客户端。 react v16采用了最新的技术“Fiber.” React Server Side Rendering 解决 SPA 应用的 SEO 问题","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"},{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"Event Loop 问题理解","slug":"Event-Loop-问题理解","date":"2018-05-09T02:08:43.000Z","updated":"2018-06-28T10:00:35.000Z","comments":true,"path":"2018/05/09/Event-Loop-问题理解/","link":"","permalink":"http://yoursite.com/2018/05/09/Event-Loop-问题理解/","excerpt":"","text":"Q1:事件循环机制是什么？A1:JavaScript 是典型的单线程单并发语言，即表示在同一时间内其只能执行单个任务，同域浏览器中 JavaScript 主线程拥有一个函数调用栈(主线程)以及多个任务队列。 Q2:什么是任务？A2:任务分为两种，一种是同步任务，一种是异步任务。 同步任务，就是主线程中排队执行的任务； 异步任务，不先进入主线程，而是先进入“任务队列”的任务，只有任务队列通知了主线程，某个异步任务可以执行了，该任务才会进入主线程执行 Q3:事件循环（Event Loop）的原理是什么？A3:首先，主线程会依次执行代码。 当主线栈的函数调用栈为空时，即会根据事件循环（Event Loop）机制来从任务队列中提取出待执行的回调并执行。 执行的过程同样会进行函数帧的入栈出栈操作。这样不断的循环往复，这就是事件循环（Event Loop）。 只要主线程空了，就会去读取”任务队列”，这就是JavaScript的运行机制 Q4:任务队列中的任务有几种？A4:任务队列中的任务分为两种：MacroTask (task) 和 MicroTask 。Event Loop 处理这两种任务。 Q5:MacroTask (task) 和 MicroTask各包含什么任务？A5: microtasks:process.nextTick promise Object.observe MutationObserver macrotasks:setTimeout setInterval setImmediate I/O UI渲染 Q6:MacroTask和MicroTask的运行机制是什么？A6:事件循环的顺序，决定了JavaScript代码的执行顺序。它从script(整体代码)开始第一次循环。之后全局上下文进入函数调用栈。直到调用栈清空(只剩全局)，然后执行所有的microtask。当所有可执行的micro-task执行完毕之后。循环再次从macro-task开始，找到其中一个任务队列执行完毕，然后再执行所有的micro-task，这样一直循环下去。一句话说，microtask将会被添加到任务队列末尾进行处理。 MacroTask运行机制MicroTask运行机制Q7:来尝试一道面试题123456789101112131415161718192021222324252627282930313233343536373839console.log('start')const interval = setInterval(() =&gt; &#123; console.log('setInterval')&#125;, 0)setTimeout(() =&gt; &#123; console.log('setTimeout 1') Promise.resolve() .then(() =&gt; &#123; console.log('promise 3') &#125;) .then(() =&gt; &#123; console.log('promise 4') &#125;) .then(() =&gt; &#123; setTimeout(() =&gt; &#123; console.log('setTimeout 2') Promise.resolve() .then(() =&gt; &#123; console.log('promise 5') &#125;) .then(() =&gt; &#123; console.log('promise 6') &#125;) .then(() =&gt; &#123; clearInterval(interval) &#125;) &#125;, 0) &#125;)&#125;, 0)Promise.resolve() .then(() =&gt; &#123; console.log('promise 1') &#125;) .then(() =&gt; &#123; console.log('promise 2') &#125;) A7:startpromise 1promise 2setIntervalsetTimeout 1promise 3promise 4setIntervalsetTimeout 2promise 5promise 6","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"PWA 之Q&A","slug":"PWA-之Q-A","date":"2018-05-08T08:11:07.000Z","updated":"2018-05-14T09:59:24.000Z","comments":true,"path":"2018/05/08/PWA-之Q-A/","link":"","permalink":"http://yoursite.com/2018/05/08/PWA-之Q-A/","excerpt":"","text":"——吉吉《PWA初窥》学习笔记 Q1：什么是PWA？A1: PWA全称Progressive Web App，即渐进式WEB应用。一个 PWA 应用首先是一个网页, 可以通过 Web 技术编写出一个网页应用. 随后添加上 App Manifest 和 Service Worker 来实现 PWA 的安装和离线等功能 Q2: PWA解决了什么问题？A2: 1) 可以添加至主屏幕，点击主屏幕图标可以实现启动动画以及隐藏地址栏 2）实现离线缓存功能，即使用户手机没有网络，依然可以使用一些离线功能 3）实现了消息推送 Q3: App Manifest 是什么，有什么用？A3: Web应用程序清单在一个JSON文本文件中提供有关应用程序的信息（如名称，作者，图标和描述）。manifest 的目的是将Web应用程序安装到设备的主屏幕，为用户提供更快的访问和更丰富的体验。 Q4: 什么是service worker，有什么作用？A4: Service Worker 是 Chrome 团队提出和力推的一个 WEB API，用于给 web 应用提供高级的可持续的后台处理能力。 Service Workers 就像介于服务器和网页之间的拦截器，能够拦截进出的HTTP 请求，从而完全控制你的网站。 Q5: service worker 有什么特点？A5：1）resource caching and push notifications 2）client-side programmable proxy between web app and the outside world 3）service workers run independent of the application they are associated with 4）the primary uses for a service workers are to act as a caching agent to handle network requests 5）and to store content for offline use and secondly to handle push messaging the 6）information that you need to persist and reuse across restartswork with IndexedDB databases 7）promise-based 8）only available on secure origins(https) Q6: HTTP缓存与service worker缓存有什么区别A6: HTTP缓存 Web 服务器可以使用 Expires 首部来通知 Web 客户端，它可以使用资源的当前副本，直到指定的“过期 时间”。反过来，浏览器可以缓存此资源，并且只有在有效期满后才会再次检查新版本。 使用 HTTP 缓存意味着你要依赖服务器来告诉你何时缓存资源和何时过期。 service worker缓存 Service Workers 的强大在于它们拦截 HTTP 请求的能力 进入任何传入的 HTTP 请求，并决定想要如何响应。在你的 Service Worker 中，可以编写逻辑来决定 想要缓存的资源，以及需要满足什么条件和资源需要缓存多久。一切尽归你掌控！ Q7: service worker的生命周期是怎样的？A7: Q8: 怎么配置一个PWAA8: 1）准备一个html文件，以及相应的css等：12345678910&lt;head&gt; &lt;title&gt;Minimal PWA&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, user-scalable=no\" /&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"main.css\"&gt; &lt;link rel=\"manifest\" href=\"manifest.json\" /&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;Revision 1&lt;/h3&gt; &lt;div class=\"main-text\"&gt;Minimal PWA, open Console for more~~~&lt;/div&gt;&lt;/body&gt; 2）添加manifest.json文件 123456789101112131415&#123; \"name\": \"Minimal app to try PWA\", \"short_name\": \"Minimal PWA\", \"display\": \"standalone\", \"start_url\": \"/\", \"theme_color\": \"#8888ff\", \"background_color\": \"#aaaaff\", \"icons\": [ &#123; \"src\": \"e.png\", \"sizes\": \"256x256\", \"type\": \"image/png\" &#125; ]&#125; 3)添加Service WorkerService Worker 在网页已经关闭的情况下还可以运行, 用来实现页面的缓存和离线, 后台通知等等功能。sw.js 文件需要在 HTML 当中引入:12345678&lt;script&gt; if (navigator.serviceWorker != null) &#123; navigator.serviceWorker.register('sw.js') .then(function(registration) &#123; console.log('Registered events at scope: ', registration.scope); &#125;); &#125;&lt;/script&gt; 4)处理静态缓存12345678var cacheStorageKey = 'minimal-pwa-1'var cacheList = [ '/', \"index.html\", \"main.css\", \"e.png\"] 借助 Service Worker, 可以在注册完成安装 Service Worker 时, 抓取资源写入缓存:1234567self.addEventListener('install', e =&gt; &#123; e.waitUntil( caches.open(cacheStorageKey) .then(cache =&gt; cache.addAll(cacheList)) .then(() =&gt; self.skipWaiting()) )&#125;) 调用 self.skipWaiting() 方法是为了在页面更新的过程当中, 新的 Service Worker 脚本能立即激活和生效。5）处理动态缓存网页抓取资源的过程中, 在 Service Worker 可以捕获到 fetch 事件, 可以编写代码决定如何响应资源的请求:12345678910self.addEventListener('fetch', function(e) &#123; e.respondWith( caches.match(e.request).then(function(response) &#123; if (response != null) &#123; return response &#125; return fetch(e.request.url) &#125;) )&#125;) 真实的项目当中, 可以根据资源的类型, 站点的特点, 可以专门设计复杂的策略。fetch 事件当中甚至可以手动生成 Response 返回给页面。6)更新静态资源缓存的资源随着版本的更新会过期, 所以会根据缓存的字符串名称(这里变量为 cacheStorageKey, 值用了 “minimal-pwa-1”)清除旧缓存, 可以遍历所有的缓存名称逐一判断决决定是否清除(备注: 简化的写法, Promise.all 中 return undefined 可能出错, 见评论): 123456789101112self.addEventListener('activate', function(e) &#123; e.waitUntil( Promise.all( cacheNames.filter(name =&gt; &#123; return name !== cacheStorageKey &#125;).map(name =&gt; &#123; return caches.delete(name) &#125;) ).then(() =&gt; self.clients.claim()) &#125;) )&#125;) 在新安装的 Service Worker 中通过调用 self.clients.claim() 取得页面的控制权, 这样之后打开页面都会使用版本更新的缓存。旧的 Service Worker 脚本不再控制着页面之后会被停止。 相关文章： PWA 入门: 写个非常简单的 PWA 页面 讲讲PWA 您的第一个 Progressive Web App","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[]},{"title":"Javascript 继承学习","slug":"Javascript 继承学习","date":"2018-05-08T07:07:28.000Z","updated":"2018-06-28T10:00:35.000Z","comments":true,"path":"2018/05/08/Javascript 继承学习/","link":"","permalink":"http://yoursite.com/2018/05/08/Javascript 继承学习/","excerpt":"","text":"javascript的继承方式有好多方式，之前ES5通过原型链继承，ES6中引入了Class，javascript可以像java一样使用extends关键字继承。现在整理一下js中的继承方式。 ES5中的继承方式 一、构造函数的继承现在有一个”动物”对象的构造函数123function Animal()&#123; this.species = \"动物\";&#125; 还有一个”猫”对象的构造函数。 1234function Cat(name,color)&#123; this.name = name; this.color = color;&#125; 1.构造函数绑定:使用call或apply方法，将父对象的构造函数绑定在子对象上。 1234567function Cat(name,color)&#123; Animal.apply(this, arguments); this.name = name; this.color = color;&#125;var cat1 = new Cat(\"大毛\",\"黄色\");alert(cat1.species); // 动物 此种继承方式只能继承父构造函数中的属性,不能继承父构造函数原型上的属性.Animal.apply(this, arguments)也可用Animal.call(this)替换.cat对象有两个层级,第一级存放着自有属性以及父构造器中的属性,第二级存放着自己函数原型上的属性(Cat.prototype) 2.prototype模式: 1234Cat.prototype = new Animal();Cat.prototype.constructor = Cat;var cat1 = new Cat(\"大毛\",\"黄色\");alert(cat1.species); // 动物 遵循一点，即如果替换了prototype对象，1o.prototype = &#123;&#125;; 那么，下一步必然是为新的prototype对象加上constructor属性，并将这个属性指回原来的构造函数。1o.prototype.constructor = o; 此种继承方式既能继承父构造函数中的属性,也能继承父构造函数原型上的属性.cat对象有三个层级,第一级存放着自有属性,第二级存放着父构造器的属性(加上constructor,指向创建该对象(cat)的构造器(Cat)),第三级存放着父构造器原型上的属性. 3.直接继承prototype:第3种方法是对第2种方法的改进。由于Animal对象中，不变的属性都可以直接写入Animal.prototype。所以，我们也可以让Cat()跳过 Animal()，直接继承Animal.prototype。 先将Animal对象改写 12function Animal()&#123; &#125;Animal.prototype.species = \"动物\"; 然后，将Cat的prototype对象，然后指向Animal的prototype对象，这样就完成了继承。 1234Cat.prototype = Animal.prototype;Cat.prototype.constructor = Cat;var cat1 = new Cat(\"大毛\",\"黄色\");alert(cat1.species); // 动物 此种继承方式只能继承父构造器原型上的属性.cat对象有两个层级,第一级存放着自有属性,第二级存放着父构造器原型上的属性(加上constructor,指向创建该对象(cat)的构造器(Cat)).注意:Cat.prototype.constructor = Cat会将Animal.prototype.constructor也改成Cat,从而影响父构造器创建对象 4.空对象作为中介: 1234567function extend(Child, Parent) &#123; var F = function()&#123;&#125;; F.prototype = Parent.prototype; Child.prototype = new F(); Child.prototype.constructor = Child; Child.uber = Parent.prototype;&#125; 用法： 123extend(Cat,Animal);var cat1 = new Cat(\"大毛\",\"黄色\");alert(cat1.species); // 动物 此种继承方式只能继承父构造器原型上的属性.cat对象有三个层级,第一级存放着自有属性,第二级存放着临时构造器F的属性(加上constructor,指向创建该对象(cat)的构造器(Cat)),第三级存放着父构造器原型上的属性.注意:临时构造器只充当中介的作用,一般不会有自己的属性. 5.浅拷贝继承:首先，还是把Animal的所有不变属性，都放到它的prototype对象上。12function Animal()&#123; &#125;Animal.prototype.species = \"动物\"; 然后，再写一个函数，实现属性拷贝的目的。12345678function extend2(Child, Parent) &#123; var p = Parent.prototype; var c = Child.prototype; for (var i in p) &#123; c[i] = p[i]; &#125; c.uber = p;&#125; 用法： 123extend2(Cat, Animal);var cat1 = new Cat(\"大毛\",\"黄色\");alert(cat1.species); // 动物 此种继承方式只能继承父构造器原型上的属性.cat对象有两个层级,第一级存放着自有属性,第二级存放着父构造器原型上的除了constructor和proto的属性(不会拷贝原型上的constructor和proto属性).适合父构造器原型上的自增属性为基本数据类型的情况. 二、非构造函数的继承比如，现在有一个对象，叫做”中国人”。123var Chinese = &#123; nation:'中国'&#125;; 还有一个对象，叫做”医生”。123var Doctor =&#123; career:'医生'&#125; 1.object()方法 12345function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125; 这个object()函数，其实只做一件事，就是把子对象的prototype属性，指向父对象，从而使得子对象与父对象连在一起。用法：第一步先在父对象的基础上，生成子对象：1var Doctor = object(Chinese); 然后，再加上子对象本身的属性：1Doctor.career = '医生'; 这时，子对象已经继承了父对象的属性了。1alert(Doctor.nation); //中国 2.浅拷贝除了使用”prototype链”以外，还有另一种思路：把父对象的属性，全部拷贝给子对象，也能实现继承。 就是在做拷贝：12345678function extendCopy(p) &#123;var c = &#123;&#125;;for (var i in p) &#123; c[i] = p[i];&#125;c.uber = p;return c;&#125; 用法，这样写：123var Doctor = extendCopy(Chinese);Doctor.career = '医生';alert(Doctor.nation); // 中国 样的拷贝有一个问题。那就是，如果父对象的属性等于数组或另一个对象，那么实际上，子对象获得的只是一个内存地址，而不是真正拷贝，因此存在父对象被篡改的可能。 3.深拷贝所谓”深拷贝”，就是能够实现真正意义上的数组和对象的拷贝。它的实现并不难，只要递归调用”浅拷贝”就行了。123456789101112function deepCopy(p, c) &#123; var c = c || &#123;&#125;; for (var i in p) &#123; if (typeof p[i] === 'object') &#123; c[i] = (p[i].constructor === Array) ? [] : &#123;&#125;; deepCopy(p[i], c[i]); &#125; else &#123; c[i] = p[i]; &#125; &#125; return c;&#125; 使用的时候这样写：1var Doctor = deepCopy(Chinese); 现在，给父对象加一个属性，值为数组。然后，在子对象上修改这个属性：这时，父对象就不会受到影响了。目前，jQuery库使用的就是这种继承方法。 ES6中的继承方式Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。123456789101112class Point &#123; //一些属性&#125;class ColorPoint extends Point &#123; //一些属性&#125;// 等同于class ColorPoint extends Point &#123; constructor(...args) &#123; super(...args); &#125;&#125; 上面代码定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Point类。 如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。 在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例。 ES6 规定，在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]}]}