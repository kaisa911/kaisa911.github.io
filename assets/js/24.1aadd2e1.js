(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{605:function(t,e,r){"use strict";r.r(e);var i=r(17),a=Object(i.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("p",[t._v("之前写 CSS 的时候都是想到什么属性就写什么属性，随意的很。特别是在调试样式的时候，还会把在浏览器调试的样式直接复制到随机的位置。")]),t._v(" "),r("p",[t._v("虽然知道浏览器的回流和重绘都会影响渲染的性能，但是仅仅停留在了操作样式的时候，也没怎么考虑在初始写 CSS 的时候顺序。")]),t._v(" "),r("p",[t._v("于是好好的学习了一下。")]),t._v(" "),r("h2",{attrs:{id:"css-的书写顺序"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#css-的书写顺序"}},[t._v("#")]),t._v(" CSS 的书写顺序")]),t._v(" "),r("ul",[r("li",[t._v("定位属性：position，z-index，display，float， left， right， top， bottom，clear，clip，overflow…")]),t._v(" "),r("li",[t._v("尺寸属性：width，height，margin，padding，border，flex…")]),t._v(" "),r("li",[t._v("文字样式：font，color…")]),t._v(" "),r("li",[t._v("背景属性：background…")]),t._v(" "),r("li",[t._v("文本属性：text-align，vertical-align，text-indent，text-decoration，letter-spacing，text-overflow，word-break…")]),t._v(" "),r("li",[t._v("CSS3 属性：animation，transition，box-shadow，border-radius…")])]),t._v(" "),r("h2",{attrs:{id:"why"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#why"}},[t._v("#")]),t._v(" why？")]),t._v(" "),r("p",[t._v("正常我们都知道浏览器的渲染过程，就像下图\n"),r("img",{attrs:{src:"https://img-blog.csdnimg.cn/20210319094134969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ2Mjc4MDc=,size_16,color_FFFFFF,t_70",alt:"在这里插入图片描述"}}),t._v("\n浏览器的渲染总共分为 4 步：")]),t._v(" "),r("ol",[r("li",[t._v("解析 HTML 生成 DOM 树,解析 CSS 生成 CSSOM 规则树。")]),t._v(" "),r("li",[t._v("将 DOM 树与 CSSOM 规则树合并在一起生成渲染树。")]),t._v(" "),r("li",[t._v("遍历渲染树开始布局，计算每个节点的位置大小信息。")]),t._v(" "),r("li",[t._v("将渲染树每个节点绘制到屏幕。")])]),t._v(" "),r("p",[t._v("合理的书写 CSS 的顺序，主要作用在生成渲染树布局和计算大小的时候，让 renderTree 提前知道这个 dom 是在文档流里的还是脱离了文档流等，避免了渲染了前面各种属性之后，又发现需要脱离文档流，就又需要重新渲染 renderTree 等。")])])}),[],!1,null,null,null);e.default=a.exports}}]);