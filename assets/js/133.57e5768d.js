(window.webpackJsonp=window.webpackJsonp||[]).push([[133],{709:function(v,_,e){"use strict";e.r(_);var o=e(17),d=Object(o.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("p",[v._v("一个开放的，可交互的由开发者制定的 "),e("code",[v._v("JavaScript Promise")]),v._v(" 标准。")]),v._v(" "),e("p",[v._v("一个 "),e("code",[v._v("Promise")]),v._v(" 代表一个异步操作的最终结果。与 "),e("code",[v._v("Promise")]),v._v(" 交互的主要方式是通过它的 "),e("code",[v._v("then")]),v._v(" 方法，该 "),e("code",[v._v("then")]),v._v(" 方法注册了两个回调函数，用来接收 "),e("code",[v._v("Promise")]),v._v(" 的最终结果或者导致 "),e("code",[v._v("Promise")]),v._v(" 不能 "),e("code",[v._v("fulfilled")]),v._v("（已完成） 的原因。")]),v._v(" "),e("p",[v._v("本规范详细的列出 "),e("code",[v._v("then")]),v._v(" 方法的行为，为所有符合 "),e("code",[v._v("Promises/A+")]),v._v(" 规范的 "),e("code",[v._v("Promise")]),v._v(" 提供了一个可互操作的基础来定义 "),e("code",[v._v("then")]),v._v(" 方法。因此本规范是稳定的。尽管 "),e("code",[v._v("Promise/A+")]),v._v(" 组织可能会偶尔地通过一些较小的且向后兼容的修订，来解决新发现的一些边界情况。如果要进行大规模或者不兼容的更新，我们一定会经过仔细的考虑、讨论和测试。")]),v._v(" "),e("p",[v._v("从历史上来说，"),e("code",[v._v("Promises/A+")]),v._v(" 规范实际上是把之前 "),e("code",[v._v("Promises/A")]),v._v("规范中的建议变成了标准：扩展了原有规范约定俗成的行为，并删减了原规范的一些特例情况和有问题的部分")]),v._v(" "),e("p",[v._v("最后 "),e("code",[v._v("Promises/A+")]),v._v(" 规范不设计如何创建、解决和拒绝 "),e("code",[v._v("promise")]),v._v("，而是专注于提供一个可交互操作的  "),e("code",[v._v("then")]),v._v(" 方法。未来在其他相关规范中可能会提及。")]),v._v(" "),e("h2",{attrs:{id:"_1、术语"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、术语"}},[v._v("#")]),v._v(" 1、术语")]),v._v(" "),e("ol",[e("li",[v._v("“"),e("code",[v._v("promise")]),v._v("” 是一个拥有 "),e("code",[v._v("then")]),v._v(" 方法的 对象或者函数，它的行为符合本规范")]),v._v(" "),e("li",[v._v("“"),e("code",[v._v("thenable")]),v._v("” 是一个定义了 "),e("code",[v._v("then")]),v._v(" 方法的对象和函数")]),v._v(" "),e("li",[v._v("值（“"),e("code",[v._v("value")]),v._v("”） 是任何 "),e("code",[v._v("JavaScript")]),v._v(" 的合法值 (包括 "),e("code",[v._v("undefined")]),v._v(", "),e("code",[v._v("thenable")]),v._v(", 或者 "),e("code",[v._v("promise")]),v._v(").")]),v._v(" "),e("li",[v._v("异常（“"),e("code",[v._v("exception")]),v._v("”） 是使用 "),e("code",[v._v("throw")]),v._v(" 抛出的一个值")]),v._v(" "),e("li",[v._v("原因（“"),e("code",[v._v("reason")]),v._v("”）是一个 "),e("code",[v._v("promise")]),v._v(" 的拒绝原因")])]),v._v(" "),e("h2",{attrs:{id:"_2、要求"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2、要求"}},[v._v("#")]),v._v(" 2、要求")]),v._v(" "),e("h3",{attrs:{id:"_2-1、promise-的状态"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-1、promise-的状态"}},[v._v("#")]),v._v(" 2.1、"),e("code",[v._v("Promise")]),v._v(" 的状态")]),v._v(" "),e("p",[v._v("一个 "),e("code",[v._v("Promise")]),v._v(" 的当前状态必须是以下三种状态中的一种：等待（"),e("code",[v._v("pending")]),v._v("），完成（"),e("code",[v._v("fulfilled")]),v._v("）和拒绝（"),e("code",[v._v("rejected")]),v._v("）")]),v._v(" "),e("ol",[e("li",[v._v("当一个"),e("code",[v._v("promise")]),v._v("处于等待状态：\n"),e("ol",[e("li",[v._v("可以迁移到完成状态或者拒绝状态中的任意一个")])])]),v._v(" "),e("li",[v._v("当一个 "),e("code",[v._v("promise")]),v._v(" 处于完成状态\n"),e("ol",[e("li",[v._v("一定不能再迁移到其他状态")]),v._v(" "),e("li",[v._v("必须有一个值("),e("code",[v._v("value")]),v._v(")，而且一定不能再改变")])])]),v._v(" "),e("li",[v._v("当一个 "),e("code",[v._v("promise")]),v._v(" 处于拒绝状态\n"),e("ol",[e("li",[v._v("一定不能再迁移到其他状态")]),v._v(" "),e("li",[v._v("必须有一个原因（"),e("code",[v._v("reason")]),v._v("），而且一定不能再改变")])])])]),v._v(" "),e("p",[v._v("这里，“一定不能改变” 意味着 恒等 （例如 ===），但是并不意味着更深层次的不可变。")]),v._v(" "),e("h3",{attrs:{id:"_2-2、then-方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-2、then-方法"}},[v._v("#")]),v._v(" 2.2、Then 方法")]),v._v(" "),e("p",[v._v("一个 "),e("code",[v._v("promise")]),v._v(" 必须提供一个 "),e("code",[v._v("then")]),v._v(" 方法，来访问它当前的最终结果或者原因\n一个 "),e("code",[v._v("promise")]),v._v(" 的 "),e("code",[v._v("then")]),v._v(" 方法接收2个参数：\n"),e("code",[v._v("promise.then(onFulfilled,onRejected)")])]),v._v(" "),e("ol",[e("li",[e("code",[v._v("onFulfilled")]),v._v(" 和 "),e("code",[v._v("onRejected")]),v._v(" 都是可选参数:\n"),e("ol",[e("li",[v._v("如果 "),e("code",[v._v("onFulfilled")]),v._v(" 不是函数，那它必须被忽略")]),v._v(" "),e("li",[v._v("如果 "),e("code",[v._v("onRejected")]),v._v(" 不是函数，那它必须被忽略")])])]),v._v(" "),e("li",[v._v("如果 "),e("code",[v._v("onFulfilled")]),v._v(" 是一个函数:\n"),e("ol",[e("li",[v._v("它必须在 promise 状态变成完成（"),e("code",[v._v("fulfilled")]),v._v("）状态之后才会调用，并且"),e("code",[v._v("promise")]),v._v("的值是第一个参数")]),v._v(" "),e("li",[v._v("它一定不能在 promise 是完成（"),e("code",[v._v("fulfilled")]),v._v("）状态之前被调用")]),v._v(" "),e("li",[v._v("它一定不能被调用超过1次")])])]),v._v(" "),e("li",[v._v("如果 "),e("code",[v._v("onRejected")]),v._v(" 是一个函数\n"),e("ol",[e("li",[v._v("它必须在 "),e("code",[v._v("promise")]),v._v("状态变成拒绝（"),e("code",[v._v("rejected")]),v._v("）之后才会调用，并且"),e("code",[v._v("promise")]),v._v("的原因是第一个参数")]),v._v(" "),e("li",[v._v("它一定不能在 "),e("code",[v._v("promise")]),v._v(" 是拒绝（"),e("code",[v._v("rejected")]),v._v("）状态之前被调用")]),v._v(" "),e("li",[v._v("它一定不能被调用超过1次")])])]),v._v(" "),e("li",[e("code",[v._v("onFulfilled")]),v._v(" 和 "),e("code",[v._v("onRejected")]),v._v(" 只有在执行上下文栈仅包含平台代码的时候才会被调用 [3.1].")]),v._v(" "),e("li",[e("code",[v._v("onFulfilled")]),v._v(" 和 "),e("code",[v._v("onRejected")]),v._v(" 必须当作函数调用（例如，没有 "),e("code",[v._v("this")]),v._v("值） [3.2]")]),v._v(" "),e("li",[v._v("同一个 "),e("code",[v._v("promise")]),v._v(" 的 "),e("code",[v._v("then")]),v._v(" 方法可以多次调用\n"),e("ol",[e("li",[v._v("当"),e("code",[v._v("promise")]),v._v("是完成（"),e("code",[v._v("fulfilled")]),v._v("）状态，所有相应的"),e("code",[v._v("onFulfilled")]),v._v(" 回调必须按照他们初始调用"),e("code",[v._v("then")]),v._v("方法的顺序执行")]),v._v(" "),e("li",[v._v("当"),e("code",[v._v("promise")]),v._v("是拒绝（"),e("code",[v._v("rejected")]),v._v("）状态，所有相应的"),e("code",[v._v("onFulfilled")]),v._v(" 回调必须按照他们初始调用"),e("code",[v._v("then")]),v._v("方法的顺序执行.\n7."),e("code",[v._v("then")]),v._v(" 方法必须返回一个"),e("code",[v._v("promise")]),v._v("对象 [3.3].\n"),e("code",[v._v("promise2 = promise1.then(onFulfilled,onRejected);")])]),v._v(" "),e("li",[v._v("如果 "),e("code",[v._v("onFulfilled")]),v._v(" 或者 "),e("code",[v._v("onRejected")]),v._v(" 返回一个值 "),e("code",[v._v("x")]),v._v("，则运行下面的 "),e("code",[v._v("Promise")]),v._v(" 解决过程："),e("code",[v._v("[[Resolve]](promise2, x)")])]),v._v(" "),e("li",[v._v("如果"),e("code",[v._v("onFulfilled")]),v._v(" 或者"),e("code",[v._v("onRejected")]),v._v(" 抛出一个异常 "),e("code",[v._v("e")]),v._v(", "),e("code",[v._v("promise2")]),v._v(" 必须以 "),e("code",[v._v("e")]),v._v(" 为原因被拒绝.")]),v._v(" "),e("li",[v._v("如果 "),e("code",[v._v("onFulfilled")]),v._v(" 不是函数，并且 "),e("code",[v._v("promise1")]),v._v(" 是完成状态，那么"),e("code",[v._v("promise2")]),v._v("必须以"),e("code",[v._v("promise1")]),v._v("同样的值完成.")]),v._v(" "),e("li",[v._v("如果 "),e("code",[v._v("onReject")]),v._v(" 不是函数，并且 "),e("code",[v._v("promise1")]),v._v(" 是拒绝状态，那么"),e("code",[v._v("promise2")]),v._v("必须以"),e("code",[v._v("promise1")]),v._v("同样的值拒绝.")])])])]),v._v(" "),e("h3",{attrs:{id:"_2-3、promise-解决过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-3、promise-解决过程"}},[v._v("#")]),v._v(" 2.3、Promise 解决过程")]),v._v(" "),e("p",[v._v("Promise 的解决过程是一个抽象操作，需要一个 promise 和一个值来作为输入，我们将其表示为[[Resolve]](promise, x)。如果 x 有 then 方法且看上去像一个 Promise ，那它会尝试让 promise 接收x的状态，否则就用x的值来完成（fulfilled） promise。")]),v._v(" "),e("p",[v._v("这种"),e("code",[v._v("thenable")]),v._v("的特性使得 "),e("code",[v._v("Promise")]),v._v(" 的实现更具有通用性：只要其暴露出一个遵循 "),e("code",[v._v("Promise/A+")]),v._v(" 协议的 "),e("code",[v._v("then")]),v._v(" 方法即可；这同时也使遵循 "),e("code",[v._v("Promise/A+")]),v._v(" 规范的实现可以与那些不太规范但可用的实现能良好共存。")]),v._v(" "),e("p",[v._v("要运行"),e("code",[v._v("[[Resolve]](promise, x)")]),v._v("，需要执行如下步骤：")]),v._v(" "),e("ol",[e("li",[v._v("如果 "),e("code",[v._v("promise")]),v._v(" 和 "),e("code",[v._v("x")]),v._v(" 指向同一个对象，那用"),e("code",[v._v("TypeError")]),v._v("为原因拒绝"),e("code",[v._v("promise")])]),v._v(" "),e("li",[v._v("如果x是一个"),e("code",[v._v("promise")]),v._v("，那就让 "),e("code",[v._v("promise")]),v._v(" 接受"),e("code",[v._v("x")]),v._v("的状态 [3.4]:\n"),e("ol",[e("li",[v._v("如果"),e("code",[v._v("x")]),v._v("是"),e("code",[v._v("pending")]),v._v("状态，那"),e("code",[v._v("promise")]),v._v("必须保持"),e("code",[v._v("pending")]),v._v("状态直到"),e("code",[v._v("x")]),v._v("变成完成（fulfilled）或者拒绝（"),e("code",[v._v("rejected")]),v._v("）")]),v._v(" "),e("li",[v._v("如果"),e("code",[v._v("x")]),v._v("是完成态"),e("code",[v._v("fulfilled")]),v._v(", 那让"),e("code",[v._v("promise")]),v._v(" 用同样的值（"),e("code",[v._v("value")]),v._v("）完成.")]),v._v(" "),e("li",[v._v("如果"),e("code",[v._v("x")]),v._v("是拒绝态"),e("code",[v._v("rejected")]),v._v(", 那让"),e("code",[v._v("promise")]),v._v(" 用同样的原因（"),e("code",[v._v("reason")]),v._v("）拒绝")])])]),v._v(" "),e("li",[e("code",[v._v("x")]),v._v("为对象或者函数,\n"),e("ol",[e("li",[v._v("把 "),e("code",[v._v("x.then")]),v._v(" 赋值给 "),e("code",[v._v("then")]),v._v(". [3.5]")]),v._v(" "),e("li",[v._v("如果检索属性 "),e("code",[v._v("x.then")]),v._v(" 导致抛出了一个异常 "),e("code",[v._v("e")]),v._v("，用 "),e("code",[v._v("e")]),v._v(" 作为原因拒绝 "),e("code",[v._v("promise")]),v._v("。")]),v._v(" "),e("li",[v._v("如果"),e("code",[v._v("then")]),v._v("是一个函数，用"),e("code",[v._v("x")]),v._v("作为"),e("code",[v._v("this")]),v._v("调用它，第一个参数是 "),e("code",[v._v("resolvePromise")]),v._v(", 第二个参数是"),e("code",[v._v("rejectPromise")]),v._v(":\n"),e("ol",[e("li",[v._v("如果"),e("code",[v._v("resolvePromise")]),v._v("被一个值"),e("code",[v._v("y")]),v._v("调用，执行"),e("code",[v._v("[[Resolve]](promise, y)")]),v._v(".")]),v._v(" "),e("li",[v._v("如果 "),e("code",[v._v("rejectPromise")]),v._v(" 以原因 "),e("code",[v._v("r")]),v._v("为参数被调用，则以原因"),e("code",[v._v("r")]),v._v("拒绝 "),e("code",[v._v("promise")])]),v._v(" "),e("li",[v._v("如果 "),e("code",[v._v("resolvePromise")]),v._v(" 和 "),e("code",[v._v("rejectPromise")]),v._v(" 都被调用，或者被同一参数调用了多次，则优先采用第一次调用并剩下的调用都会被忽略")]),v._v(" "),e("li",[v._v("如果调用抛出异常 "),e("code",[v._v("e")]),v._v(" "),e("ol",[e("li",[v._v("如果 "),e("code",[v._v("resolvePromise")]),v._v(" 或者 "),e("code",[v._v("rejectPromise")]),v._v(" 已经被调用过了，那忽略它")]),v._v(" "),e("li",[v._v("用异常"),e("code",[v._v("e")]),v._v("为原因拒绝"),e("code",[v._v("promise")])])])])])]),v._v(" "),e("li",[v._v("如果"),e("code",[v._v("then")]),v._v("不是一个函数，用"),e("code",[v._v("x")]),v._v("完成"),e("code",[v._v("promise")])])])]),v._v(" "),e("li",[v._v("如果"),e("code",[v._v("x")]),v._v("不是一个对象或者数组，用"),e("code",[v._v("x")]),v._v("完成"),e("code",[v._v("promise")])])]),v._v(" "),e("p",[v._v("如果一个 "),e("code",[v._v("promise")]),v._v(" 被一个循环的 thenable 链中的对象完成，而 "),e("code",[v._v("[[Resolve]](promise, thenable)")]),v._v("的递归性质又使得其被再次调用，根据上面的算法将会导致无限递归。规范中并没有强制要求处理这种情况，但也鼓励实现者检测这样的递归是否存在，若检测到存在则用一个可识别的 "),e("code",[v._v("TypeError")]),v._v(" 为原因来拒绝 "),e("code",[v._v("promise")]),v._v("[3.6]。")]),v._v(" "),e("h2",{attrs:{id:"_3、注释"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3、注释"}},[v._v("#")]),v._v(" 3、注释")]),v._v(" "),e("ol",[e("li",[v._v("这里的平台代码是指引擎、环境以及 "),e("code",[v._v("promise")]),v._v(" 的实施代码。在实践中，要确保 "),e("code",[v._v("onFulfilled")]),v._v(" 和 "),e("code",[v._v("onRejected")]),v._v(" 两个参数异步执行，并且应该在 "),e("code",[v._v("then")]),v._v("方法被调用的那一轮事件循环之后的新执行栈中执行。这可以用如 "),e("code",[v._v("setTimeout")]),v._v(" 或 "),e("code",[v._v("setImmediate")]),v._v("这样的“宏任务”机制实现，或者用如"),e("code",[v._v("MutationObserver")]),v._v("或 "),e("code",[v._v("process.nextTick")]),v._v(" 这样的“微任务”机制实现。由于 "),e("code",[v._v("promise")]),v._v(" 的实施代码本身就是平台代码，故代码自身在处理在处理程序时可能已经包含一个任务调度队列")]),v._v(" "),e("li",[v._v("严格模式下，它们中的"),e("code",[v._v("this")]),v._v("将会是"),e("code",[v._v("undefined")]),v._v("；在非严格模式，"),e("code",[v._v("this")]),v._v("将会是全局对象")]),v._v(" "),e("li",[v._v("假如实现满足所有需求，可以允许 "),e("code",[v._v("promise2 === promise1")]),v._v("。每一个实现都应该记录是否能够产生"),e("code",[v._v("promise2 === promise1")]),v._v(" 以及什么情况下会出现 "),e("code",[v._v("promise2 === promise1")])]),v._v(" "),e("li",[v._v("总的来说，只有"),e("code",[v._v("x")]),v._v("来自于当前实现，才知道它是一个真正的"),e("code",[v._v("promise")]),v._v("。这条规则允许那些特例实现采用符合已知要求的"),e("code",[v._v("Promise")]),v._v("的状态")]),v._v(" "),e("li",[v._v("这个程序首先存储"),e("code",[v._v("x.then")]),v._v("的引用，之后测试和调用那个引用，这样避免了多次访问"),e("code",[v._v("x.then")]),v._v("属性。这种预防措施确保了该属性的一致性，因为访问者属性的值可能在俩次检索之间发生变化")]),v._v(" "),e("li",[v._v("实现不应该在"),e("code",[v._v("thenable")]),v._v("链的深度上做任意限制，并且假设超过那个任意限制将会无限递归。只有真正的循环才应该引发一个"),e("code",[v._v("TypeError")]),v._v("；如果遇到一个无限循环的"),e("code",[v._v("thenable")]),v._v("，永远执行递归是正确的行为")])])])}),[],!1,null,null,null);_.default=d.exports}}]);