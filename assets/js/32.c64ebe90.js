(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{609:function(T,e,n){"use strict";n.r(e);var P=n(17),t=Object(P.a)({},(function(){var T=this,e=T.$createElement,n=T._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":T.$parent.slotKey}},[n("p",[T._v("一、什么是HTTP2.0\n1.1 基本信息\nHTTP2.0就是超文本传输协议第2版，是HTTP协议的第二个主要版本，之前有过HTTP1.0和1999年发布的HTTP1.1版本，主要是基于SPDY协议。")]),T._v(" "),n("p",[T._v("HTTP2.0就是在兼容HTTP/1.1在请求方法、状态码乃至URI和绝大多数HTTP头部字段等，减少网络延迟，提高浏览器的页面加载速度。")]),T._v(" "),n("p",[T._v("HTTP2.0的主要目标是通过支持完整的请求与响应复用来减少延迟，通过有效压缩 HTTP 标头字段将协议开销降至最低，同时增加对请求优先级和服务器推送的支持。大幅提升web性能")]),T._v(" "),n("p",[T._v("1.2 SPDY协议\nSPDY（读作“SPeeDY”）是Google开发的基于TCP的会话层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验。SPDY并不是一种用于替代HTTP的协议，而是对HTTP协议的增强。新协议的功能包括数据流的多路复用、请求优先级以及HTTP报头压缩。\n原理：")]),T._v(" "),n("ul",[n("li",[T._v("在SSL层上增加一个SPDY会话层，以在一个TCP连接中实现并发流。")]),T._v(" "),n("li",[T._v("通常的HTTP GET和POST格式仍然是一样的；然而SPDY为编码和传输数据设计了一个新的帧格式。")]),T._v(" "),n("li",[T._v("流是双向的，可以在客户端和服务器端启动")]),T._v(" "),n("li",[T._v("SPDY旨在通过基本（始终启用）和高级（可选启用）功能实现更低的延迟。\n"),n("img",{attrs:{src:"https://img-blog.csdnimg.cn/20200709095731715.png",alt:"在这里插入图片描述"}})])]),T._v(" "),n("p",[T._v("二、HTTP2.0的特点\n2.1 二进制传输\n"),n("img",{attrs:{src:"https://img-blog.csdnimg.cn/20200709100218590.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ2Mjc4MDc=,size_16,color_FFFFFF,t_70",alt:"在这里插入图片描述"}})]),T._v(" "),n("p",[T._v("HTTP/2 所有性能增强的核心在于新的二进制分帧层，它定义了如何封装 HTTP 消息并在客户端与服务器之间传输。\n这里所谓的“层”，指的是位于套接字接口与应用可见的高级 HTTP API 之间一个经过优化的新编码机制：HTTP 的语义（包括各种动词、方法、标头）都不受影响，不同的是传输期间对它们的编码方式变了。 HTTP/1.x 协议以换行符作为纯文本的分隔符，而 HTTP/2 将所有传输的信息分割为更小的消息和帧，并采用二进制格式对它们编码。\n这样一来，客户端和服务器为了相互理解，都必须使用新的二进制编码机制：HTTP/1.x 客户端无法理解只支持 HTTP/2 的服务器，反之亦然。 不过不要紧，现有的应用不必担心这些变化，因为客户端和服务器会替我们完成必要的分帧工作。\n2.2 多路复用\nHTTP2.0中，有两个概念非常重要：帧（frame）和流（stream）。\n帧是最小的数据单位，每个帧会标识出该帧属于哪个流，流是多个帧组成的数据流。\n所谓多路复用，即在一个TCP连接中存在多个流，即可以同时发送多个请求，对端可以通过帧中的表示知道该帧属于哪个请求。在客户端，这些帧乱序发送，到对端后再根据每个帧首部的流标识符重新组装。通过该技术，可以避免HTTP旧版本的队头阻塞问题，极大提高传输性能。")]),T._v(" "),n("p",[n("img",{attrs:{src:"https://img-blog.csdnimg.cn/20200709100229423.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ2Mjc4MDc=,size_16,color_FFFFFF,t_70#pic_center",alt:"在这里插入图片描述"}}),T._v("\nHTTP/2 中的新二进制分帧层解决了 HTTP/1.x 中存在的队首阻塞问题，也消除了并行处理和发送请求及响应时对多个连接的依赖。 结果，应用速度更快、开发更简单、部署成本更低。")]),T._v(" "),n("p",[T._v("2.3 数据流优先级\n将 HTTP 消息分解为很多独立的帧之后，我们就可以复用多个数据流中的帧，客户端和服务器交错发送和传输这些帧的顺序就成为关键的性能决定因素。 为了做到这一点，HTTP/2 标准允许每个数据流都有一个关联的权重和依赖关系：")]),T._v(" "),n("ul",[n("li",[T._v("可以向每个数据流分配一个介于 1 至 256 之间的整数。")]),T._v(" "),n("li",[T._v("每个数据流与其他数据流之间可以存在显式依赖关系。\n数据流依赖关系和权重的组合让客户端可以构建和传递“优先级树”，表明它倾向于如何接收响应。 反过来，服务器可以使用此信息通过控制 CPU、内存和其他资源的分配设定数据流处理的优先级，在资源数据可用之后，带宽分配可以确保将高优先级响应以最优方式传输至客户端。\n2.4 Header压缩\n在HTTP1.0中，我们使用文本的形式传输header，在header中携带cookie的话，每次都需要重复传输几百到几千的字节，这着实是一笔不小的开销。\n在HTTP2.0中，我们使用了HPACK（HTTP2头部压缩算法）压缩格式对传输的header进行编码，减少了header的大小。并在两端维护了索引表，用于记录出现过的header，后面在传输过程中就可以传输已经记录过的header的键名，对端收到数据后就可以通过键名找到对应的值。")])]),T._v(" "),n("p",[T._v("2.5 服务端推送\n在HTTP2.0中，服务端可以在客户端某个请求后，主动推送其他资源。\n可以想象一下，某些资源客户端是一定会请求的，这时就可以采取服务端push的技术，提前给客户端推送必要的资源，就可以相对减少一点延迟时间。在浏览器兼容的情况下也可以使用prefetch。")]),T._v(" "),n("p",[T._v("2.6 更安全\nHTTP2.0使用了tls的拓展ALPN做为协议升级，除此之外，HTTP2.0对tls的安全性做了近一步加强，通过黑名单机制禁用了几百种不再安全的加密算法。")]),T._v(" "),n("p",[T._v("三、发展状态\nHTTP/2标准于2015年5月以RFC 7540正式发表。HTTP/2的标准化工作由Chrome、Opera、Firefox、Internet Explorer 11、Safari、Amazon Silk及Edge等浏览器提供支持。多数主流浏览器已经在2015年底支持了该协议。2015年9月，Google 宣布了计划，移除对SPDY的支持，拥抱 HTTP/2，并将在Chrome 51中生效。")])])}),[],!1,null,null,null);e.default=t.exports}}]);