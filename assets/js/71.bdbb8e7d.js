(window.webpackJsonp=window.webpackJsonp||[]).push([[71],{646:function(n,o,t){"use strict";t.r(o);var e=t(17),l=Object(e.a)({},(function(){var n=this,o=n.$createElement,t=n._self._c||o;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("ul",[t("li",[n._v("ES6 模块输出的是值的引用，CommonJS 模块输出的是一个值的拷贝")]),n._v(" "),t("li",[n._v("ES6 模块是编译时输出接口，CommonJS 模块是运行时加载。")]),n._v(" "),t("li",[n._v("ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。而 CommonJS 加载的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成。")])]),n._v(" "),t("p",[n._v("ES6 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。")]),n._v(" "),t("p",[n._v("es6 {\n　　export : '可以输出多个，输出方式为 {}' ，\n　　export default : ' 只能输出一个 ，可以与 export 同时输出，但是不建议这么做'，\n　　解析阶段确定对外输出的接口，解析阶段生成接口，\n　　模块不是对象，加载的不是对象，\n　　可以单独加载其中的某个接口（方法），\n　　静态分析，动态引用，输出的是值的引用，值改变，引用也改变，即原来模块中的值改变则该加载的值也改变，\n　　this 指向 undefined\n}\ncommonJS {\n　　module.exports = ... : '只能输出一个，且后面的会覆盖上面的' ，\n　　exports. ... : ' 可以输出多个'，\n　　运行阶段确定接口，运行时才会加载模块，\n　　模块就是对象，加载的是该对象，\n　　加载的是整个模块，即将所有的接口全部加载进来，\n　　输出的是值的拷贝，即原来模块中的值改变不会影响已经加载的该值，\n　　this 指向当前模块\n}")])])}),[],!1,null,null,null);o.default=l.exports}}]);