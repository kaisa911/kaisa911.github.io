<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[堆排序]]></title>
    <url>%2F2018%2F05%2F21%2F%E5%A0%86%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] &gt;= A[i]。在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶。 具体算法描述如下： 1、将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；2、将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn), 且满足R[1,2…n-1]&lt;=R[n]；3、由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。 时间复杂度：最好：O(nlog2n)，最坏：O(nlog2n)，平均：O(nlog2n)。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/*方法说明：堆排序@param array 待排序数组*/ const heapSort = (arr) =&gt; &#123; if (Object.prototype.toString.call(array).slice(8, -1) === 'Array') &#123; //建堆 let heapSize = array.length, temp; for (let i = Math.floor(heapSize / 2); i &gt;= 0; i--) &#123; heapify(array, i, heapSize); &#125; //堆排序 for (let j = heapSize - 1; j &gt;= 1; j--) &#123; temp = array[0]; array[0] = array[j]; array[j] = temp; heapify(array, 0, --heapSize); &#125; &#125; else &#123; return 'array is not an Array!'; &#125;&#125;/*方法说明：维护堆的性质@param arr 数组@param x 数组下标@param len 堆大小*/const heapify = (arr, x, len) =&gt; &#123; if (Object.prototype.toString.call(arr).slice(8, -1) === 'Array' &amp;&amp; typeof x === 'number')&#123; let l = 2 * x, r = 2 * x + 1, largest = x, temp; if (l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) &#123; largest = l; &#125; if (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) &#123; largest = r; &#125; if (largest != x) &#123; temp = arr[x]; arr[x] = arr[largest]; arr[largest] = temp; heapify(arr, largest, len); &#125; &#125; else &#123; return 'arr is not an Array or x is not a number!'; &#125;&#125;]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序]]></title>
    <url>%2F2018%2F05%2F19%2F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。 把长度为n的输入序列分成两个长度为n/2的子序列；对这两个子序列分别采用归并排序；将两个排序好的子序列合并成一个最终的排序序列。 归并操作的工作原理如下：第一步：申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列第二步：设定两个指针，最初位置分别为两个已经排序序列的起始位置第三步：比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置重复步骤3直到某一指针超出序列尾将另一序列剩下的所有元素直接复制到合并序列尾 最佳情况：T(n) = O(n)最差情况：T(n) = O(nlogn)平均情况：T(n) = O(nlogn) 123456789101112131415161718const mergeSort = (arr) =&gt; &#123; let len = arr.lenght; if (len &lt; 2) &#123; return arr; &#125; let m = (len &gt;&gt; 1), //通过位运算符，将len取为一半。 left = array.slice(0, m), right = array.slice(m); //拆分为两个子数组 return merge(mergeSort(left), mergeSort(right));//子数组继续递归拆分,然后再合并&#125;const merge = (left, right) =&gt; &#123; //合并两个子数组 let res = []; while (left.length &amp;&amp; right.length) &#123; let item = left[0] &lt;= right[0] ? left.shift() : right.shift();//注意:判断的条件是小于或等于,如果只是小于,那么排序将不稳定. result.push(item); &#125; return result.concat(left.length ? left : right);&#125;]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选择排序]]></title>
    <url>%2F2018%2F05%2F19%2F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法。 简单选择排序的基本思想：第1趟，在待排序记录r[1]~r[n]中选出最小的记录，将它与r[1]交换；第2趟，在待排序记录r[2]~r[n]中选出最小的记录，将它与r[2]交换；以此类推，第i趟在待排序记录r[i]~r[n]中选出最小的记录，将它与r[i]交换，使有序序列不断增长直到全部排序完毕。 最佳情况：T(n) = O(n^2)最差情况：T(n) = O(n^2)平均情况：T(n) = O(n^2) 1234567891011const selectSort = (arr) =&gt; &#123; let len = arr.length, min; for (let i = 0; i &lt; len - 1; i++) &#123; min = i; for (let j = i + 1; j &lt; len; j++)&#123; arr[j] &lt; arr[min] &amp;&amp; (min = j); &#125; min != i &amp;&amp; swap(i,min,arr); &#125; return arr&#125;]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序]]></title>
    <url>%2F2018%2F05%2F19%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[快速排序（Quicksort）是对冒泡排序的一种改进。快速排序的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 一趟快速排序的算法是：（1）在数据集之中，选择一个元素作为”基准”（pivot）。（2）所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。（3）对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。 最佳情况：T(n) = O(nlogn)最差情况：T(n) = O(n2)平均情况：T(n) = O(nlogn) 12345678910111213141516const quickSort = (arr) =&gt; &#123; if (arr.length &lt;= 1) &#123; return arr; &#125; let pivotIndex = arr.length &gt;&gt; 1; console.log(pivotIndex); let pivot = arr.splice(pivotIndex, 1)[0]; let left = []; let right = []; for (let i = 0; i &lt; arr.length; i++)&#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; return quickSort(left).concat([pivot], quickSort(right));&#125;]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序]]></title>
    <url>%2F2018%2F05%2F19%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。 冒泡排序算法的运作如下：（从后往前）比较相邻的元素。如果第一个比第二个大，就交换他们两个。对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。针对所有的元素重复以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 时间复杂度：冒泡排序最好的时间复杂度为O(n)。冒泡排序的最坏时间复杂度为O(n^2)。冒泡排序总的平均时间复杂度为O(n^2)。 12345678910111213const bubbleSort = (arr) =&gt; &#123; let len = arr.length; for (let i = 0; i &lt; len - 1; i++) &#123; for (let j = 0; j &lt; len - 1 - j; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; let temp = arr[j+1]; arr[j+1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; return arr;&#125;]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax实现]]></title>
    <url>%2F2018%2F05%2F16%2Fajax%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[Q1: 何谓ajax，它有何优点？A1:AJAX = 异步 JavaScript 和 XML。AJAX 是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据 交换，AJAX 可以使网页实现异步更新 Q2:ajax 如何实现？A2:步骤：(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象. (2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息. (3)设置响应HTTP请求状态变化的函数. (4)发送HTTP请求. (5)获取异步调用返回的数据. (6)使用JavaScript和DOM实现局部刷新. 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;html&gt; &lt;head&gt; &lt;title&gt;AJAX实例&lt;/title&gt; &lt;script language="javascript" type="text/javascript"&gt; var xmlHttpRequest; //定义一个变量用于存放XMLHttpRequest对象 //定义一个用于创建XMLHttpRequest对象的函数 function createXMLHttpRequest()&#123; if(window.ActiveXObject)&#123; //IE浏览器的创建方式 xmlHttpRequest = new ActiveXObject("Microsoft.XMLHTTP"); &#125;else if(windew.XMLHttpRequest)&#123; //Netscape浏览器中的创建方式 xmlHttpRequest = new XMLHttpRequest(); &#125; &#125; //响应HTTP请求状态变化的函数 function httpStateChange()&#123; //判断异步调用是否完成 if(xmlHttpRequest.readyState == 4)&#123; //判断异步调用是否成功,如果成功开始局部更新数据 if(xmlHttpRequest.status == 200||xmlHttpRequest.status == 0)&#123; //查找节点 var node = document.getElementById("myDIv"); //更新数据 node.firstChild.nodeValue = xmlHttpRequest .responseText; &#125;else&#123; //如果异步调用未成功,弹出警告框,并显示出错信息 alert("异步调用出错/n返回的HTTP状态码为:"+xmlHttpRequest.status + "/n返回的HTTP状态信息为:" + xmlHttpRequest.statusText); &#125; &#125; &#125; //异步调用服务器段数据 function getData(name,value)&#123; //创建XMLHttpRequest对象 createXMLHttpRequest(); if(xmlHttpRequest!=null)&#123; //创建HTTP请求 xmlHttpRequest.open("get","ajax.text",true) //设置HTTP请求状态变化的函数 xmlHttpRequest.onreadystatechange = httpStateChange; //发送请求 xmlHttpRequest.send(null); &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="myDiv"&gt;原数据&lt;/div&gt; &lt;input type = "button" value = "更新数据" onclick = "getData()"&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>Demo练习</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域问题探究]]></title>
    <url>%2F2018%2F05%2F15%2F%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E6%8E%A2%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[Q1: 什么是跨域？A1: 一个域上加载的脚本获取或操作另一个域上的文档属性，是指a页面想获取b页面资源，如果a、b页面的协议、域名、端口、子域名不同，或是a页面为ip地址，b页面为域名地址，所进行的访问行动都是跨域的。而浏览器为了安全问题一般都限制了跨域访问，也就是不允许跨域请求资源。 Q2: 怎么算跨域？A2: Uri 说明 是否跨域 http://www.cnblogs.com/a.js http://www.a.com/b.js 不同域名 是 http://www.a.com/lab/a.js http://www.a.com/script/b.js 同域名下不同文件 否 http://www.a.com:8000/a.js http://www.a.com/b.js 同域名下不同端口 是 http://www.a.com/a.js s https://www.a.com/b.js 同域名 不同协议 是 http://www.a.com/a.js http://70.32.92.74/b.jss 域名和域名对应ip 是 http://www.a.com/a.js http://script.a.com/b.js 主域名相同 子域名不同 是（cookie不可访问） http://www.a.com/a.js http://a.com/b.js 同一域名，不同二级域名（同上） 是 Q3: 什么是浏览器的同源策略？A3: 计算机的本地与Web是不同的层面，Web世界（通常称为Internet域）运行在浏览器上，而被限制了直接进行本地数据（通常称为本地域）的读写。同源策略是众多安全策略的一个，是Web层面上的策略，同源策略规定：不同域的客户端脚本在没明确授权的情况下，不能读写对方的资源。 Q4: 怎么解决跨域？A4: 有那么几种方法可以来解决跨域：1、Jsonp 需要目标服务器配合一个callback函数，但是注意JSONP只支持GET请求，不支持POST请求。 123456789101112131415&lt;script type="text/javascript" src="jquery.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $.ajax(&#123; url: api.testURI, dataType:'jsonp', data:'', jsonp:'callback', success:function(result) &#123; for(var i in result) &#123; alert(i+":"+result[i]);//循环输出a:1,b:2,etc. &#125; &#125;, timeout:3000 &#125;); &lt;/script&gt; 2、通过修改document.domain来跨子域将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域。主域相同的使用document.domain 3、使用window.name来进行跨域 12345window.name = data; //接着，子窗口跳回一个与主窗口同域的网址。 location = 'http://parent.url.com/xxx.html'; //然后，主窗口就可以读取子窗口的window.name了 var data = document.getElementById('iframe').contentWindow.name; 4、通过CORS解决AJAX跨域 12345678910111213141516171819function test() &#123; $.ajax(&#123; url: api.testURI, type: "get", async: false, data:&#123; "id":1 &#125;, dataType:"json", withCredentials:true, success: function(data)&#123; alert(data); alert(data.code); &#125;, error: function()&#123; alert('fail'); &#125; &#125;)&#125; 5.服务器设置Access-Control-Allow-Origin实现跨域 123456app.all("*", function(req, res, next) &#123; const host = req.headers.origin; res.header('Access-Control-Allow-Origin', host) //res.header('Access-Control-Allow-Origin', *) next();&#125;);]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[webpack 配置理解]]></title>
    <url>%2F2018%2F05%2F15%2Fwebpack-%E9%85%8D%E7%BD%AE%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 webpack 4 虽然已经不需要引入一个配置文件。但是，webpack在实际的应用中还是会配置很多东西。下面就是对webpack的配置分析：从webpack文档中找出路配置，进行了分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355const path = require('path');module.exports = &#123; mode: "production", // "production" | "development" | "none" // webpack有三种模式：生产模式，开发模式，none；选择模式告诉webpack相应地使用其内置优化。 entry: "./app/entry", // string | object | array // webpack的入口文件，这里应用程序开始执行 // webpack 开始打包 output: &#123; // webpack 如何输出结果的相关选项 path: path.resolve(__dirname, "dist"), // string // 所有输出文件的目标路径 // 必须是绝对路径（使用 Node.js 的 path 模块） filename: "bundle.js", // string // 「入口分块(entry chunk)」的文件名模板（出口分块？） publicPath: "/assets/", // string // 输出解析文件的目录，url 相对于 HTML 页面 library: "MyLibrary", // string, // 导出库(exported library)的名称 libraryTarget: "umd", // 通用模块定义 // 导出库(exported library)的类型 /* 高级输出配置 */ pathinfo: true, // boolean // 在生成代码时，引入相关的模块、导出、请求等有帮助的路径信息。 chunkFilename: "[id].js", chunkFilename: "[chunkhash].js", // 长效缓存(/guides/caching) // 「附加分块(additional chunk)」的文件名模板 jsonpFunction: "myWebpackJsonp", // string // 用于加载分块的 JSONP 函数名 sourceMapFilename: "[file].map", // string sourceMapFilename: "sourcemaps/[file].map", // string // 「source map 位置」的文件名模板 devtoolModuleFilenameTemplate: "webpack:///[resource-path]", // string // 「devtool 中模块」的文件名模板 devtoolFallbackModuleFilenameTemplate: "webpack:///[resource-path]?[hash]", // string // 「devtool 中模块」的文件名模板（用于冲突） umdNamedDefine: true, // boolean // 在 UMD 库中使用命名的 AMD 模块 crossOriginLoading: "use-credentials", // 枚举 crossOriginLoading: "anonymous", crossOriginLoading: false, // 指定运行时如何发出跨域请求问题 /* 专家级输出配置（自行承担风险） */ devtoolLineToLine: &#123; test: /\.jsx$/ &#125;, // 为这些模块使用 1:1 映射 SourceMaps（快速） hotUpdateMainFilename: "[hash].hot-update.json", // string // 「HMR 清单」的文件名模板 hotUpdateChunkFilename: "[id].[hash].hot-update.js", // string // 「HMR 分块」的文件名模板 sourcePrefix: "\t", // string // 包内前置式模块资源具有更好可读性 &#125;, module: &#123; // 关于模块配置 rules: [ // 模块规则（配置 loader、解析器等选项） &#123; test: /\.jsx?$/, include: [ path.resolve(__dirname, "app") ], exclude: [ path.resolve(__dirname, "app/demo-files") ], // 这里是匹配条件，每个选项都接收一个正则表达式或字符串 // test 和 include 具有相同的作用，都是必须匹配选项 // exclude 是必不匹配选项（优先于 test 和 include） // 最佳实践： // - 只在 test 和 文件名匹配 中使用正则表达式 // - 在 include 和 exclude 中使用绝对路径数组 // - 尽量避免 exclude，更倾向于使用 include issuer: &#123; test, include, exclude &#125;, // issuer 条件（导入源） enforce: "pre", enforce: "post", // 标识应用这些规则，即使规则覆盖（高级选项） loader: "babel-loader", // 应该应用的 loader，它相对上下文解析 // 为了更清晰，`-loader` 后缀在 webpack 2 中不再是可选的 // 查看 webpack 1 升级指南。 options: &#123; presets: ["es2015"] &#125;, // loader 的可选项 &#125;, &#123; test: /\.html$/, test: "\.html$" use: [ // 应用多个 loader 和选项 "htmllint-loader", &#123; loader: "html-loader", options: &#123; /* ... */ &#125; &#125; ] &#125;, &#123; oneOf: [ /* rules */ ] &#125;, // 只使用这些嵌套规则之一 &#123; rules: [ /* rules */ ] &#125;, // 使用所有这些嵌套规则（合并可用条件） &#123; resource: &#123; and: [ /* 条件 */ ] &#125; &#125;, // 仅当所有条件都匹配时才匹配 &#123; resource: &#123; or: [ /* 条件 */ ] &#125; &#125;, &#123; resource: [ /* 条件 */ ] &#125;, // 任意条件匹配时匹配（默认为数组） &#123; resource: &#123; not: /* 条件 */ &#125; &#125; // 条件不匹配时匹配 ], /* 高级模块配置（点击展示） */ noParse: [ /special-library\.js$/ ], // 不解析这里的模块 unknownContextRequest: ".", unknownContextRecursive: true, unknownContextRegExp: /^\.\/.*$/, unknownContextCritical: true, exprContextRequest: ".", exprContextRegExp: /^\.\/.*$/, exprContextRecursive: true, exprContextCritical: true, wrappedContextRegExp: /.*/, wrappedContextRecursive: true, wrappedContextCritical: false, // 指定动态请求的默认行为 &#125;, resolve: &#123; // 解析模块请求的选项 // （不适用于对 loader 解析） modules: [ "node_modules", path.resolve(__dirname, "app") ], // 用于查找模块的目录 extensions: [".js", ".json", ".jsx", ".css"], // 使用的扩展名 alias: &#123; // 模块别名列表 "module": "new-module", // 起别名："module" -&gt; "new-module" 和 "module/path/file" -&gt; "new-module/path/file" "only-module$": "new-module", // 起别名 "only-module" -&gt; "new-module"，但不匹配 "only-module/path/file" -&gt; "new-module/path/file" "module": path.resolve(__dirname, "app/third/module.js"), // 起别名 "module" -&gt; "./app/third/module.js" 和 "module/file" 会导致错误 // 模块别名相对于当前上下文导入 &#125;, /* 可供选择的别名语法（点击展示） */ alias: [ &#123; name: "module", // 旧的请求 alias: "new-module", // 新的请求 onlyModule: true // 如果为 true，只有 "module" 是别名 // 如果为 false，"module/inner/path" 也是别名 &#125; ], /* 高级解析选项（点击展示） */ symlinks: true, // 遵循符号链接(symlinks)到新位置 descriptionFiles: ["package.json"], // 从 package 描述中读取的文件 mainFields: ["main"], // 从描述文件中读取的属性 // 当请求文件夹时 aliasFields: ["browser"], // 从描述文件中读取的属性 // 以对此 package 的请求起别名 enforceExtension: false, // 如果为 true，请求必不包括扩展名 // 如果为 false，请求可以包括扩展名 moduleExtensions: ["-module"], enforceModuleExtension: false, // 类似 extensions/enforceExtension，但是用模块名替换文件 unsafeCache: true, unsafeCache: &#123;&#125;, // 为解析的请求启用缓存 // 这是不安全，因为文件夹结构可能会改动 // 但是性能改善是很大的 cachePredicate: (path, request) =&gt; true, // 用于选择缓存请求的谓词函数 plugins: [ // ... ] // 应用于解析器的附加插件 &#125;, performance: &#123; hints: "warning", // or "error" or false maxAssetSize: 200000, // 整数类型（以字节为单位） maxEntrypointSize: 400000, // 整数类型（以字节为单位） assetFilter: function(assetFilename) &#123; // 提供资源文件名的断言函数 return assetFilename.endsWith('.css') || assetFilename.endsWith('.js'); &#125; &#125;, devtool: "source-map", // // devtool: "inline-source-map", // 嵌入到源文件中 // devtool: "eval-source-map", // 将 SourceMap 嵌入到每个模块中 // devtool: "hidden-source-map", // SourceMap 不在源文件中引用 // devtool: "cheap-source-map", // 没有模块映射(module mappings)的 SourceMap 低级变体(cheap-variant) // devtool: "cheap-module-source-map", // 有模块映射(module mappings)的 SourceMap 低级变体 // devtool: "eval", // 没有模块映射，而是命名模块。以牺牲细节达到最快。 // 通过在浏览器调试工具(browser devtools)中添加元信息(meta info)增强调试 // 牺牲了构建速度的 `source-map' 是最详细的。 context: __dirname, // string（绝对路径！） // webpack 的主目录 // entry 和 module.rules.loader 选项 // 相对于此目录解析 target: "web", // 默认 // 包(bundle)应该运行的环境 // 更改 块加载行为(chunk loading behavior) 和 可用模块(available module) externals: ["react", /^@angular\//], // 不要遵循/打包这些模块，而是在运行时从环境中请求他们 stats: "errors-only", // 精确控制要显示的 bundle 信息 devServer: &#123; proxy: &#123; // 代理URL到后端开发服务器 '/api': 'http://localhost:3000' auth: false //授权 changeOrigin: true //跨域 &#125;, contentBase: path.join(__dirname, 'public'), // boolean | string | array, 静态文件位置 compress: true, // 启用gzip压缩 historyApiFallback: true, // 提供重定向响应 404 -- 如果使用 hot: true, // 热加载 https: false, // 是否是https noInfo: true, // 只有错误并警告热重新加载 // ... &#125;, plugins: [ // ... ], // 附加插件列表 /* 高级配置（点击展示） */ resolveLoader: &#123; /* 等同于 resolve */ &#125; // 独立解析选项的 loader parallelism: 1, // number // 限制并行处理模块的数量 profile: true, // boolean // 捕获时机信息 bail: true, //boolean // 在第一个错误出错时抛出，而不是无视错误。 cache: false, // boolean // 禁用/启用缓存 watch: true, // boolean // 启用观察 watchOptions: &#123; aggregateTimeout: 1000, // in ms // 将多个更改聚合到单个重构建(rebuild) poll: true, poll: 500, // 间隔单位 ms // 启用轮询观察模式 // 必须用在不通知更改的文件系统中 // 即 nfs shares（译者注：Network FileSystem，最大的功能就是可以透過網路，讓不同的機器、不同的作業系統、可以彼此分享個別的檔案 ( share file )） &#125;, node: &#123; // 在非node环境下填充或模拟运行node环境 console: false, // boolean | "mock" global: true, // boolean | "mock" process: true, // boolean __filename: "mock", // boolean | "mock" __dirname: "mock", // boolean | "mock" Buffer: true, // boolean | "mock" setImmediate: true // boolean | "mock" | "empty" &#125;, recordsPath: path.resolve(__dirname, "build/records.json"), recordsInputPath: path.resolve(__dirname, "build/records.json"), recordsOutputPath: path.resolve(__dirname, "build/records.json"), // TODO&#125; Webpack 的工作流从 context 文件夹开始（框架内没有配置，那就默认为 ‘’）查找 entry 对应的文件(找到文件之后) 读取文件内容. 每当遇到 import (ES6) 或者 require() (Node) 依赖项时, 它会解析这些代码, 并且打包到最终构建里. 接着它会不断递归搜索实际需要的依赖项, 直到它到达了“树”的底部递归完所有依赖之后, Webpack 会将所有东西打包到 output.path 对应的目录, 并将 output.filename 的值作为最终的资源名 ([name] 表示使用 entry 项的 key)]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在页面中获取图片的尺寸]]></title>
    <url>%2F2018%2F05%2F14%2F%E5%9C%A8%E9%A1%B5%E9%9D%A2%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%9B%BE%E7%89%87%E7%9A%84%E5%B0%BA%E5%AF%B8%2F</url>
    <content type="text"><![CDATA[在js中写了获取图片的高度，却发现高度都是0.这是因为js运行的时候，图片还没有加载好所以在获取图片高度的时候，要用window.onload在图片都加载好了之后获取就可以了。 1234window.onload = function () &#123; var imgHeight = $(".bgImg").height() console.log(imgHeight);&#125;]]></content>
      <categories>
        <category>bug汇总</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery监控浏览器大小变化]]></title>
    <url>%2F2018%2F05%2F14%2Fjquery%E7%9B%91%E6%8E%A7%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A4%A7%E5%B0%8F%E5%8F%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425var screenWidth = window.screen.width;$(window).resize(function () &#123;//当浏览器大小变化时 if($(window).width()!== screenWidth)&#123; //history.go(0) &#125;&#125;);//监控浏览器旋转function orientationChange() &#123; switch (window.orientation) &#123; case 0: //history.go(0) break; case -90: //history.go(0) break; case 90: // history.go(0) break; case 180: //history.go(0) break; &#125;&#125;window.addEventListener('orientationchange', orientationChange);]]></content>
      <categories>
        <category>Demo练习</category>
      </categories>
      <tags>
        <tag>Jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设置overflow：hidden导致相邻行内元素向下偏移的问题]]></title>
    <url>%2F2018%2F05%2F14%2F%E8%AE%BE%E7%BD%AEoverflow%EF%BC%9Ahidden%E5%AF%BC%E8%87%B4%E7%9B%B8%E9%82%BB%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E5%90%91%E4%B8%8B%E5%81%8F%E7%A7%BB%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[123456&lt;!-- html --&gt;&lt;div&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt;&lt;/div&gt; 1234567/* CSS */div span&#123; display:inline-block;&#125;div span:nth(0)&#123; overflow:hidden;&#125; 这样设置之后，后面的两个span会向下偏移一定距离实际上就是inline-block元素的默认baseline和其下外边沿的距离。常用的解决方法是为上述inline-block元素添加vertical-align: bottom。]]></content>
      <categories>
        <category>bug汇总</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何去掉两个span间的间距]]></title>
    <url>%2F2018%2F05%2F14%2F%E5%A6%82%E4%BD%95%E5%8E%BB%E6%8E%89%E4%B8%A4%E4%B8%AAspan%E9%97%B4%E7%9A%84%E9%97%B4%E8%B7%9D%2F</url>
    <content type="text"><![CDATA[12345&lt;!-- html --&gt;&lt;div&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;&lt;/div&gt; 1234567/* CSS */div&#123; font-size：10px；&#125;span&#123; display:inline-block;&#125; 设置成块级元素的span，会因为父元素设置字体的大小，导致两个span外的空格会占有空隙。所以将父元素的font-size：0；然后再单独设置span的字体大小就可以解决这个问题。]]></content>
      <categories>
        <category>bug汇总</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery对追加事件的绑定]]></title>
    <url>%2F2018%2F05%2F14%2Fjquery%E5%AF%B9%E8%BF%BD%E5%8A%A0%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[写项目的时候又用到了jquery，突然发现，对于用jquery追加的元素，on方法绑定不能用。 发现：on要原始存在才绑定上，否则要用delegate来动态绑定1$(document).delegate('selecter','click', function () &#123; alert(this.innerHTML) &#125;);]]></content>
      <categories>
        <category>bug汇总</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS中position属性总结笔记]]></title>
    <url>%2F2018%2F05%2F14%2FCSS%E4%B8%ADposition%E5%B1%9E%E6%80%A7%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[写了好多的position，一直在用它们字面的意思，最近项目写到的position的问题，竟然又出问题了。。总结一下： 1. positon:static; 静态定位（默认的 ） 这个是默认的，写不写都会是这个定位，所有的标准文档流里面的元素都是静态定位。 2. positon:relative; 相对定位 相对定位不会使有该属性的元素脱离标准文档流 相对定位会在页面原始的位置占据位置，而元素的位置会根据原始的位置进行偏移。 相对定位的作用一般是用来给子元素的绝对定位提供参考的。 3. position:absolute; 绝对定位 绝对定位会使有该属性的元素脱离标准文档流 特点： 如果这个元素没有父元素，top、left、right、bottom就相对于浏览器窗口来定位 如果绝对定位的元素有父元素，且父元素没有相对定位，top、left、right、bottom相对于浏览窗口来定位 如果绝对定位的元素有父元素，且父元素有定位（非static），top、left、right、bottom以父元素为基础偏移 绝对定位之后的元素在页面上不会占据位置 4. position:fixed; 固定定位 固定定位会使有该属性的元素脱离标准文档流 位置不变，适用于广告或者飘窗 总结：写页面时，用到最多是绝对定位与相对定位一起使用，较多的是子元素使用绝对定位，父元素使用相对定位]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[变量的作用域和变量提升]]></title>
    <url>%2F2018%2F05%2F14%2F%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%2F</url>
    <content type="text"><![CDATA[某家面试的时候面试题，面试官小姐姐给出了一道题：123456789var a = 100;function test()&#123; console.log(a); a = 10; console.log(a); console.log(this.a); var a;&#125;test(); 问我这三个会打印出来的值是什么？ 研究一下这个变量的作用域和变量提升： 一、作用域： 一个变量的作用域（scope）是程序源代码中定义这个变量的区域。全局变量拥有全局作用域，在javaScript代码中任何地方都有定义的。然而在函数内声明的变量只是在函数内部有定义，他们是局部变量，作用域也只是在局部。 在函数体内，局部变量的优先级要高于全局变量。如果在函数体内重新声明一个与局部变量重名的变量，局部变量就会覆盖全局变量的值。来看个例子： 123456789101112var num="100";function scope()&#123; var num="10"; function innerScope()&#123; var num = "1"; console.log(scope);//输出：1 &#125; innerScope(); console.log(num);//输出：10&#125;scope();console.log(num);//输出：100 这个例子会打印三个数，分别是1，10，100；局部变量的作用域仅仅在函数内部，出了函数体之后，局部变量就会被销毁。在innerScope()函数中，虽然又声明了一个num，但是innerScope()中的num是局部变量，只是与全局变量的名字相同，并不是全局变量，所以，虽然在该函数中把num赋值为1，但这仅仅是一个与全局变量名称相同的一个变量而已，并没有改变全局变量的值。 再来看一个例子: 123456789101112var num="100";function scope()&#123; var num="10"; function innerScope()&#123; num = "1"; console.log(scope);//输出：1 &#125; innerScope(); console.log(num);//输出：1&#125;scope();console.log(num);//输出：100 上面这部分代码中，在innerScope()函数中，我们并没有用var来声明num，所以，在这里的num的作用域就被提升了，即我们将scope中的num的值重置了，所以在输出的时候输出的结果为嵌套作用域内的局部变量。 二、变量提升 在Javascript中，函数及变量的声明都将被提升到函数的最顶部。在js中，变量的声明会被解析器悄悄的提升到方法体的最顶部，但是需要注意的是，提升的仅仅是变量的声明，变量的赋值并不会被提升，我们需要注意的是，函数的声明与变量的声明是不一样的。函数的函数体也会被一起提升。函数表达式和变量表达式只是其声明被提升，函数声明是函数的声明和实现都被提升。 所以上面那个题就很好理解了。我们再来看一下这个题：123456789var a = 100;function test()&#123; console.log(a); a = 10; console.log(a); console.log(this.a); var a;&#125;test(); 因为变量提升，a提升到最前面，声明未赋值，所以第一个就会打印undefined； 第二个在a声明之后，而且a赋值为10，所以第二个打印出来10； 第三个，因为test()是在window下调用的；this指的是test()调用的作用域，所以第三个打印100； 看一个函数提升的例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;script language="javascript" type="text/javascript"&gt; //在全局对象中声明两个全局函数,反模式 function foo() &#123; alert("global foo"); &#125; function bar() &#123; alert("global bar"); &#125; //定义全局变量 var v = "global var"; function hoistMe() &#123; alert(typeof foo); //function alert(typeof bar); //undefined alert(v); //undefined //为什么bar函数和变量v是未定义而不是全局变量中定义的相应的函数变量呢？ //因为函数里面定义了同名的函数和变量，无论在函数的任何位置定义这些函数和 //和变量，它们都将被提升到函数的最顶部。 foo(); //local foo bar(); //报错，TypeError "bar is not a function" //函数声明，变量foo以及其实现被提升到hoistMe函数顶部 function foo() &#123; alert("local foo"); &#125; //函数表达式,仅变量bar被提升到函数顶部，实现没有被提升 var bar = function() &#123; alert("local bar"); &#125;; //定义局部变量 var v = "local"; &#125; (function() &#123; hoistMe(); &#125;)(); //函数表达式和变量表达式只是其声明被提升，函数声明是函数的声明和实现都被提升。 /**由于函数提升的效果，hoistMe方法相当于 function hoistMe() &#123; //函数声明，变量foo以及其实现被提升到hoistMe函数顶部 function foo() &#123; alert("local foo"); &#125; //函数表达式,仅变量bar被提升到函数顶部，实现没有被提升(同变量提升) var bar = undefined; //变量声明被提升 var v = undefined; alert(typeof foo); //function alert(typeof bar); //undefined alert(v); //undefined foo(); //local foo bar(); //报错，缺少对象 bar = function() &#123; alert("local bar"); &#125;; v = "local"; &#125; */ &lt;/script&gt;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 书单]]></title>
    <url>%2F2018%2F05%2F14%2F2018-%E4%B9%A6%E5%8D%95%2F</url>
    <content type="text"><![CDATA[☐ 《原则》瑞·达利欧 著 中信出版社✔ 《爆裂》伊藤穰一 杰夫·豪 著 中信出版社☐ 《基因传》悉达多•穆克吉 著 中信出版社☐ 《未来简史》尤瓦尔·赫拉利 著 中信出版社☐ 《人类简史》尤瓦尔·赫拉利 著 中信出版社✔ 《你的第一本哲学书》托马斯·内格尔 著 中信出版社☐ 《自私的基因》理查德·道金斯 著 中信出版社☐ 《不会被机器替代的人》杰夫·科尔文 著 中信出版社☐ 《好好说话》马薇薇、黄执中、周玄毅等 著 中信出版社☐ 《跃迁》古典 著 中信出版社☐ 《智能时代》吴军 著 中信出版社☐ 《细节：如何轻松影响他人》史蒂夫·马丁 诺瓦·戈尔茨坦 等 著 中信出版社☐ 《向前一步》谢丽尔·桑德伯✔ 《人人都是产品经理》☐ 《穷爸爸富爸爸》☐ 《中国经济2018》]]></content>
      <categories>
        <category>浮生小记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[redux-devtools学习理解]]></title>
    <url>%2F2018%2F05%2F11%2Fredux-devtools%E5%AD%A6%E4%B9%A0%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[redux-devtoolsA live-editing time travel environment for Redux.redux-devtools是一个有趣而又高效的redux开发工具，通过redux-devtools，我们可以清晰的看到当前 store 仓库中的 state 是怎么样的，在可视化工具的左边，我们还可以看到触发的action的变化。这样，使得我们开发过程中很方便地进行调试。 安装123npm install --save-dev redux-devtoolsnpm install --save-dev redux-devtools-log-monitornpm install --save-dev redux-devtools-dock-monitor 使用 通过createDevTools来创建DevTools组件 1234567891011121314151617import React from 'react'//从redux-devtools中引入createDevToolslet DevTools;if (process.env.NODE_ENV === 'development') &#123; const &#123;createDevTools&#125; = require('redux-devtools'); const LogMonitor = require('redux-devtools-log-monitor').default; const DockMonitor = require('redux-devtools-dock-monitor').default; DevTools = createDevTools( &lt;DockMonitor toggleVisibilityKey="ctrl-h" changePositionKey="ctrl-w" defaultIsVisible=&#123;false&#125; defaultPosition="right"&gt; &lt;LogMonitor theme="tomorrow" preserveScrollTop=&#123;false&#125;/&gt; &lt;/DockMonitor&gt; );&#125; 采用DevTools.instrument()通过redux的compose来扩展store 1234567891011121314151617181920212223export function configureStore(history, reducers, initialState) &#123; // Installs hooks that always keep react-router and redux store in sync const middleware = [thunk, routerMiddleware(history)]; if (process.env.NODE_ENV === 'development') &#123; //开发环境 const &#123;createLogger&#125; = require('redux-logger'); middleware.push(createLogger()); &#125; let devTools = []; if (DevTools &amp;&amp; typeof document !== 'undefined') &#123; devTools = [DevTools.instrument()] &#125; const store = createStore( reducers, initialState, compose( applyMiddleware(...middleware), ...devTools )); return store;&#125; 用createDevTools()创建的DevTools组件有个特殊的静态方法instrument(),它返回一个store的增强器,在开发中你需要在compose中使用。注意：DevTools.instrument()要放在applyMiddleware后，因为你的applyMiddleware可以存在异步行为，为了确保所有的actions显示在store中，所以要放在后面 Render &lt;DevTools /&gt; 1234567891011const store = configureStore();render( &lt;Provider store=&#123;store&#125;&gt; &lt;div&gt; &lt;Router /&gt; &lt;DevTools /&gt; &lt;/div&gt; &lt;/Provider&gt; document.getElementById('app'));]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux源码学习--applyMiddleware]]></title>
    <url>%2F2018%2F05%2F11%2Fredux%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-applyMiddleware%2F</url>
    <content type="text"><![CDATA[applyMiddleware理解 中间件的本质是作为enhancer而存在的。它是通过createStore方法传递到redux的内部中的,中间件模块是一个高阶函数下面是redux中间件的基本格式：1const reduxMiddleware = (&#123;dispatch, getState&#125;[简化的store]) =&gt; (next[上一个中间件的dispatch方法]) =&gt; (action[实际派发的action对象]) =&gt; &#123;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950export default function applyMiddleware(...middlewares) &#123; // middlewares就是我们传递给applyMiddlewarez函数的一系列中间件函数 return (createStore) =&gt; (...args) =&gt; &#123; // createStore就是redux用于创建store的方法,args === [reducers, preloadedState]。下面这句话就是在中间件的内部，使用我们传递的参数创建一个store对象 // 注：这一块没有传递enhancer,所以返回的就是我们经常使用的store对象 const store = createStore(...args) // 获取store对象的dispatch方法 let dispatch = () =&gt; &#123; throw new Error( `Dispatching while constructing your middleware is not allowed. ` + `Other middleware would not be applied to this dispatch.` ) &#125; // 传递给中间件的第一层的函数的参数， const middlewareAPI = &#123; getState: store.getState, // 重写了dispatch方法，其实就是store.dispatch(...args) dispatch: (...args) =&gt; dispatch(...args) &#125; /** * 着重给大家详细的解释一下这一块 * 假设我们给applyMiddleware函数传递的中间件是 * applyMiddleware( * f1 =&gt; g1 =&gt; h1(...arg) =&gt; &#123;&#125;, * f2 =&gt; g2 =&gt; h2(...arg) =&gt; &#123;&#125; * ) * 运行下面的这行代码之后，chain中保存的内容是 * chain = [g1 =&gt; h1(...arg) =&gt; &#123;&#125;, g2 =&gt; h2(...arg) =&gt; &#123;&#125;] */ const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)) /** * 当我们把chain传入到 compose中后，根据我们对compose的分析， * compose(...chain)(store.dispatch)的结果就是: * g1(h2(...arg)) =&gt; h1(...arg) * * 也就是说，按照上面的这个形式，下面的dispatch和h1函数是一样的，所以，h1的参数，就是我们需要派发的action，当我们调用dispatch的时候，其实就相当于调用h1(action)，而在h1的内部，这个action是由g1的参数 * 也就是h2进行派发的，所以这个时候action就传递到了h2的内部，而h2的参数是由g2的参数，也就是实际传入的store.dispatch进行派发的，就这样层层传入，层层输出，就形成了我们强大的中间件机制。 */ dispatch = compose(...chain)(store.dispatch) // 返回的也是一个store对象 return &#123; ...store, // 这个dispatch其实就是，各个中间件的最底层(第三层)的哪个函数组成的圆环函数构成的 dispatch &#125; &#125;&#125;]]></content>
      <categories>
        <category>redux源码学习</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>react</tag>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux源码学习--bindActionCreators]]></title>
    <url>%2F2018%2F05%2F11%2Fredux%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-bindActionCreators%2F</url>
    <content type="text"><![CDATA[bindActionCreators 以前这样触发一个action，即dispatch(actionCreator(args))，现在变成这样触发一个action: boundActionCreator(args)。目的很单纯，简化某个action的调用。 Redux中的bindActionCreators，是通过dispatch将action包裹起来，这样可以通过bindActionCreators创建的方法，直接调用dispatch(action)(隐式调用）。一般情况下，我们可以通过Provider将store通过React的connext属性向下传递，bindActionCreators的唯一用处就是需要传递action creater到子组件，并且改子组件并没有接收到父组件上传递的store和dispatch。 实现上面那个效果，仅需一行代码，也就是源码文件中的第一个函数：1234567// 返回一个函数fn：函数目的是将actionCreator绑定到dispatch上，不用麻烦调用dispatch(actionCreator(args))了// 返回一个函数fn，该函数fn用dispatch来调用，其参数是actionCreator执行结果，function bindActionCreator(actionCreator, dispatch) &#123; return function() &#123; return dispatch(actionCreator.apply(this, arguments)) &#125;&#125; 参数理解actionCreators: actionCreators是一个对象，它的值是actions creator函数。也可以传递一个函数。dispatch: 等同于store中的store.dispatch，用于组合action 返回值boundActionCreators: 返回一个boundActionCreators对象 1234567891011121314151617181920212223242526272829export default function bindActionCreators(actionCreators, dispatch) &#123; //如果actionCreators是一个函数，则说明只有一个actionCreator，那直接调用bindActionCreator就行了 if (typeof actionCreators === 'function') &#123; return bindActionCreator(actionCreators, dispatch) &#125; //如果是actionCreator是对象，或者是null的话，报错喽 if (typeof actionCreators !== 'object' || actionCreators === null) &#123; throw new Error( `bindActionCreators expected an object or a function, instead received $&#123;actionCreators === null ? 'null' : typeof actionCreators&#125;. ` + `Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?` ) &#125; //保持actionCreators里面原来的key，只是把key对应的value都转成了boundActionCreator const keys = Object.keys(actionCreators) const boundActionCreators = &#123;&#125; for (let i = 0; i &lt; keys.length; i++) &#123; const key = keys[i] const actionCreator = actionCreators[key] //只对value是函数的key进行转换，其他的都过滤掉了 if (typeof actionCreator === 'function') &#123; boundActionCreators[key] = bindActionCreator(actionCreator, dispatch) &#125; &#125; //返回绑定之后的对象 return boundActionCreators&#125; 总结 bindActionCreators函数把actionCreators这个对象里面包含的每一个actionCreator按照原来的key的方式全部都封装了一遍。]]></content>
      <categories>
        <category>redux源码学习</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>react</tag>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux源码学习--combineReducers]]></title>
    <url>%2F2018%2F05%2F11%2Fredux%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E2%80%94combineReducers%2F</url>
    <content type="text"><![CDATA[combineReducers 理解 combineReducers.js文件对外暴露了一个函数combineReducers，combineReducer函数是redux的一个辅助性的函数，用于拆分createStore里面的第一个参数：reducer函数。combineReducer函数的返回值是一个函数，该函数是组合之后的一个标准的reducer函数。combineReducers将多个值不同的reducer对象转换为单个reducer。它将调用每个子reducer，并将它们的结果收集到单个状态对象中，该对象的键对应于传递的reducer函数的键。 参数理解{reducers}：一个对象，它的值对应于需要被组合成一个的不同的reducer函数。获得它的一种简便方法是使用ES6import * as reducers语法。对于任何的actions，reducer可能永远不会返回undefined。相反，如果传递给它们的state是undefined，则返回初始state，以及任何未识别action的当前state。1234let reducers = &#123; usersId: function getUsersIdReducer()&#123;&#125;, userName: function getUserNameReducer()&#123;&#125;&#125; 参数处理 从传入的参数里面提取出合法的reducers（reducers的每一个key对应的value值是函数，才是合法的子reducer），赋值给新的局部变量：finalReducers 12345678910111213141516const reducerKeys = Object.keys(reducers)//定义一个局部变量 finalReducersconst finalReducers = &#123;&#125;for (let i = 0; i &lt; reducerKeys.length; i++) &#123; const key = reducerKeys[i] if (process.env.NODE_ENV !== 'production') &#123; if (typeof reducers[key] === 'undefined') &#123; warning(`No reducer provided for key "$&#123;key&#125;"`) &#125; &#125; //过滤出reducers对应的value值是function的key，将其放入finalReducers对象 if (typeof reducers[key] === 'function') &#123; finalReducers[key] = reducers[key] &#125;&#125; 校验finalReducers, 判断其每一个子reducer是否能返回正常的子state 1234567891011121314//取出过滤出来的有效的keys列表const finalReducerKeys = Object.keys(finalReducers)let unexpectedKeyCacheif (process.env.NODE_ENV !== 'production') &#123; unexpectedKeyCache = &#123;&#125;&#125;let shapeAssertionErrortry &#123; assertReducerShape(finalReducers)&#125; catch (e) &#123; shapeAssertionError = e&#125; 调用assertReducerShape函数： 123456789101112131415161718192021222324252627282930313233343536//确认reducer是否是合法的reducer，即返回的state是不是undefined，如果是undefined，则是非法reducerfunction assertReducerShape(reducers) &#123; Object.keys(reducers).forEach(key =&gt; &#123; const reducer = reducers[key] const initialState = reducer(undefined, &#123;type: ActionTypes.INIT&#125;) //如果初始state是undefined，则抛出错误 if (typeof initialState === 'undefined') &#123; throw new Error( `Reducer "$&#123;key&#125;" returned undefined during initialization. ` + `If the state passed to the reducer is undefined, you must ` + `explicitly return the initial state. The initial state may ` + `not be undefined. If you don't want to set a value for this reducer, ` + `you can use null instead of undefined.` ) &#125; //如果reducer是undefined，抛出错误 if ( typeof reducer(undefined, &#123; type: ActionTypes.PROBE_UNKNOWN_ACTION() &#125;) === 'undefined' ) &#123; throw new Error( `Reducer "$&#123;key&#125;" returned undefined when probed with a random type. ` + `Don't try to handle $&#123; ActionTypes.INIT &#125; or other actions in "redux/*" ` + `namespace. They are considered private. Instead, you must return the ` + `current state for any unknown actions, unless it is undefined, ` + `in which case you must return the initial state, regardless of the ` + `action type. The initial state may not be undefined, but can be null.` ) &#125; &#125;)&#125; 返回值combineReducers函数返回一个combination函数，combination是一个标准的reducer函数，有初始化的state参数，和一个携带了actionType和数据的action对象。12345678910111213141516171819202122232425262728293031323334353637383940return function combination(state = &#123;&#125;, action) &#123; //如果有非法的reducer，就直接报错 if (shapeAssertionError) &#123; throw shapeAssertionError &#125; if (process.env.NODE_ENV !== 'production') &#123; const warningMessage = getUnexpectedStateShapeWarningMessage( state, finalReducers, action, unexpectedKeyCache ) if (warningMessage) &#123; warning(warningMessage) &#125; &#125; let hasChanged = false //定义新的nextState const nextState = &#123;&#125; // 1，遍历reducers对象中的有效key， // 2，执行该key对应的value函数，即子reducer函数，并得到对应的state对象，即子state // 3，将新的子state挂到新的nextState对象上，key不变 for (let i = 0; i &lt; finalReducerKeys.length; i++) &#123; const key = finalReducerKeys[i] const reducer = finalReducers[key] const previousStateForKey = state[key] const nextStateForKey = reducer(previousStateForKey, action) if (typeof nextStateForKey === 'undefined') &#123; const errorMessage = getUndefinedStateErrorMessage(key, action) throw new Error(errorMessage) &#125; nextState[key] = nextStateForKey //如果hasChanged为true，那就是true了 后面的判断是，只要有一次nextStateForKey!== previousStateForKey不同，就说明整个state不同 hasChanged = hasChanged || nextStateForKey !== previousStateForKey &#125; //如果state发生变化了，直接返回新的nextState，否则，还是返回旧的state return hasChanged ? nextState : state&#125; 总结 combineReducers 辅助函数的作用是，把一个由多个不同 reducer 函数作为 value 的 object，合并成一个最终的 reducer 函数，然后就可以对这个 reducer 调用 createStore。 合并后的 reducer 可以调用各个子 reducer，并把它们的结果合并成一个 state 对象。state 对象的结构由传入的多个 reducer 的 key 决定。 每个传入 combineReducers 的 reducer 都需满足以下规则： 所有未匹配到的 action，必须把它接收到的第一个参数也就是那个 state 原封不动返回。 永远不能返回 undefined。当过早 return 时非常容易犯这个错误，为了避免错误扩散，遇到这种情况时 combineReducers 会抛异常。 如果传入的 state 就是 undefined，一定要返回对应 reducer 的初始 state。根据上一条规则，初始 state 禁止使用 undefined。使用 ES6 的默认参数值语法来设置初始 state 很容易，但你也可以手动检查第一个参数是否为 undefined。]]></content>
      <categories>
        <category>redux源码学习</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>react</tag>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux源码学习--compose]]></title>
    <url>%2F2018%2F05%2F11%2Fredux%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-compose%2F</url>
    <content type="text"><![CDATA[composecompose 是一个从右向左编写单参数组成的函数。最右边的函数可以接受多个参数，因为它提供了签名由此产生的复合函数。 参数理解{...funcs}需要合成的多个函数。每个函数都接收一个函数作为参数，然后返回一个函数。 返回值(Function) 从右到左把接收到的函数合成后的最终函数。 代码理解1234567891011export default function compose(...funcs) &#123; if (funcs.length === 0) &#123; return arg =&gt; arg &#125; if (funcs.length === 1) &#123; return funcs[0] &#125; //对参数进行一个累加，就是依次以右边的参数作为左边方法的参数累加到最左边 return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))&#125; 总结compose 主要用于 applyMiddleware / createStore enhancer.compose 做的只是让你不使用深度右括号的情况下来写深度嵌套的函数compose的运行结果是一个函数，调用这个函数所传递的参数将会作为compose最后一个参数的参数，从而由内向外，逐步调用。]]></content>
      <categories>
        <category>redux源码学习</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>react</tag>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[immutable.js 学习]]></title>
    <url>%2F2018%2F05%2F11%2Fimmutable-js-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[JavaScript 中的对象一般是可变的，因为Javascript为了节省内存，都是使用引用赋值，生成一个新对象如果简单的引用了原始对象，那对新对象作出的改变，也将影响到原始对象。平时简单的应用还不会特别明显，但是如果在复杂的应用中，对象的改变就会引起比较复杂的问题。往往都会使用deepCopy来解决这个问题，但是deepCopy往往会对整个对象的树进行拷贝，也会造成 CPU 和内存的浪费。一、什么是immutable data？Immutable Data 就是被创建之后不能给改变数据。Immutable 实现的原理是 Persistent Data Structure（持久化数据结构），新数据通过旧的数据创建，需要使旧数据依旧可用而且不能被改变。Immutable的这种实现原理，也避免了deepCopy复制所有节点带来的性能损耗。Immutable的实现原理见下图： 二、Immutable 优点 Immutable 降低了 Mutable 带来的复杂度 节省内存 Undo/Redo，Copy/Paste，甚至时间旅行这些功能做起来小菜一碟 并发安全 拥抱函数式编程 三、Immutable 缺点： 需要学习新的 API 增加了资源文件大小 容易与原生对象混淆 四、Immutable的数据类型Immutable 的几种数据类型1.List: 有序索引集，类似JavaScript中的Array。2.Map: 无序索引集，类似JavaScript中的Object。3.OrderedMap: 有序的Map，根据数据的set()进行排序。4.Set: 没有重复值的集合。5.OrderedSet: 有序的Set，根据数据的add进行排序。6.Stack: 有序集合，支持使用unshift（）和shift（）添加和删除。7.Range(): 返回一个Seq.Indexed类型的集合，这个方法有三个参数，start表示开始值，默认值为0，end表示结束值，默认为无穷大，step代表每次增大的数值，默认为1.如果start = end,则返回空集合。8.Repeat(): 返回一个vSeq.Indexe类型的集合，这个方法有两个参数，value代表需要重复的值，times代表要重复的次数，默认为无穷大。9.Record: 一个用于生成Record实例的类。类似于JavaScript的Object，但是只接收特定字符串为key，具有默认值。10.Seq: 序列，但是可能不能由具体的数据结构支持。11.Collection: 是构建所有数据结构的基类，不可以直接构建。 用的最多就是List和Map，所以在这里主要介绍这两种数据类型的API。 五、常用的API1.fromJS() 将一个js数据转换为Immutable类型的数据。用法：fromJS(value, converter)简介：value是要转变的数据，converter是要做的操作。第二个参数可不填，默认情况会将数组准换为List类型，将对象转换为Map类型，其余不做操作。 1234const obj = Immutable.fromJS(&#123;a:'123',b:'234'&#125;,function (key, value, path) &#123; console.log(key, value, path) return isIndexed(value) ? value.toList() : value.toOrderedMap())&#125;) 2.toJS()作用：将一个Immutable数据转换为JS类型的数据。用法：value.toJS() 3.is()对两个对象进行比较。用法：is(map1,map2)简介：和js中对象的比较不同，在js中比较两个对象比较的是地址，但是在Immutable中比较的是这个对象hashCode和valueOf，只要两个对象的hashCode相等，值就是相同的，避免了深度遍历，提高了性能。 123456import &#123; Map, is &#125; from 'immutable'const map1 = Map(&#123; a: 1, b: 1, c: 1 &#125;)const map2 = Map(&#123; a: 1, b: 1, c: 1 &#125;)map1 === map2 //falseObject.is(map1, map2) // falseis(map1, map2) // true 4.List 和 Map创建List() 和 Map() 作用：用来创建一个新的List/Map对象 用法: 12345678910//ListList(): List&lt;any&gt;List&lt;T&gt;(): List&lt;T&gt;//MapMap(): Map&lt;any&gt;Map&lt;T&gt;(): Map&lt;T&gt;List.of() 和 Map.of() 作用：创建一个新的包含value的List/Map对象用法：123List.of&lt;T&gt;(...values: Array&lt;T&gt;): List&lt;T&gt;Map.of&lt;T&gt;(...values: Object&lt;T&gt;): Map&lt;T&gt; 判断 1List.isList() 和 Map.isMap() 作用：判断一个数据结构是不是List/Map类型用法：123List.isList(maybeList: any): booleanMap.isMap(maybeMap: any): boolean 长度size 作用：获取List/Map的长度 数据读取get() 、 getIn() 作用：获取数据结构中的数据 has() 、 hasIn() 作用:判断是否存在某一个key 用法：1234Immutable.fromJS([1,2,3,&#123;a:4,b:5&#125;]).has('0'); //trueImmutable.fromJS([1,2,3,&#123;a:4,b:5&#125;]).has('0'); //trueImmutable.fromJS([1,2,3,&#123;a:4,b:5&#125;]).hasIn([3,'b']) //trueincludes() 作用：判断是否存在某一个value 用法： 123456Immutable.fromJS([1,2,3,&#123;a:4,b:5&#125;]).includes(2); //trueImmutable.fromJS([1,2,3,&#123;a:4,b:5&#125;]).includes('2'); //false 不包含字符2Immutable.fromJS([1,2,3,&#123;a:4,b:5&#125;]).includes(5); //false Immutable.fromJS([1,2,3,&#123;a:4,b:5&#125;]).includes(&#123;a:4,b:5&#125;) //falseImmutable.fromJS([1,2,3,&#123;a:4,b:5&#125;]).includes(Immutable.fromJS(&#123;a:4,b:5&#125;)) //truefirst() 、 last() 作用：用来获取第一个元素或者最后一个元素，若没有则返回undefined代码： 12345Immutable.fromJS([1,2,3,&#123;a:4,b:5&#125;]).first()//1Immutable.fromJS([1,2,3,&#123;a:4,b:5&#125;]).last()//&#123;a:4,b:5&#125;Immutable.fromJS(&#123;a:1,b:2,c:&#123;d:3,e:4&#125;&#125;).first() //1Immutable.fromJS(&#123;a:1,b:2,c:&#123;d:3,e:4&#125;&#125;).first() //&#123;d:3,e:4&#125; 数据修改注：这里对于数据的修改，是对原数据进行操作后的值赋值给一个新的数据，并不会对原数据进行修改，因为Immutable是不可变的数据类型。 设置 set() 作用：设置第一层key、index的值 用法： 123set(index: number, value: T): List&lt;T&gt;set(key: K, value: V): thisList在使用的时候，将index为number值设置为value。Map在使用的时候，将key的值设置为value。 在List中使用时，若传入的number为负数，则将index为size+index的值设置为value，例，若传入-1，则将size-1的值设为value。若传入的number的值超过了List的长度，则将List自动补全为传入的number的值，将number设置为value，其余用undefined补全。注：跟js中不同，List中不存在空位，[,,,],List中若没有值，则为undefined。 代码实现：12345678910111213141516171819202122232425//////Listconst originalList = List([ 0 ]);// List [ 0 ]originalList.set(1, 1);// List [ 0, 1 ]originalList.set(0, 'overwritten');// List [ "overwritten" ]originalList.set(2, 2);// List [ 0, undefined, 2 ]List().set(50000, 'value').size;// 50001//////Mapconst &#123; Map &#125; = require('immutable')const originalMap = Map()const newerMap = originalMap.set('key', 'value')const newestMap = newerMap.set('key', 'newer value')originalMap// Map &#123;&#125;newerMap// Map &#123; "key": "value" &#125;newestMap// Map &#123; "key": "newer value" &#125; setIn()作用：设置深层结构中某属性的值用法：12setIn(keyPath: Iterable&lt;any&gt;, value: any): this用法与set()一样，只是第一个参数是一个数组，代表要设置的属性所在的位置 删除 delete 作用：用来删除第一层结构中的属性 用法：123delete(index: number): List&lt;T&gt; //Listdelete(key: K): this //MapdeleteIn() 用来删除深层数据，用法参考setIndeleteAll() (Map独有，List没有)作用：用来删除Map中的多个key用法：1deleteAll(keys: Iterable&lt;K&gt;): this 代码示例：123const names = Map(&#123; a: "Aaron", b: "Barry", c: "Connor" &#125;)names.deleteAll([ 'a', 'c' ])// Map &#123; "b": "Barry" &#125; 更新 update()作用：对对象中的某个属性进行更新，可对原数据进行相关操作用法：12update(index: number, updater: (value: T) =&gt; T): this //Listupdate(key: K, updater: (value: V) =&gt; V): this //Map 代码示例：12345678////Listconst list = List([ 'a', 'b', 'c' ])const result = list.update(2, val =&gt; val.toUpperCase())///Mapconst aMap = Map(&#123; key: 'value' &#125;)const newMap = aMap.update('key', value =&gt; value + value)updateIn() 用法参考setIn 清除 clear() 作用：清除所有数据 用法：clear(): this 代码示例：12Map(&#123; key: 'value' &#125;).clear() //MapList([ 1, 2, 3, 4 ]).clear() // List List中的各种删除与插入List对应的数据结构是js中的数组，所以数组的一些方法在Immutable中也是通用的，比如push，pop,shift，unshift，insert。 push()：在List末尾插入一个元素pop(): 在List末尾删除一个元素unshift: 在List首部插入一个元素shift: 在List首部删除一个元素insert：在List的index处插入元素代码实现：123456789101112List([ 0, 1, 2, 3, 4 ]).insert(6, 5) //List [ 0, 1, 2, 3, 4, 5 ]List([ 1, 2, 3, 4 ]).push(5)// List [ 1, 2, 3, 4, 5 ]List([ 1, 2, 3, 4 ]).pop()// List[ 1, 2, 3 ]List([ 2, 3, 4]).unshift(1);// List [ 1, 2, 3, 4 ]List([ 0, 1, 2, 3, 4 ]).shift();// List [ 1, 2, 3, 4 ]List中还有一个特有的方法用法设置List的长度，setSize()List([]).setSize(2).toJS() //[undefined,undefined] 关于mergemerge 作用：浅合并，新数据与旧数据对比，旧数据中不存在的属性直接添加，就数据中已存在的属性用新数据中的覆盖 mergrWith 作用：自定义浅合并，可自行设置某些属性的值 mergeIn 作用：对深层数据进行浅合并 mergeDeep 作用：深合并，新旧数据中同时存在的的属性为新旧数据合并之后的数据 mergeDeepIn 作用：对深层数据进行深合并 mergrDeepWith 作用:自定义深合并，可自行设置某些属性的值这里用一段示例彻底搞懂merge，此示例为Map结构，List与Map原理相同123456789101112131415const Map1 = Immutable.fromJS(&#123;a:111,b:222,c:&#123;d:333,e:444&#125;&#125;);const Map2 = Immutable.fromJS(&#123;a:111,b:222,c:&#123;e:444,f:555&#125;&#125;);const Map3 = Map1.merge(Map2); //Map &#123;a:111,b:222,c:&#123;e:444,f:555&#125;&#125;const Map4 = Map1.mergeDeep(Map2); //Map &#123;a:111,b:222,c:&#123;d:333,e:444,f:555&#125;&#125;const Map5 = Map1.mergeWith((oldData,newData,key)=&gt;&#123; if(key === 'a')&#123; return 666; &#125;else&#123; return newData &#125; &#125;,Map2); //Map &#123;a:666,b:222,c:&#123;e:444,f:555&#125;&#125; 序列算法concat()作用：对象的拼接，用法与js数组中的concat()相同，返回一个新的对象。用法：1const List = list1.concat(list2) map()作用：遍历整个对象，对Map/List元素进行操作，返回一个新的对象。用法：12Map(&#123;a:1,b:2&#125;).map(val=&gt;10*val)//Map&#123;a:10,b:20&#125; Map特有的mapKey()作用：遍历整个对象，对Map元素的key进行操作，返回一个新的对象。用法：12Map(&#123;a:1,b:2&#125;).mapKey(val=&gt;val+'l')//Map&#123;al:10,bl:20&#125; Map特有的mapEntries() 作用：遍历整个对象，对Map元素的key和value同时进行操作，返回一个新的对象。Map的map()也可实现此功能。用法：1234Map(&#123;a:1,b:2&#125;).map((key,val)=&gt;&#123; return [key+'l',val*10]&#125;)//Map&#123;al:10,bl:20&#125; 过滤 filter作用：返回一个新的对象，包括所有满足过滤条件的元素用法：1234Map(&#123;a:1,b:2&#125;).filter((key,val)=&gt;&#123; return val == 2&#125;)//Map&#123;b:2&#125; 还有一个filterNot()方法，与此方法正好相反。反转 reverse作用：将数据的结构进行反转代码示例：1234Immutable.fromJS([1, 2, 3, 4, 5]).reverse();// List [5,4,3,2,1]Immutable.fromJS(&#123;a:1,b:&#123;c:2,d:3&#125;,e:4&#125;).recerse();//Map &#123;e:4,b:&#123;c:2,d:3&#125;,a:1&#125; 排序 sort &amp; sortBy作用：对数据结构进行排序代码示例：1234567891011121314151617181920212223242526272829303132///ListImmutable.fromJS([4,3,5,2,6,1]).sort()// List [1,2,3,4,5,6]Immutable.fromJS([4,3,5,2,6,1]).sort((a,b)=&gt;&#123; if (a &lt; b) &#123; return -1; &#125; if (a &gt; b) &#123; return 1; &#125; if (a === b) &#123; return 0; &#125;&#125;)// List [1,2,3,4,5,6]Immutable.fromJS([&#123;a:3&#125;,&#123;a:2&#125;,&#123;a:4&#125;,&#123;a:1&#125;]).sortBy((val,index,obj)=&gt;&#123; return val.get('a')&#125;,(a,b)=&gt;&#123; if (a &lt; b) &#123; return -1; &#125; if (a &gt; b) &#123; return 1; &#125; if (a === b) &#123; return 0; &#125;&#125;)//List [ &#123;a:3&#125;, &#123;a:2&#125;, &#123;a:4&#125;, &#123;a:1&#125; ]//MapImmutable.fromJS( &#123;b:1, a: 3, c: 2, d:5&#125; ).sort()//Map &#123;b: 1, c: 2, a: 3, d: 5&#125;Immutable.fromJS( &#123;b:1, a: 3, c: 2, d:5&#125; ).sort((a,b)=&gt;&#123; if (a &lt; b) &#123; return -1; &#125; if (a &gt; b) &#123; return 1; &#125; if (a === b) &#123; return 0; &#125;&#125;)//Map &#123;b: 1, c: 2, a: 3, d: 5&#125;Immutable.fromJS( &#123;b:1, a: 3, c: 2, d:5&#125; ).sortBy((value, key, obj)=&gt; &#123; return value&#125;)//Map &#123;b: 1, c: 2, a: 3, d: 5&#125; 分组 groupBy作用：对数据进行分组12345678910111213const listOfMaps = List([ Map(&#123; v: 0 &#125;), Map(&#123; v: 1 &#125;), Map(&#123; v: 1 &#125;), Map(&#123; v: 0 &#125;), Map(&#123; v: 2 &#125;)])const groupsOfMaps = listOfMaps.groupBy(x =&gt; x.get('v'))// Map &#123;// 0: List [ Map&#123; "v": 0 &#125;, Map &#123; "v": 0 &#125; ],// 1: List [ Map&#123; "v": 1 &#125;, Map &#123; "v": 1 &#125; ],// 2: List [ Map&#123; "v": 2 &#125; ],// &#125; 查找数据indexOf() 、 lastIndexOf Map不存在此方法作用：和js数组中的方法相同，查找第一个或者最后一个value的index值，找不到则返回-1用法：12Immutable.fromJS([1,2,3,4]).indexof(3) //2Immutable.fromJS([1,2,3,4]).lastIndexof(3) //2 findIndex() 、 findLastIndex() Map不存在此方法作用：查找满足要求的元素的index值用法：123456Immutable.fromJS([1,2,3,4]).findIndex((value,index,array)=&gt;&#123; return value%2 === 0;&#125;) // 1Immutable.fromJS([1,2,3,4]).findLastIndex((value,index,array)=&gt;&#123; return index%2 === 0;&#125;) // 3 find() 、 findLast()作用：查找满足条件的元素的value值用法：1234567Immutable.fromJS([1,2,3,4]).find((value,index,array)=&gt;&#123; return value%2 === 0;&#125;) // 2Immutable.fromJS([1,2,3,4]).findLast((value,index,array)=&gt;&#123; return value%2 === 0;&#125;) // 4 findKey() 、 findLastKey()作用：查找满足条件的元素的key值用法：1234567Immutable.fromJS([1,2,3,4]).findKey((value,index,array)=&gt;&#123; return value%2 === 0;&#125;) // 1Immutable.fromJS([1,2,3,4]).findLastKey((value,index,array)=&gt;&#123; return value%2 === 0;&#125;) // 3 findEntry() 、 findLastEntry()作用：查找满足条件的元素的键值对 key:value用法：1234567Immutable.fromJS([1,2,3,4]).findEntry((value,index,array)=&gt;&#123; return value%2 === 0;&#125;) // [1,2]Immutable.fromJS([1,2,3,4]).findLastEntry((value,index,array)=&gt;&#123; return value%2 === 0;&#125;) // [3,4] keyOf() lastKeyOf()作用：查找某一个value对应的key值用法：12Immutable.fromJS([1,2,3,4]).keyOf(2) //1Immutable.fromJS([1,2,3,4]).lastKeyOf(2) //1 max() 、 maxBy()作用：查找最大值用法:12345Immutable.fromJS([1, 2, 3, 4]).max() //4Immutable.fromJS([&#123;a;1&#125;,&#123;a:2&#125;,&#123;a: 3&#125;,&#123;a:4&#125;]).maxBy((value,index,array)=&gt;&#123; return value.get('a')&#125;) //&#123;a:4&#125; min() 、 minBy() 作用：查找最小值用法:12345Immutable.fromJS([1, 2, 3, 4]).min() //1Immutable.fromJS([&#123;a;1&#125;,&#123;a:2&#125;,&#123;a: 3&#125;,&#123;a:4&#125;]).minBy((value,index,array)=&gt;&#123; return value.get('a')&#125;) //&#123;a:1&#125; 创建子集slice() 作用： 和原生js中数组的slice数组一样，包含两个参数，start和end，start代表开始截取的位置，end代表结束的位置，不包括第end的元素。若不包括end，则返回整个对象，若end为负数，则返回（start，length-end）对应的数据。若start只有一个并且为负数，则返回最后的end个元素。 用法： 1234Immutable.fromJS([1, 2, 3, 4]).slice(0); //[1,2,3,4]Immutable.fromJS([1, 2, 3, 4]).slice(0,2); //[1,2]Immutable.fromJS([1, 2, 3, 4]).slice(-2); //[3,4]Immutable.fromJS([1, 2, 3, 4]).slice(0,-2); //[1,2] rest()作用：返回除第一个元素之外的所有元素用法:1Immutable.fromJS([1, 2, 3, 4]).rest()//[2,3,4] butLast()作用：返回除最后一个元素之外的所有元素用法:1Immutable.fromJS([1, 2, 3, 4]).rest()//[1,2,3] skip()作用：有一个参数n, 返回截掉前n个元素之后剩下的所有元素用法:1Immutable.fromJS([1, 2, 3, 4]).skip(1)//[2,3,4] skipLast() 作用：有一个参数n, 返回截掉最后n个元素之后剩下的所有元素 用法: 1Immutable.fromJS([1, 2, 3, 4]).skip(1)//[1,2,3] skipWhile() 作用：返回从第一次返回false之后的所有元素 123Immutable.fromJS([1, 2, 3, 4]).skipWhile(list.skipWhile((value,index,list)=&gt;&#123; return value &gt; 2;&#125;))// [1,2,3,4] skipUntil() 作用：返回从第一次返回true之后的所有元素 123Immutable.fromJS([1, 2, 3, 4]).skipUntil(list.skipWhile((value,index,list)=&gt;&#123; return value &gt; 2;&#125;))// [3,4] take() 作用：有一个参数n, 返回前n个元素 用法:Immutable.fromJS([1, 2, 3, 4]).take(2)//[1,2] takeLast() 作用：有一个参数n, 返回最后n个元素 用法:1Immutable.fromJS([1, 2, 3, 4]).takeLast(2)//[3,4] takeWhile() 作用：返回从第一次返回false之前的所有元素 123Immutable.fromJS([1, 2, 3, 4]).skipWhile(list.takeWhile((value,index,list)=&gt;&#123; return value &gt; 2;&#125;))// [] takeUntil() 作用：返回从第一次返回true之前的所有元素 123Immutable.fromJS([1, 2, 3, 4]).skipUntil(list.takeUntil((value,index,list)=&gt;&#123; return value &gt; 2;&#125;))// [1,2] 处理数据reduce() 作用：和js中数组中的reduce相同,按索引升序的顺序处理元素 用法： 12345Immutable.fromJS([1,2,3,4]).reduce((pre,next,index,arr)=&gt;&#123; console.log(pre+next) return pre+next; &#125;)// 3 6 10 reduceRight() 作用：和js中数组中的reduce相同,按索引降序的顺序处理元素 用法： 12345Immutable.fromJS([1,2,3,4]).reduceRight((pre,next,index,arr)=&gt;&#123; console.log(pre+next) return pre+next; &#125;)// 7 9 10 every() 作用：判断整个对象总中所有的元素是不是都满足某一个条件，都满足返回true，反之返回false。 代码： 123Immutable.fromJS([1,2,3,4]).every((value,index,arr)=&gt;&#123; return value &gt; 2&#125;) // false some() 作用：判断整个对象总中所有的元素是不是存在满足某一个条件的元素，若存在返回true，反之返回false。 代码： 123Immutable.fromJS([1,2,3,4]).some((value,index,arr)=&gt;&#123; return value &gt; 2&#125;) // true join() 作用：同js中数组的join方法。把准换为字符串 用法：Immutable.fromJS([1,2,3,4]).join(‘,’) //1,2,3,4 isEmpty() 作用：判断是否为空 用法: 12Immutable.fromJS([]).isEmpty(); // trueImmutable.fromJS(&#123;&#125;).isEmpty(); // true count() 作用：返回元素个数，可自定义条件，返回满足条件的个数 用法： 12345678910const list = Immutable.fromJS([1,2,3,4]);const map = Immutable.fromJS(&#123;a:1,b:2,c:3,d:4&#125;);list.count((value,index,list)=&gt;&#123; return value &gt; 2;&#125;) //2map.count((value,index,list)=&gt;&#123; return value &gt; 2;&#125;) //2 countBy() 作用：与count不同的是，countBy返回一个对象 用法： 12345678const list = Immutable.fromJS([1,2,3,4]);const map = Immutable.fromJS(&#123;a:1,b:2,c:3,d:4&#125;);list.countBy((value,index,list)=&gt;&#123; return value &gt; 2;&#125; //&#123;false: 2, true: 2&#125;map.countBy((value,index,list)=&gt;&#123; return value &gt; 2;&#125; //&#123;false: 2, true: 2&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>immutable</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux 源码学习——createStore]]></title>
    <url>%2F2018%2F05%2F11%2Fredux-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E2%80%94createStore%2F</url>
    <content type="text"><![CDATA[createStore 理解 创建一个保存state树的Redux store，store，可以让你阅读state，发送actions，并订阅更改。改变store数据的唯一方法是调用dispatch（）方法。应用中只能有一个store，指定state树的不同部分如何响应actions，可以通过使用combineReducers方法来组合多个reducer，将其转换为单个reducer。 返回值createStore.js是redux的核心文件，对外暴露了一个createStore函数，函数执行后返回一个对象，这个对象包括四个方法，分别是dispatch, subscribe, getState, replaceReducer。这些方法都redux中store的关键方法，后面将慢慢的展开理解。12345678910export default function createStore(reducer, preloadedState, enhancer) &#123; //other codes return &#123; dispatch, subscribe, getState, replaceReducer, [$$observable]: observable &#125;&#125; createStore 的参数理解createStore有三个参数：reducer, preloadedState, enhancer。 reducer：reducer是一个函数，通过给定当前state树和要处理的actions，返回下一个state树。 preloadedState：初始state，初始状态。您可以选择指定它从应用程序的服务器中来融合state，或者还原先前序列化的用户会话。如果使用combineReducers来生成根reducer函数，则必须是一个与“combineReducers”键相同的对象。 enhancer：store增强器。您可以选择指定它通过第三方功能增强store，如中间件，时间旅行，持久化等。Redux附带的唯一store增强器是applyMiddleware（）方法。这个参数特别有意思，如果该enhancer参数存在的话，会将当前的createStore函数作为参数传入enhancer函数，并且，enhancer执行之后得到一个新函数，该新函数其实就是一个加强版的createStore函数，新的函数会把之前的reducer和preloadeState作为参数传入并执行。这个enhancer参数为redux中间件提供了入口。 参数检查及异常处理12345678910111213141516171819//如果没有传preloadedState参数，但是enhancer参数传了，把两者交换一下if (typeof preloadedState === 'function' &amp;&amp; typeof enhancer === 'undefined') &#123; enhancer = preloadedState preloadedState = undefined &#125;//如果enhancer传了，但是不是函数，就抛出错误，否则执行enhancer函数，//并继续执行enhancer函数返回的加强版的createStore函数，//参数reducer以及preloadeState和原createStore函数保持一致if (typeof enhancer !== 'undefined') &#123; if (typeof enhancer !== 'function') &#123; throw new Error('Expected the enhancer to be a function.') &#125; return enhancer(createStore)(reducer, preloadedState) &#125;//如果reducer不是函数，则抛出错误if (typeof reducer !== 'function') &#123; throw new Error('Expected the reducer to be a function.')&#125; 定义局部变量12345let currentReducer = reducer //保存了当前的reducer函数，该reducer函数可以被动态替换掉let currentState = preloadedState //保存了当前的state数据let currentListeners = [] //保存了当前注册的函数列表let nextListeners = currentListenerslet isDispatching = false //是否正在dispatch一个action 定义返回store的方法1234567//确保nextListeners和currentListeners不是同一个引用function ensureCanMutateNextListeners() &#123; if (nextListeners === currentListeners) &#123; //如果是同一个引用，则浅拷贝currentListeners到nextListeners nextListeners = currentListeners.slice() &#125;&#125; 1234//getState函数，返回局部变量currentState，以获取当前状态function getState() &#123; return currentState&#125; 123456789101112131415161718192021222324252627//注册一个函数，将注册函数放入局部变量nextListeners数组里面//注册函数的返回值是一个注销函数，注销函数执行可以将刚刚添加进nextListeners的listener函数又删除掉。这里很有意思，外部必须在调用subscribe执行现场保存好unsubscribe函数，否则将无法注销一个函数function subscribe(listener) &#123; //如果listener不是函数，直接报错 if (typeof listener !== 'function') &#123; throw new Error('Expected listener to be a function.') &#125; let isSubscribed = true //确保nextListeners不是currentListeners，以保证修改的是nextListeners，而不是currentListeners ensureCanMutateNextListeners() //将监听函数放入监听函数列表尾部 nextListeners.push(listener) //返回一个函数，该函数可以从监听函数列表中删除刚刚注册的监听函数 return function unsubscribe() &#123; if (!isSubscribed) &#123; return &#125; isSubscribed = false ensureCanMutateNextListeners() const index = nextListeners.indexOf(listener) nextListeners.splice(index, 1) &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142//触发action的函数：每次触发一个action，currentListeners中的所有函数都要执行一遍function dispatch(action) &#123; //如果action不是普通的对象，直接报错 if (!isPlainObject(action)) &#123; throw new Error( 'Actions must be plain objects. ' + 'Use custom middleware for async actions.' ) &#125; //如果action没有type属性，直接报错：说明action对象必须要包含type字段 if (typeof action.type === 'undefined') &#123; throw new Error( 'Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?' ) &#125; //如果当前正在触发另外一个action，直接报错 if (isDispatching) &#123; throw new Error('Reducers may not dispatch actions.') &#125; try &#123; //先将标志位置为true isDispatching = true //执行传入的reducer函数，该函数返回一个新的state对象，并赋值给currentState变量 currentState = currentReducer(currentState, action) &#125; finally &#123; //reducer函数执行完成后，将isDispatching恢复成false，方便下次action的触发 isDispatching = false &#125; //每一次触发一个action，所有的监听函数都要全部重新执行一遍， //并且把上次得到的新的监听函数列表赋值成为当前的监听函数列表。这是一个懒操作，并不是在subscribe的时候就操作了，而是在dispatch的时候才操作 const listeners = currentListeners = nextListeners for (let i = 0; i &lt; listeners.length; i++) &#123; const listener = listeners[i] listener() &#125; //该dispatch函数的返回值是原来的action return action&#125; 12345678910111213//替换reducer函数：这个函数允许运行时动态替换最开始调用createStore函数时传入的reducer，并且替换掉reducer之后，重新dispatch一个action，得到全新的currentState对象function replaceReducer(nextReducer) &#123; //如果nextReducer不是函数，直接报错 if (typeof nextReducer !== 'function') &#123; throw new Error('Expected the nextReducer to be a function.') &#125; //把新的reducer赋值给当前的currentReducer变量，得到一个全新的currentReducer currentReducer = nextReducer // 触发一个初始action： // 1.这样就可以完成一次监听函数列表的全部调用 // 2.可以得到一个全新的currentState； dispatch(&#123;type: ActionTypes.INIT&#125;)&#125; 1234567891011121314151617181920212223242526272829303132function observable() &#123; const outerSubscribe = subscribe return &#123; /** * The minimal observable subscription method. * @param &#123;Object&#125; observer Any object that can be used as an observer. * The observer object should have a `next` method. * @returns &#123;subscription&#125; An object with an `unsubscribe` method that can * be used to unsubscribe the observable from the store, and prevent further * emission of values from the observable. */ subscribe(observer) &#123; if (typeof observer !== 'object') &#123; throw new TypeError('Expected the observer to be an object.') &#125; function observeState() &#123; if (observer.next) &#123; observer.next(getState()) &#125; &#125; observeState() const unsubscribe = outerSubscribe(observeState) return &#123;unsubscribe&#125; &#125;, [$$observable]() &#123; return this &#125; &#125;&#125; 初始化:初始化很简单，一句代码，直接调用一次dispatch，就会执行所有的注册函数，并且执行reducer函数，生成初始化的state12//马上内部调用一次初始化的操作，根据传入的reducer函数，preloadedState生成一个全新的currentState和全新的reducerdispatch(&#123;type: ActionTypes.INIT&#125;) 总结 createStore函数定义了几个局部变量用于记录状态，主要包括currentState记录数据状态，currentListeners记录注册函数列表，currentReducer记录当前的reducer函数。 定义了几个函数用于修改上面的几个局部变量：主要包括getState函数用于获取currentState；replaceReducer用于替换currentReducer；subscribe用于修改currentListeners列表；dispatch用于触发currentReducer执行，生成新的currentState，并且，执行currentListeners列表中的每一个函数。]]></content>
      <categories>
        <category>redux源码学习</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>react</tag>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[瀑布流布局]]></title>
    <url>%2F2018%2F05%2F09%2F%E7%80%91%E5%B8%83%E6%B5%81%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[瀑布流布局 在知乎看到大佬说，学习前端的第一阶段要会一些js基本的特效，学习一下，做几个Demo来看看 好像有那么两种方法：1、通过css来搞定瀑布流2、通过js来控制 CSS方法解决瀑布流因为css3有了一个新的属性:column我们在图片或者需要瀑布流的模块的父元素设置column属性就可以达到这种瀑布流的效果。12345678#main&#123; /*定位*/ /*position: relative;*/ /*多栏布局 设置栏宽度*/ -webkit-column-width:202px; -moz-column-width:202px; column-width:202px;&#125; JS方法来解决瀑布流布局首先先把html写出来：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;瀑布流布局&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="main"&gt; &lt;div class="wrap"&gt; &lt;div class="img"&gt; &lt;img src="http://img4.imgtn.bdimg.com/it/u=3673652172,785167112&amp;fm=27&amp;gp=0.jpg"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="wrap"&gt; &lt;div class="img"&gt; &lt;img src="http://img1.imgtn.bdimg.com/it/u=2752884811,3342547378&amp;fm=27&amp;gp=0.jpg"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="wrap"&gt; &lt;div class="img"&gt; &lt;img src="http://img5.imgtn.bdimg.com/it/u=2573504723,2456120500&amp;fm=27&amp;gp=0.jpg"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="wrap"&gt; &lt;div class="img"&gt; &lt;img src="http://img0.imgtn.bdimg.com/it/u=3214770734,3861052448&amp;fm=27&amp;gp=0.jpg"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="wrap"&gt; &lt;div class="img"&gt; &lt;img src="http://img4.imgtn.bdimg.com/it/u=3407532446,2830180038&amp;fm=27&amp;gp=0.jpg"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="wrap"&gt; &lt;div class="img"&gt; &lt;img src="http://img0.imgtn.bdimg.com/it/u=30302420,912099376&amp;fm=27&amp;gp=0.jpg"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="wrap"&gt; &lt;div class="img"&gt; &lt;img src="http://img5.imgtn.bdimg.com/it/u=2347360460,2805552283&amp;fm=27&amp;gp=0.jpg"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 在html里写了很多的图片（这里没有写出来，也可以从后台拉取数据）然后对图片做一些样式的调整：1234567891011121314151617181920212223&lt;style&gt; * &#123; padding: 0px; margin: 0px; &#125; #main &#123; position: relative; &#125; .wrap &#123; padding: 15px 0px 0px 15px; float: left; &#125; .img &#123; padding: 10px; border-radius: 5px; border: 1px solid #ccc; box-shadow: 0 0 5px #ccc; &#125; .img img &#123; width: 240px; height: auto; &#125; &lt;/style&gt; 对图片做一些操作，宽度确定，高度auto;然后开始用js对这些图片做一些处理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;script&gt; window.onload = function () &#123; waterFull('main', 'wrap'); &#125; function waterFull(parent, children) &#123; var oParent = document.getElementById(parent); var oWraps = getByClass(oParent, children); //计算整个页面显示的列数 var oWrapWeight = oWraps[0].offsetWidth; var cols = Math.floor(document.documentElement.clientWidth / oWrapWeight); //设置main的宽度，并且居中 oParent.style.cssText = 'width:' + oWrapWeight * cols + 'px; margin: 0 auto'; //找出高度最小的图片，将下一个图片放在下面 //定义一个数组，存放每一列的高度，初始化存的是第一行的所有列的高度 var arrHeight = []; for (var i = 0; i &lt; oWraps.length; i++) &#123; if (i &lt; cols) &#123; arrHeight.push(oWraps[i].offsetHeight); &#125;else &#123; var minHeight = Math.min.apply(null, arrHeight); var minIndex = getMinhIndex(arrHeight, minHeight); oWraps[i].style.position = 'absolute'; oWraps[i].style.top = minHeight + 'px'; oWraps[i].style.left = minIndex * oWrapWeight + 'px'; arrHeight[minIndex] += oWraps[i].offsetHeight; &#125; &#125; &#125; function getByClass(parent, className) &#123; var boxArr = new Array();//用来获取所有class为box的元素 oElement = parent.getElementsByTagName('*'); for (var i = 0; i &lt; oElement.length; i++) &#123; if (oElement[i].className == className) &#123; boxArr.push(oElement[i]); &#125; &#125;; return boxArr; &#125; //获取当前最小值得下标 function getMinhIndex(array, min) &#123; for (var i in array) &#123; if (array[i] == min) return i; &#125; &#125; &lt;/script&gt; 搞定～]]></content>
      <categories>
        <category>Demo练习</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>Javascript</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react 16.0 新特性学习]]></title>
    <url>%2F2018%2F05%2F09%2Freact-16-0-%E6%96%B0%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[1、Fragment新版本的render可以返回数组、字符串、react组件、数字、boolean值v15.x必须要一个标签来包裹Before v161234567return ( &lt;div&gt; &lt;label htmlFor="name"&gt;名字：&lt;/label&gt; &lt;input id="name" type="text" placeholder="请输入名字"/&gt; &lt;button&gt;搜索&lt;/button&gt; &lt;/div&gt; ); When v16.0.01234567return ( [ &lt;label htmlFor="name"&gt;名字：&lt;/label&gt;, &lt;input id="name" type="text" placeholder="请输入名字"/&gt;, &lt;button&gt;搜索&lt;/button&gt; ]); Now v16.2.01234567return ( &lt;React.Fragment&gt; &lt;label htmlFor="name"&gt;名字：&lt;/label&gt; &lt;input id="name" type="text" placeholder="请输入名字"/&gt; &lt;button&gt;搜索&lt;/button&gt; &lt;/React.Fragment&gt;); 片段(fragments) 可以让你将子元素列表添加到一个分组中，并且不会在DOM中增加额外节点。key 是唯一可以传递给 Fragment 的属性1234567891011return ( &lt;dl&gt; &#123;props.items.map(item =&gt; ( // 没有`key`，将会触发一个key警告 &lt;React.Fragment key=&#123;item.id&#125;&gt; &lt;dt&gt;&#123;item.term&#125;&lt;/dt&gt; &lt;dd&gt;&#123;item.description&#125;&lt;/dd&gt; &lt;/React.Fragment&gt; ))&#125; &lt;/dl&gt; ); 简明写法&lt;&gt;&lt;/&gt;，但是还没有被更多的工具支持，它不支持 键(keys) 或 属性(attributes)。Further babel v7.0.0+ , babel-plugin-transform-react-jsx-source or babel-preset-react 1234567return ( &lt;&gt; &lt;label htmlFor="name"&gt;名字：&lt;/label&gt; &lt;input id="name" type="text" placeholder="请输入名字"/&gt; &lt;button&gt;搜索&lt;/button&gt; &lt;/&gt;); DOM Fragment 12345678910const select = document.getElementById('select')const values = [1, 2, 3]const fragment = document.createDocumentFragment()values.map(item =&gt; &#123; const option = document.createElement('option') option.value = item option.innerHTML = `小明$&#123;item&#125;号` fragment.appendChild(option)&#125;)select.appendChild(fragment) 2、PortalsPortals是reactjs16提供的官方解决方案，使得组件可以脱离父组件层级挂载在DOM树的任何位置。普通情况下，组件的render函数返回的元素会被挂载在它的父级组件上。然而，有些元素需要被挂载在更高层级的位置。最典型的应用场景：当父组件具有overflow: hidden或者z-index的样式设置时，组件有可能被其他元素遮挡，就可以考虑使用Portal使组件的挂载脱离父组件。组件的挂载点虽然可以脱离父组件，但组件的事件通过冒泡机制仍可以传给父组件。1234&lt;body&gt; &lt;div id="bd"&gt;&lt;/div&gt; &lt;div id="modal"&gt;&lt;/div&gt;&lt;/body&gt; 123456789101112render( &lt;App&gt; &lt;SearchBox&gt; &lt;Modal&gt; &lt;div&gt;模态框&lt;/div&gt; &lt;/Modal&gt; &lt;/SearchBox&gt; &lt;/App&gt;, document.getElementById('bd'), () =&gt; &#123; console.log(arguments)&#125;) 1234567891011121314class App extends Component&#123; constructor(options) &#123; super(options) this.handleClick = this.handleClick.bind(this) &#125; handleClick() &#123; alert('react component tree propagation!') &#125; render() &#123; return &lt;div className="app" onClick=&#123;this.handleClick&#125;&gt; &#123;this.props.children&#125; &lt;/div&gt; &#125;&#125; 12345678class Modal extends Component &#123; constructor(options) &#123; super(options) &#125; render() &#123; return createPortal(this.props.children, document.getElementById('modal')) &#125; &#125; 12345678910&lt;div id="bd"&gt; &lt;div class="app"&gt; &lt;label for="name"&gt;名字：&lt;/label&gt; &lt;input type="text" id="name" placeholder="请输入名字"&gt; &lt;button&gt;搜索&lt;/button&gt; &lt;/div&gt;&lt;/div&gt;&lt;div id="modal"&gt; &lt;div&gt;模态框&lt;/div&gt;&lt;/div&gt; 1234567891011121314&lt;App&gt; &lt;div className=&quot;app&quot; onClick=bound handleClick()&gt; &lt;SearchBox&gt; &lt;labelhtmlFor=&quot;name&quot;&gt;名字：&lt;/label&gt; &lt;inputid=&quot;name&quot;type=&quot;text&quot;placeholder=&quot;请输入名字&quot;&gt;&lt;/input&gt; &lt;button&gt;搜索&lt;/button&gt; &lt;Modal&gt; &lt;ReactPortal target=HTMLDivElement&#123;…&#125;&gt; &lt;div&gt;模态框&lt;/div&gt; &lt;/ReactPortal&gt; &lt;/Modal&gt; &lt;/SearchBox&gt; &lt;/div&gt;&lt;/App&gt; Before portals 123456789101112131415161718ReactDom.render(reactChild, container, callback)ReactDom.unmountComponentAtNode(container)ReactDom.unstable_renderSubtreeIntoContainer( context, reactChild, domNode, callback)ReactDom.unmountComponentAtNode(container)render: ReactMount._renderSubtreeIntoContainer(null, reactChild, container, callback )unstable_renderSubtreeIntoContainer: ReactMount._renderSubtreeIntoContainer(context, reactChild, container, callback) 3、Error Boundaries之前react在渲染过程中或者是生命周期内出现了致命的错误，react会从根组件上把所有的组件都卸载下来，以防止展现错误的数据，但这不是最好的用户体验。React 16修复了这一点，引入了Error Boundary的概念，中文译为“错误边界”，当某个组件发生错误时，我们可以通过Error Boundary捕获到错误并对错误做优雅处理。（注：它并不能捕获runtime所有的错误，比如组件回调事件里的错误，可以把它想象成传统的try-catch语句） 123456789101112131415161718192021class ErrorBoundary extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; hasError: false &#125;; &#125;// 新增了componentDidCatch这个生命周期函数，它可以捕获自身及子树上的错误并对错误做优雅处理，包括上报错误日志、展示出错提示，而不是卸载整个组件树。 componentDidCatch(error, info) &#123; // 错误代理组件的展示与否 this.setState(&#123; hasError: true &#125;); // 在这里我们可以对错误进行记录 logErrorToMyService(error, info); &#125; render() &#123; if (this.state.hasError) &#123; // 在这里我们可以书写自己想要展示的ui组件 return &lt;h1&gt;Something went wrong.&lt;/h1&gt;; &#125; return this.props.children; &#125;&#125; 上面的组件是当页面中有错误时我们想要展示的效果，具体用法如下:12345678910render()&#123; return ( &lt;div&gt; &lt;ErrorBoundary&gt; // 外层组件我们定义的错误组件 &lt;Profile user=&#123;this.state.user&#125; /&gt; // 内层组件是我们将要监视的自定义组件 &lt;/ErrorBoundary&gt; &lt;button onClick=&#123;this.onClick&#125;&gt;Update&lt;/button&gt; &lt;/div&gt; )&#125; 这个组件能够不仅仅能够监听到本组件的错误，连同它下面的子组件的错误也可以监听到 ###不能捕获的错误 事件处理 异步回调 服务端渲染 error boundary组件自身抛出的错误（只能由父级捕获）###react遇到未捕获的错误会怎么办对 React16 来说，一个未捕获的错误会导致整个应用不能被挂载 4、setState传入null时不会再触发更新之前的setState不管传入什么只要调用了这么方法就会渲染123456789selectCity(e)&#123; const newValue = e.target.value; this.setState((state)=&gt;&#123; if(state.city===newValue)&#123; return null; &#125; return &#123;city:newValue&#125; &#125;)) 5、v16.0支持自定义的dom属性之前的版本对于自定义属性react会在属性前加上data-**来进行处理，现在对于部分属性去除了这种写法，拥抱了原生dom，这样可以减少react的代码，提升了性能 6、其他更好的服务器端渲染：React 16的SSR被完全重写，新的实现非常快，接近3倍性能于React 15，现在提供一种流模式streaming，可以更快地把渲染的字节发送到客户端。 react v16采用了最新的技术“Fiber.” React Server Side Rendering 解决 SPA 应用的 SEO 问题]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Event Loop 问题理解]]></title>
    <url>%2F2018%2F05%2F09%2FEvent-Loop-%E9%97%AE%E9%A2%98%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Q1:事件循环机制是什么？A1:JavaScript 是典型的单线程单并发语言，即表示在同一时间内其只能执行单个任务，同域浏览器中 JavaScript 主线程拥有一个函数调用栈(主线程)以及多个任务队列。 Q2:什么是任务？A2:任务分为两种，一种是同步任务，一种是异步任务。 同步任务，就是主线程中排队执行的任务； 异步任务，不先进入主线程，而是先进入“任务队列”的任务，只有任务队列通知了主线程，某个异步任务可以执行了，该任务才会进入主线程执行 Q3:事件循环（Event Loop）的原理是什么？A3:首先，主线程会依次执行代码。 当主线栈的函数调用栈为空时，即会根据事件循环（Event Loop）机制来从任务队列中提取出待执行的回调并执行。 执行的过程同样会进行函数帧的入栈出栈操作。这样不断的循环往复，这就是事件循环（Event Loop）。 只要主线程空了，就会去读取”任务队列”，这就是JavaScript的运行机制 Q4:任务队列中的任务有几种？A4:任务队列中的任务分为两种：MacroTask (task) 和 MicroTask 。Event Loop 处理这两种任务。 Q5:MacroTask (task) 和 MicroTask各包含什么任务？A5: microtasks:process.nextTick promise Object.observe MutationObserver macrotasks:setTimeout setInterval setImmediate I/O UI渲染 Q6:MacroTask和MicroTask的运行机制是什么？A6:事件循环的顺序，决定了JavaScript代码的执行顺序。它从script(整体代码)开始第一次循环。之后全局上下文进入函数调用栈。直到调用栈清空(只剩全局)，然后执行所有的microtask。当所有可执行的micro-task执行完毕之后。循环再次从macro-task开始，找到其中一个任务队列执行完毕，然后再执行所有的micro-task，这样一直循环下去。一句话说，microtask将会被添加到任务队列末尾进行处理。 MacroTask运行机制MicroTask运行机制Q7:来尝试一道面试题123456789101112131415161718192021222324252627282930313233343536373839console.log('start')const interval = setInterval(() =&gt; &#123; console.log('setInterval')&#125;, 0)setTimeout(() =&gt; &#123; console.log('setTimeout 1') Promise.resolve() .then(() =&gt; &#123; console.log('promise 3') &#125;) .then(() =&gt; &#123; console.log('promise 4') &#125;) .then(() =&gt; &#123; setTimeout(() =&gt; &#123; console.log('setTimeout 2') Promise.resolve() .then(() =&gt; &#123; console.log('promise 5') &#125;) .then(() =&gt; &#123; console.log('promise 6') &#125;) .then(() =&gt; &#123; clearInterval(interval) &#125;) &#125;, 0) &#125;)&#125;, 0)Promise.resolve() .then(() =&gt; &#123; console.log('promise 1') &#125;) .then(() =&gt; &#123; console.log('promise 2') &#125;) A7:startpromise 1promise 2setIntervalsetTimeout 1promise 3promise 4setIntervalsetTimeout 2promise 5promise 6]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PWA 之Q&A]]></title>
    <url>%2F2018%2F05%2F08%2FPWA-%E4%B9%8BQ-A%2F</url>
    <content type="text"><![CDATA[——吉吉《PWA初窥》学习笔记 Q1：什么是PWA？A1: PWA全称Progressive Web App，即渐进式WEB应用。一个 PWA 应用首先是一个网页, 可以通过 Web 技术编写出一个网页应用. 随后添加上 App Manifest 和 Service Worker 来实现 PWA 的安装和离线等功能 Q2: PWA解决了什么问题？A2: 1) 可以添加至主屏幕，点击主屏幕图标可以实现启动动画以及隐藏地址栏 2）实现离线缓存功能，即使用户手机没有网络，依然可以使用一些离线功能 3）实现了消息推送 Q3: App Manifest 是什么，有什么用？A3: Web应用程序清单在一个JSON文本文件中提供有关应用程序的信息（如名称，作者，图标和描述）。manifest 的目的是将Web应用程序安装到设备的主屏幕，为用户提供更快的访问和更丰富的体验。 Q4: 什么是service worker，有什么作用？A4: Service Worker 是 Chrome 团队提出和力推的一个 WEB API，用于给 web 应用提供高级的可持续的后台处理能力。 Service Workers 就像介于服务器和网页之间的拦截器，能够拦截进出的HTTP 请求，从而完全控制你的网站。 Q5: service worker 有什么特点？A5：1）resource caching and push notifications 2）client-side programmable proxy between web app and the outside world 3）service workers run independent of the application they are associated with 4）the primary uses for a service workers are to act as a caching agent to handle network requests 5）and to store content for offline use and secondly to handle push messaging the 6）information that you need to persist and reuse across restartswork with IndexedDB databases 7）promise-based 8）only available on secure origins(https) Q6: HTTP缓存与service worker缓存有什么区别A6: HTTP缓存 Web 服务器可以使用 Expires 首部来通知 Web 客户端，它可以使用资源的当前副本，直到指定的“过期 时间”。反过来，浏览器可以缓存此资源，并且只有在有效期满后才会再次检查新版本。 使用 HTTP 缓存意味着你要依赖服务器来告诉你何时缓存资源和何时过期。 service worker缓存 Service Workers 的强大在于它们拦截 HTTP 请求的能力 进入任何传入的 HTTP 请求，并决定想要如何响应。在你的 Service Worker 中，可以编写逻辑来决定 想要缓存的资源，以及需要满足什么条件和资源需要缓存多久。一切尽归你掌控！ Q7: service worker的生命周期是怎样的？A7: Q8: 怎么配置一个PWAA8: 1）准备一个html文件，以及相应的css等：12345678910&lt;head&gt; &lt;title&gt;Minimal PWA&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, user-scalable=no" /&gt; &lt;link rel="stylesheet" type="text/css" href="main.css"&gt; &lt;link rel="manifest" href="manifest.json" /&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;Revision 1&lt;/h3&gt; &lt;div class="main-text"&gt;Minimal PWA, open Console for more~~~&lt;/div&gt;&lt;/body&gt; 2）添加manifest.json文件 123456789101112131415&#123; "name": "Minimal app to try PWA", "short_name": "Minimal PWA", "display": "standalone", "start_url": "/", "theme_color": "#8888ff", "background_color": "#aaaaff", "icons": [ &#123; "src": "e.png", "sizes": "256x256", "type": "image/png" &#125; ]&#125; 3)添加Service WorkerService Worker 在网页已经关闭的情况下还可以运行, 用来实现页面的缓存和离线, 后台通知等等功能。sw.js 文件需要在 HTML 当中引入:12345678&lt;script&gt; if (navigator.serviceWorker != null) &#123; navigator.serviceWorker.register('sw.js') .then(function(registration) &#123; console.log('Registered events at scope: ', registration.scope); &#125;); &#125;&lt;/script&gt; 4)处理静态缓存12345678var cacheStorageKey = 'minimal-pwa-1'var cacheList = [ '/', "index.html", "main.css", "e.png"] 借助 Service Worker, 可以在注册完成安装 Service Worker 时, 抓取资源写入缓存:1234567self.addEventListener('install', e =&gt; &#123; e.waitUntil( caches.open(cacheStorageKey) .then(cache =&gt; cache.addAll(cacheList)) .then(() =&gt; self.skipWaiting()) )&#125;) 调用 self.skipWaiting() 方法是为了在页面更新的过程当中, 新的 Service Worker 脚本能立即激活和生效。5）处理动态缓存网页抓取资源的过程中, 在 Service Worker 可以捕获到 fetch 事件, 可以编写代码决定如何响应资源的请求:12345678910self.addEventListener('fetch', function(e) &#123; e.respondWith( caches.match(e.request).then(function(response) &#123; if (response != null) &#123; return response &#125; return fetch(e.request.url) &#125;) )&#125;) 真实的项目当中, 可以根据资源的类型, 站点的特点, 可以专门设计复杂的策略。fetch 事件当中甚至可以手动生成 Response 返回给页面。6)更新静态资源缓存的资源随着版本的更新会过期, 所以会根据缓存的字符串名称(这里变量为 cacheStorageKey, 值用了 “minimal-pwa-1”)清除旧缓存, 可以遍历所有的缓存名称逐一判断决决定是否清除(备注: 简化的写法, Promise.all 中 return undefined 可能出错, 见评论): 123456789101112self.addEventListener('activate', function(e) &#123; e.waitUntil( Promise.all( cacheNames.filter(name =&gt; &#123; return name !== cacheStorageKey &#125;).map(name =&gt; &#123; return caches.delete(name) &#125;) ).then(() =&gt; self.clients.claim()) &#125;) )&#125;) 在新安装的 Service Worker 中通过调用 self.clients.claim() 取得页面的控制权, 这样之后打开页面都会使用版本更新的缓存。旧的 Service Worker 脚本不再控制着页面之后会被停止。 相关文章： PWA 入门: 写个非常简单的 PWA 页面 讲讲PWA 您的第一个 Progressive Web App]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Javascript 继承学习]]></title>
    <url>%2F2018%2F05%2F08%2FJavascript%20%E7%BB%A7%E6%89%BF%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[javascript的继承方式有好多方式，之前ES5通过原型链继承，ES6中引入了Class，javascript可以像java一样使用extends关键字继承。现在整理一下js中的继承方式。 ES5中的继承方式 一、构造函数的继承现在有一个”动物”对象的构造函数123function Animal()&#123; this.species = "动物";&#125; 还有一个”猫”对象的构造函数。 1234function Cat(name,color)&#123; this.name = name; this.color = color;&#125; 1.构造函数绑定:使用call或apply方法，将父对象的构造函数绑定在子对象上。 1234567function Cat(name,color)&#123; Animal.apply(this, arguments); this.name = name; this.color = color;&#125;var cat1 = new Cat("大毛","黄色");alert(cat1.species); // 动物 此种继承方式只能继承父构造函数中的属性,不能继承父构造函数原型上的属性.Animal.apply(this, arguments)也可用Animal.call(this)替换.cat对象有两个层级,第一级存放着自有属性以及父构造器中的属性,第二级存放着自己函数原型上的属性(Cat.prototype) 2.prototype模式: 1234Cat.prototype = new Animal();Cat.prototype.constructor = Cat;var cat1 = new Cat("大毛","黄色");alert(cat1.species); // 动物 遵循一点，即如果替换了prototype对象，1o.prototype = &#123;&#125;; 那么，下一步必然是为新的prototype对象加上constructor属性，并将这个属性指回原来的构造函数。1o.prototype.constructor = o; 此种继承方式既能继承父构造函数中的属性,也能继承父构造函数原型上的属性.cat对象有三个层级,第一级存放着自有属性,第二级存放着父构造器的属性(加上constructor,指向创建该对象(cat)的构造器(Cat)),第三级存放着父构造器原型上的属性. 3.直接继承prototype:第3种方法是对第2种方法的改进。由于Animal对象中，不变的属性都可以直接写入Animal.prototype。所以，我们也可以让Cat()跳过 Animal()，直接继承Animal.prototype。 先将Animal对象改写 12function Animal()&#123; &#125;Animal.prototype.species = "动物"; 然后，将Cat的prototype对象，然后指向Animal的prototype对象，这样就完成了继承。 1234Cat.prototype = Animal.prototype;Cat.prototype.constructor = Cat;var cat1 = new Cat("大毛","黄色");alert(cat1.species); // 动物 此种继承方式只能继承父构造器原型上的属性.cat对象有两个层级,第一级存放着自有属性,第二级存放着父构造器原型上的属性(加上constructor,指向创建该对象(cat)的构造器(Cat)).注意:Cat.prototype.constructor = Cat会将Animal.prototype.constructor也改成Cat,从而影响父构造器创建对象 4.空对象作为中介: 1234567function extend(Child, Parent) &#123; var F = function()&#123;&#125;; F.prototype = Parent.prototype; Child.prototype = new F(); Child.prototype.constructor = Child; Child.uber = Parent.prototype;&#125; 用法： 123extend(Cat,Animal);var cat1 = new Cat("大毛","黄色");alert(cat1.species); // 动物 此种继承方式只能继承父构造器原型上的属性.cat对象有三个层级,第一级存放着自有属性,第二级存放着临时构造器F的属性(加上constructor,指向创建该对象(cat)的构造器(Cat)),第三级存放着父构造器原型上的属性.注意:临时构造器只充当中介的作用,一般不会有自己的属性. 5.浅拷贝继承:首先，还是把Animal的所有不变属性，都放到它的prototype对象上。12function Animal()&#123; &#125;Animal.prototype.species = "动物"; 然后，再写一个函数，实现属性拷贝的目的。12345678function extend2(Child, Parent) &#123; var p = Parent.prototype; var c = Child.prototype; for (var i in p) &#123; c[i] = p[i]; &#125; c.uber = p;&#125; 用法： 123extend2(Cat, Animal);var cat1 = new Cat("大毛","黄色");alert(cat1.species); // 动物 此种继承方式只能继承父构造器原型上的属性.cat对象有两个层级,第一级存放着自有属性,第二级存放着父构造器原型上的除了constructor和proto的属性(不会拷贝原型上的constructor和proto属性).适合父构造器原型上的自增属性为基本数据类型的情况. 二、非构造函数的继承比如，现在有一个对象，叫做”中国人”。123var Chinese = &#123; nation:'中国'&#125;; 还有一个对象，叫做”医生”。123var Doctor =&#123; career:'医生'&#125; 1.object()方法 12345function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125; 这个object()函数，其实只做一件事，就是把子对象的prototype属性，指向父对象，从而使得子对象与父对象连在一起。用法：第一步先在父对象的基础上，生成子对象：1var Doctor = object(Chinese); 然后，再加上子对象本身的属性：1Doctor.career = '医生'; 这时，子对象已经继承了父对象的属性了。1alert(Doctor.nation); //中国 2.浅拷贝除了使用”prototype链”以外，还有另一种思路：把父对象的属性，全部拷贝给子对象，也能实现继承。 就是在做拷贝：12345678function extendCopy(p) &#123;var c = &#123;&#125;;for (var i in p) &#123; c[i] = p[i];&#125;c.uber = p;return c;&#125; 用法，这样写：123var Doctor = extendCopy(Chinese);Doctor.career = '医生';alert(Doctor.nation); // 中国 样的拷贝有一个问题。那就是，如果父对象的属性等于数组或另一个对象，那么实际上，子对象获得的只是一个内存地址，而不是真正拷贝，因此存在父对象被篡改的可能。 3.深拷贝所谓”深拷贝”，就是能够实现真正意义上的数组和对象的拷贝。它的实现并不难，只要递归调用”浅拷贝”就行了。123456789101112function deepCopy(p, c) &#123; var c = c || &#123;&#125;; for (var i in p) &#123; if (typeof p[i] === 'object') &#123; c[i] = (p[i].constructor === Array) ? [] : &#123;&#125;; deepCopy(p[i], c[i]); &#125; else &#123; c[i] = p[i]; &#125; &#125; return c;&#125; 使用的时候这样写：1var Doctor = deepCopy(Chinese); 现在，给父对象加一个属性，值为数组。然后，在子对象上修改这个属性：这时，父对象就不会受到影响了。目前，jQuery库使用的就是这种继承方法。 ES6中的继承方式Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。123456789101112class Point &#123; //一些属性&#125;class ColorPoint extends Point &#123; //一些属性&#125;// 等同于class ColorPoint extends Point &#123; constructor(...args) &#123; super(...args); &#125;&#125; 上面代码定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Point类。 如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。 在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例。 ES6 规定，在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
</search>
